
msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-04-08 21:56+0200\n"
"Last-Translator: <EMAIL@ADDRESS>\n"
"Language-Team: Language pt-BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt-BR\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src\SUMMARY.md:3
#, fuzzy
msgid "Introduction"
msgstr "Introdução"

#: src\SUMMARY.md:4
#, fuzzy
msgid "Translations"
msgstr "Traduções"

#: src\SUMMARY.md:5
#, fuzzy
msgid "Idioms"
msgstr "expressões idiomáticas"

#: src\SUMMARY.md:6
#, fuzzy
msgid "Use borrowed types for arguments"
msgstr "Use tipos emprestados para argumentos"

#: src\SUMMARY.md:7
#, fuzzy
msgid "Concatenating Strings with format!"
msgstr "Concatenando Strings com formato!"

#: src\SUMMARY.md:8
#, fuzzy
msgid "Constructor"
msgstr "Construtor"

#: src\SUMMARY.md:9
#, fuzzy
msgid "The Default Trait"
msgstr "A característica padrão"

#: src\SUMMARY.md:10
#, fuzzy
msgid "Collections Are Smart Pointers"
msgstr "Coleções são ponteiros inteligentes"

#: src\SUMMARY.md:11
#, fuzzy
msgid "Finalisation in Destructors"
msgstr "Finalização em Destruidores"

#: src\SUMMARY.md:12
#, fuzzy
msgid "mem::{take(_), replace(_)}"
msgstr "mem::{pegar(_), substituir(_)}"

#: src\SUMMARY.md:13
#, fuzzy
msgid "On-Stack Dynamic Dispatch"
msgstr "Despacho dinâmico na pilha"

#: src\SUMMARY.md:14 src\SUMMARY.md:40
#, fuzzy
msgid "Foreign function interface (FFI)"
msgstr "Interface de função externa (FFI)"

#: src\SUMMARY.md:15
#, fuzzy
msgid "Idiomatic Errors"
msgstr "Erros idiomáticos"

#: src\SUMMARY.md:16
#, fuzzy
msgid "Accepting Strings"
msgstr "Aceitando Strings"

#: src\SUMMARY.md:17
#, fuzzy
msgid "Passing Strings"
msgstr "Cordas de passagem"

#: src\SUMMARY.md:18
#, fuzzy
msgid "Iterating over an Option"
msgstr "Iterando sobre uma opção"

#: src\SUMMARY.md:19
#, fuzzy
msgid "Pass Variables to Closure"
msgstr "Passar Variáveis para Encerramento"

#: src\SUMMARY.md:20
#, fuzzy
msgid "Privacy For Extensibility"
msgstr "Privacidade para Extensibilidade"

#: src\SUMMARY.md:21
#, fuzzy
msgid "Easy doc initialization"
msgstr "Fácil inicialização do documento"

#: src\SUMMARY.md:22
#, fuzzy
msgid "Temporary mutability"
msgstr "Mutabilidade temporária"

#: src\SUMMARY.md:23
#, fuzzy
msgid "Return consumed arg on error"
msgstr "Retorno arg consumido em caso de erro"

#: src\SUMMARY.md:25
#, fuzzy
msgid "Design Patterns"
msgstr "Padrões de design"

#: src\SUMMARY.md:26
#, fuzzy
msgid "Behavioural"
msgstr "Comportamental"

#: src\SUMMARY.md:27
#, fuzzy
msgid "Command"
msgstr "Comando"

#: src\SUMMARY.md:28
#, fuzzy
msgid "Interpreter"
msgstr "Intérprete"

#: src\SUMMARY.md:29
#, fuzzy
msgid "Newtype"
msgstr "Newtype"

#: src\SUMMARY.md:30
#, fuzzy
msgid "RAII Guards"
msgstr "Guardas RAII"

#: src\SUMMARY.md:31
#, fuzzy
msgid "Strategy"
msgstr "Estratégia"

#: src\SUMMARY.md:32
#, fuzzy
msgid "Visitor"
msgstr "Visitante"

#: src\SUMMARY.md:33
#, fuzzy
msgid "Creational"
msgstr "criacional"

#: src\SUMMARY.md:34
#, fuzzy
msgid "Builder"
msgstr "Construtor"

#: src\SUMMARY.md:35
#, fuzzy
msgid "Fold"
msgstr "Dobrar"

#: src\SUMMARY.md:36
#, fuzzy
msgid "Structural"
msgstr "Estrutural"

#: src\SUMMARY.md:37
#, fuzzy
msgid "Compose Structs"
msgstr "Compor Estruturas"

#: src\SUMMARY.md:38
#, fuzzy
msgid "Prefer Small Crates"
msgstr "Prefira caixas pequenas"

#: src\SUMMARY.md:39
#, fuzzy
msgid "Contain unsafety in small modules"
msgstr "Contenha a insegurança em pequenos módulos"

#: src\SUMMARY.md:41
#, fuzzy
msgid "Object-Based APIs"
msgstr "APIs baseadas em objetos"

#: src\SUMMARY.md:42
#, fuzzy
msgid "Type Consolidation into Wrappers"
msgstr "Digite a consolidação em wrappers"

#: src\SUMMARY.md:44
#, fuzzy
msgid "Anti-patterns"
msgstr "Antipadrões"

#: src\SUMMARY.md:45
#, fuzzy
msgid "Clone to satisfy the borrow checker"
msgstr "Clone para satisfazer o verificador de empréstimo"

#: src\SUMMARY.md:46
#, fuzzy
msgid "#[deny(warnings)]"
msgstr "#[negar(avisos)]"

#: src\SUMMARY.md:47
#, fuzzy
msgid "Deref Polymorphism"
msgstr "Polimorfismo Deref"

#: src\SUMMARY.md:49
#, fuzzy
msgid "Functional Programming"
msgstr "Programação Funcional"

#: src\SUMMARY.md:50
#, fuzzy
msgid "Programming paradigms"
msgstr "Paradigmas de programação"

#: src\SUMMARY.md:51
#, fuzzy
msgid "Generics as Type Classes"
msgstr "Genéricos como Classes de Tipo"

#: src\SUMMARY.md:52
#, fuzzy
msgid "Lenses and Prisms"
msgstr "Lentes e Prismas"

#: src\SUMMARY.md:54
#, fuzzy
msgid "Additional Resources"
msgstr "Recursos adicionais"

#: src\SUMMARY.md:55
#, fuzzy
msgid "Design principles"
msgstr "Princípios de design"

#: src\intro.md:1
#, fuzzy
msgid "# Introduction"
msgstr "# Introdução"

#: src\intro.md:3
#, fuzzy
msgid "## Participation"
msgstr "## Participação"

#: src\intro.md:5
#, fuzzy
msgid ""
"If you are interested in contributing to this book, check out the\n"
"[contribution "
"guidelines](https://github.com/rust-unofficial/patterns/blob/master/CONTRIBUTING.md)."
msgstr ""
"Se você estiver interessado em contribuir para este livro, confira o\n"
"[diretrizes de "
"contribuição](https://github.com/rust-unofficial/patterns/blob/master/CONTRIBUTING.md)."

#: src\intro.md:8
#, fuzzy
msgid "## Design patterns"
msgstr "## Padrões de design"

#: src\intro.md:10
#, fuzzy
msgid ""
"In software development, we often come across problems that share\n"
"similarities regardless of the environment they appear in. Although the\n"
"implementation details are crucial to solve the task at hand, we may\n"
"abstract from these particularities to find the common practices that\n"
"are generically applicable."
msgstr ""
"No desenvolvimento de software, muitas vezes nos deparamos com problemas que "
"compartilham\n"
"semelhanças independentemente do ambiente em que aparecem.\n"
"detalhes de implementação são cruciais para resolver a tarefa em mãos, "
"podemos\n"
"abstrair dessas particularidades para encontrar as práticas comuns que\n"
"são genericamente aplicáveis."

#: src\intro.md:16
#, fuzzy
msgid ""
"Design patterns are a collection of reusable and tested solutions to\n"
"recurring problems in engineering. They make our software more modular,\n"
"maintainable, and extensible. Moreover, these patterns provide a common\n"
"language for developers, making them an excellent tool for effective\n"
"communication when problem-solving in teams."
msgstr ""
"Padrões de projeto são uma coleção de soluções reutilizáveis e testadas "
"para\n"
"problemas recorrentes na engenharia. Eles tornam nosso software mais "
"modular,\n"
"sustentável e extensível. Além disso, esses padrões fornecem uma\n"
"linguagem para desenvolvedores, tornando-os uma excelente ferramenta para\n"
"comunicação na solução de problemas em equipes."

#: src\intro.md:22 src\patterns/index.md:14
#, fuzzy
msgid "## Design patterns in Rust"
msgstr "## Padrões de design em Rust"

#: src\intro.md:24
#, fuzzy
msgid ""
"Rust is not object-oriented, and the combination of all its "
"characteristics,\n"
"such as functional elements, a strong type system, and the borrow checker,\n"
"makes it unique.\n"
"Because of this, Rust design patterns vary with respect to other\n"
"traditional object-oriented programming languages.\n"
"That's why we decided to write this book. We hope you enjoy reading it!\n"
"The book is divided in three main chapters:"
msgstr ""
"Rust não é orientado a objetos, e a combinação de todas as suas "
"características,\n"
"como elementos funcionais, um sistema de tipo forte e o verificador de "
"empréstimo,\n"
"torna único.\n"
"Por causa disso, os padrões de projeto do Rust variam em relação a outros\n"
"linguagens de programação tradicionais orientadas a objetos.\n"
"É por isso que decidimos escrever este livro. Esperamos que você goste de "
"lê-lo!\n"
"O livro está dividido em três capítulos principais:"

#: src\intro.md:32
#, fuzzy
msgid ""
"- [Idioms](./idioms/index.md): guidelines to follow when coding.\n"
"  They are the social norms of the community.\n"
"  You should break them only if you have a good reason for it.\n"
"- [Design patterns](./patterns/index.md): methods to solve common problems\n"
"  when coding.\n"
"- [Anti-patterns](./anti_patterns/index.md): methods to solve common "
"problems\n"
"  when coding.\n"
"  However, while design patterns give us benefits,\n"
"  anti-patterns create more problems."
msgstr ""
"- [Idioms](./idioms/index.md): orientações a seguir ao codificar.\n"
"  Eles são as normas sociais da comunidade.\n"
"  Você deve quebrá-los apenas se tiver um bom motivo para isso.\n"
"- [Padrões de design](./patterns/index.md): métodos para resolver problemas "
"comuns\n"
"  ao codificar.\n"
"- [Anti-padrões](./anti_patterns/index.md): métodos para resolver problemas "
"comuns\n"
"  ao codificar.\n"
"  No entanto, embora os padrões de projeto nos tragam benefícios,\n"
"  antipadrões criam mais problemas."

#: src\translations.md:1
#, fuzzy
msgid "# Translations"
msgstr "# Traduções"

#: src\translations.md:3
#, fuzzy
msgid ""
"We are utilizing "
"[mdbook-i18n-helper](https://github.com/google/mdbook-i18n-helpers).\n"
"Please read up on how to _add_ and _update_ translations in [their "
"repository](https://github.com/google/mdbook-i18n-helpers#creating-and-updating-translations)"
msgstr ""
"Estamos utilizando "
"[mdbook-i18n-helper](https://github.com/google/mdbook-i18n-helpers).\n"
"Leia sobre como _adicionar_ e _atualizar_ traduções em [seu "
"repositório](https://github.com/google/mdbook-i18n-helpers#creating-and-updating-translations)"

#: src\translations.md:6
#, fuzzy
msgid "## External translations"
msgstr "## Traduções externas"

#: src\translations.md:8
#, fuzzy
msgid "- [简体中文](https://fomalhauthmj.github.io/patterns/)"
msgstr "- [简体中文](https://fomalhauthmj.github.io/patterns/)"

#: src\translations.md:10
#, fuzzy
msgid ""
"If you want to add a translation, please open an issue in the\n"
"[main repository](https://github.com/rust-unofficial/patterns)."
msgstr ""
"Se você quiser adicionar uma tradução, abra um problema no\n"
"[repositório principal](https://github.com/rust-unofficial/patterns)."

#: src\idioms/index.md:1
#, fuzzy
msgid "# Idioms"
msgstr "# expressões idiomáticas"

#: src\idioms/index.md:3
#, fuzzy
msgid ""
"[Idioms](https://en.wikipedia.org/wiki/Programming_idiom) are commonly used\n"
"styles, guidelines and patterns largely agreed upon by a community.\n"
"Writing idiomatic code allows other developers to understand better what is\n"
"happening."
msgstr ""
"[idiomas](https://en.wikipedia.org/wiki/Programming_idiom) são comumente "
"usados\n"
"estilos, diretrizes e padrões amplamente aceitos por uma comunidade.\n"
"Escrever código idiomático permite que outros desenvolvedores entendam "
"melhor o que é\n"
"acontecendo."

#: src\idioms/index.md:8
#, fuzzy
msgid ""
"After all, the computer only cares about the machine code that is generated\n"
"by the compiler.\n"
"Instead, the source code is mainly beneficial to the developer.\n"
"So, since we have this abstraction layer, why not make it more readable?"
msgstr ""
"Afinal, o computador só se preocupa com o código de máquina que é gerado\n"
"pelo compilador.\n"
"Em vez disso, o código-fonte é benéfico principalmente para o "
"desenvolvedor.\n"
"Então, já que temos essa camada de abstração, por que não torná-la mais "
"legível?"

#: src\idioms/index.md:13
msgid ""
"Remember the [KISS "
"principle](https://en.wikipedia.org/wiki/KISS_principle):\n"
"\"Keep It Simple, Stupid\". It claims that \"most systems work best if they "
"are\n"
"kept simple rather than made complicated; therefore, simplicity should be a "
"key\n"
"goal in design, and unnecessary complexity should be avoided\"."
msgstr ""

#: src\idioms/index.md:18
#, fuzzy
msgid "> Code is there for humans, not computers, to understand."
msgstr "> O código existe para ser entendido por humanos, não por computadores."

#: src\idioms/coercion-arguments.md:1
#, fuzzy
msgid "# Use borrowed types for arguments"
msgstr "# Use tipos emprestados para argumentos"

#: src\idioms/coercion-arguments.md:3 src\idioms/concat-format.md:3
#: src\idioms/default.md:3 src\idioms/deref.md:3 src\idioms/dtor-finally.md:3
#: src\idioms/mem-replace.md:3 src\idioms/on-stack-dyn-dispatch.md:3
#: src\idioms/ffi/errors.md:3 src\idioms/ffi/accepting-strings.md:3
#: src\idioms/ffi/passing-strings.md:3 src\idioms/option-iter.md:3
#: src\idioms/pass-var-to-closure.md:3 src\idioms/priv-extend.md:3
#: src\idioms/temporary-mutability.md:3
#: src\idioms/return-consumed-arg-on-error.md:3
#: src\patterns/behavioural/command.md:3
#: src\patterns/behavioural/interpreter.md:3
#: src\patterns/behavioural/newtype.md:13 src\patterns/behavioural/RAII.md:3
#: src\patterns/behavioural/strategy.md:3 src\patterns/behavioural/visitor.md:3
#: src\patterns/creational/builder.md:3 src\patterns/creational/fold.md:3
#: src\patterns/structural/compose-structs.md:5
#: src\patterns/structural/small-crates.md:3
#: src\patterns/structural/unsafe-mods.md:3 src\patterns/ffi/export.md:3
#: src\patterns/ffi/wrappers.md:3 src\anti_patterns/borrow_clone.md:3
#: src\anti_patterns/deny-warnings.md:3 src\anti_patterns/deref.md:3
#: src\functional/generics-type-classes.md:3
#, fuzzy
msgid "## Description"
msgstr "## Descrição"

#: src\idioms/coercion-arguments.md:5
#, fuzzy
msgid ""
"Using a target of a deref coercion can increase the flexibility of your "
"code\n"
"when you are deciding which argument type to use for a function argument.\n"
"In this way, the function will accept more input types."
msgstr ""
"Usar um alvo de uma coerção deref pode aumentar a flexibilidade do seu "
"código\n"
"quando você está decidindo qual tipo de argumento usar para um argumento de "
"função.\n"
"Dessa forma, a função aceitará mais tipos de entrada."

#: src\idioms/coercion-arguments.md:9
#, fuzzy
msgid ""
"This is not limited to slice-able or fat pointer types.\n"
"In fact, you should always prefer using the **borrowed type** over\n"
"**borrowing the owned type**.\n"
"Such as `&str` over `&String`, `&[T]` over `&Vec<T>`, or `&T` over `&Box<T>`."
msgstr ""
"Isso não se limita aos tipos de ponteiro fat ou fat.\n"
"Na verdade, você deve sempre preferir usar o **tipo emprestado** em vez de\n"
"**emprestar o tipo próprio**.\n"
"Como `&str` sobre `&String`, `&[T]` sobre `&Vec<T>` ou `&T` sobre `&Box<T>`."

#: src\idioms/coercion-arguments.md:14
#, fuzzy
msgid ""
"Using borrowed types you can avoid layers of indirection for those "
"instances\n"
"where the owned type already provides a layer of indirection. For instance, "
"a\n"
"`String` has a layer of indirection, so a `&String` will have two layers of\n"
"indirection. We can avoid this by using `&str` instead, and letting "
"`&String`\n"
"coerce to a `&str` whenever the function is invoked."
msgstr ""
"Usando tipos emprestados, você pode evitar camadas de indireção para essas "
"instâncias\n"
"onde o tipo de propriedade já fornece uma camada de indireção. Por exemplo, "
"um\n"
"`String` tem uma camada de indireção, então um `&String` terá duas camadas "
"de\n"
"indireção. Podemos evitar isso usando `&str` e deixando `&String`\n"
"coagir a um `&str` sempre que a função for invocada."

#: src\idioms/coercion-arguments.md:20 src\idioms/concat-format.md:10
#: src\idioms/default.md:20 src\idioms/deref.md:9 src\idioms/dtor-finally.md:9
#: src\idioms/mem-replace.md:11 src\idioms/on-stack-dyn-dispatch.md:10
#: src\idioms/pass-var-to-closure.md:12 src\idioms/priv-extend.md:18
#: src\idioms/temporary-mutability.md:12
#: src\idioms/return-consumed-arg-on-error.md:8
#: src\patterns/behavioural/command.md:18
#: src\patterns/behavioural/newtype.md:18 src\patterns/behavioural/RAII.md:11
#: src\patterns/behavioural/strategy.md:28
#: src\patterns/behavioural/visitor.md:13 src\patterns/creational/builder.md:7
#: src\patterns/creational/fold.md:12
#: src\patterns/structural/compose-structs.md:17
#: src\anti_patterns/borrow_clone.md:11 src\anti_patterns/deny-warnings.md:8
#: src\anti_patterns/deref.md:8 src\functional/generics-type-classes.md:38
#, fuzzy
msgid "## Example"
msgstr "## Exemplo"

#: src\idioms/coercion-arguments.md:22
#, fuzzy
msgid ""
"For this example, we will illustrate some differences for using `&String` as "
"a\n"
"function argument versus using a `&str`, but the ideas apply as well to "
"using\n"
"`&Vec<T>` versus using a `&[T]` or using a `&Box<T>` versus a `&T`."
msgstr ""
"Para este exemplo, vamos ilustrar algumas diferenças para usar `&String` "
"como um\n"
"argumento de função versus usar um `&str`, mas as ideias também se aplicam "
"ao uso\n"
"`&Vec<T>` versus usar um `&[T]` ou usar um `&Box<T>` versus um `&T`."

#: src\idioms/coercion-arguments.md:26
#, fuzzy
msgid ""
"Consider an example where we wish to determine if a word contains three\n"
"consecutive vowels. We don't need to own the string to determine this, so "
"we\n"
"will take a reference."
msgstr ""
"Considere um exemplo em que desejamos determinar se uma palavra contém três\n"
"vogais consecutivas. Não precisamos ser os donos da string para determinar "
"isso, então\n"
"vai pegar uma referência."

#: src\idioms/coercion-arguments.md:30
#, fuzzy
msgid "The code might look something like this:"
msgstr "O código pode ser algo como isto:"

#: src\idioms/coercion-arguments.md:32
msgid ""
"```rust\n"
"fn three_vowels(word: &String) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let ferris = \"Ferris\".to_string();\n"
"    let curious = \"Curious\".to_string();\n"
"    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
"    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
"\n"
"    // This works fine, but the following two lines would fail:\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
"\n"
"}\n"
"```"
msgstr ""

#: src\idioms/coercion-arguments.md:62
#, fuzzy
msgid ""
"This works fine because we are passing a `&String` type as a parameter.\n"
"If we remove the comments on the last two lines, the example will fail. "
"This\n"
"is because a `&str` type will not coerce to a `&String` type. We can fix "
"this\n"
"by simply modifying the type for our argument."
msgstr ""
"Isso funciona bem porque estamos passando um tipo `&String` como parâmetro.\n"
"Se removermos os comentários nas duas últimas linhas, o exemplo falhará. "
"Esse\n"
"é porque um tipo `&str` não será forçado a um tipo `&String`. Nós podemos "
"consertar isso\n"
"simplesmente modificando o tipo do nosso argumento."

#: src\idioms/coercion-arguments.md:67
#, fuzzy
msgid "For instance, if we change our function declaration to:"
msgstr "Por exemplo, se mudarmos nossa declaração de função para:"

#: src\idioms/coercion-arguments.md:69
msgid ""
"```rust, ignore\n"
"fn three_vowels(word: &str) -> bool {\n"
"```"
msgstr ""

#: src\idioms/coercion-arguments.md:73
#, fuzzy
msgid "then both versions will compile and print the same output."
msgstr "então ambas as versões irão compilar e imprimir a mesma saída."

#: src\idioms/coercion-arguments.md:75
msgid ""
"```bash\n"
"Ferris: false\n"
"Curious: true\n"
"```"
msgstr ""

#: src\idioms/coercion-arguments.md:80
#, fuzzy
msgid ""
"But wait, that's not all! There is more to this story.\n"
"It's likely that you may say to yourself: that doesn't matter, I will never "
"be\n"
"using a `&'static str` as an input anyways (as we did when we used "
"`\"Ferris\"`).\n"
"Even ignoring this special example, you may still find that using `&str` "
"will\n"
"give you more flexibility than using a `&String`."
msgstr ""
"Mas espere, isso não é tudo! Há mais nesta história.\n"
"É provável que você diga a si mesmo: isso não importa, eu nunca serei\n"
"usando um `&'static str` como uma entrada de qualquer maneira (como fizemos "
"quando usamos `\"Ferris\"`).\n"
"Mesmo ignorando este exemplo especial, você ainda pode achar que usar "
"`&str`\n"
"dar-lhe mais flexibilidade do que usar um `&String`."

#: src\idioms/coercion-arguments.md:86
#, fuzzy
msgid ""
"Let's now take an example where someone gives us a sentence, and we want to\n"
"determine if any of the words in the sentence contain three consecutive "
"vowels.\n"
"We probably should make use of the function we have already defined and "
"simply\n"
"feed in each word from the sentence."
msgstr ""
"Vamos agora dar um exemplo onde alguém nos dá uma frase, e queremos\n"
"determine se alguma das palavras da frase contém três vogais consecutivas.\n"
"Provavelmente devemos usar a função que já definimos e simplesmente\n"
"alimente cada palavra da frase."

#: src\idioms/coercion-arguments.md:91
#, fuzzy
msgid "An example of this could look like this:"
msgstr "Um exemplo disso poderia ser assim:"

#: src\idioms/coercion-arguments.md:93
msgid ""
"```rust\n"
"fn three_vowels(word: &str) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let sentence_string =\n"
"        \"Once upon a time, there was a friendly curious crab named "
"Ferris\".to_string();\n"
"    for word in sentence_string.split(' ') {\n"
"        if three_vowels(word) {\n"
"            println!(\"{} has three consecutive vowels!\", word);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/coercion-arguments.md:121
#, fuzzy
msgid ""
"Running this example using our function declared with an argument type "
"`&str`\n"
"will yield"
msgstr ""
"Executando este exemplo usando nossa função declarada com um tipo de "
"argumento `&str`\n"
"vai render"

#: src\idioms/coercion-arguments.md:124
msgid ""
"```bash\n"
"curious has three consecutive vowels!\n"
"```"
msgstr ""

#: src\idioms/coercion-arguments.md:128
#, fuzzy
msgid ""
"However, this example will not run when our function is declared with an\n"
"argument type `&String`. This is because string slices are a `&str` and not "
"a\n"
"`&String` which would require an allocation to be converted to `&String` "
"which\n"
"is not implicit, whereas converting from `String` to `&str` is cheap and "
"implicit."
msgstr ""
"No entanto, este exemplo não será executado quando nossa função for "
"declarada com um\n"
"tipo de argumento `&String`. Isso ocorre porque as fatias de string são um "
"`&str` e não um\n"
"`&String` que exigiria uma alocação para ser convertida em `&String` que\n"
"não é implícito, enquanto a conversão de `String` para `&str` é barata e "
"implícita."

#: src\idioms/coercion-arguments.md:133 src\idioms/default.md:58
#: src\idioms/deref.md:76 src\idioms/dtor-finally.md:88
#: src\idioms/mem-replace.md:108 src\idioms/on-stack-dyn-dispatch.md:83
#: src\idioms/option-iter.md:46 src\idioms/priv-extend.md:120
#: src\patterns/behavioural/command.md:218
#: src\patterns/behavioural/interpreter.md:142
#: src\patterns/behavioural/newtype.md:104 src\patterns/behavioural/RAII.md:111
#: src\patterns/behavioural/strategy.md:174
#: src\patterns/behavioural/visitor.md:106
#: src\patterns/creational/builder.md:108 src\patterns/creational/fold.md:109
#: src\patterns/structural/small-crates.md:45
#: src\patterns/structural/unsafe-mods.md:32
#: src\anti_patterns/borrow_clone.md:68 src\anti_patterns/deny-warnings.md:96
#: src\anti_patterns/deref.md:123 src\functional/generics-type-classes.md:237
#, fuzzy
msgid "## See also"
msgstr "## Veja também"

#: src\idioms/coercion-arguments.md:135
#, fuzzy
msgid ""
"- [Rust Language Reference on Type "
"Coercions](https://doc.rust-lang.org/reference/type-coercions.html)\n"
"- For more discussion on how to handle `String` and `&str` see\n"
"  [this blog series "
"(2015)](https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html)\n"
"  by Herman J. Radtke III"
msgstr ""
"- [Rust Language Reference on Type "
"Coercions](https://doc.rust-lang.org/reference/type-coercions.html)\n"
"- Para mais discussões sobre como lidar com `String` e `&str` veja\n"
"  [esta série de blogs "
"(2015)](https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html "
")\n"
"  por Herman J. Radtke III"

#: src\idioms/concat-format.md:1
#, fuzzy
msgid "# Concatenating strings with `format!`"
msgstr "# Concatenando strings com `format!`"

#: src\idioms/concat-format.md:5
#, fuzzy
msgid ""
"It is possible to build up strings using the `push` and `push_str` methods "
"on a\n"
"mutable `String`, or using its `+` operator. However, it is often more\n"
"convenient to use `format!`, especially where there is a mix of literal and\n"
"non-literal strings."
msgstr ""
"É possível construir strings usando os métodos `push` e `push_str` em um\n"
"`String` mutável, ou usando seu operador `+`. No entanto, muitas vezes é "
"mais\n"
"conveniente usar `format!`, especialmente onde há uma mistura de literal e\n"
"strings não literais."

#: src\idioms/concat-format.md:12
msgid ""
"```rust\n"
"fn say_hello(name: &str) -> String {\n"
"    // We could construct the result string manually.\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"
"\n"
"    // But using format! is better.\n"
"    format!(\"Hello {}!\", name)\n"
"}\n"
"```"
msgstr ""

#: src\idioms/concat-format.md:25 src\idioms/deref.md:43
#: src\idioms/dtor-finally.md:42 src\idioms/mem-replace.md:83
#: src\idioms/on-stack-dyn-dispatch.md:48 src\idioms/ffi/errors.md:131
#: src\idioms/ffi/accepting-strings.md:68 src\idioms/ffi/passing-strings.md:68
#: src\idioms/pass-var-to-closure.md:48 src\idioms/temporary-mutability.md:38
#: src\idioms/return-consumed-arg-on-error.md:55
#: src\patterns/behavioural/newtype.md:66 src\patterns/behavioural/RAII.md:78
#: src\patterns/behavioural/strategy.md:96
#: src\patterns/creational/builder.md:68
#: src\patterns/structural/compose-structs.md:75
#: src\patterns/structural/small-crates.md:12
#: src\patterns/structural/unsafe-mods.md:11 src\patterns/ffi/export.md:111
#: src\patterns/ffi/wrappers.md:63 src\anti_patterns/deny-warnings.md:16
#: src\anti_patterns/deref.md:69 src\functional/generics-type-classes.md:210
#, fuzzy
msgid "## Advantages"
msgstr "## Vantagens"

#: src\idioms/concat-format.md:27
#, fuzzy
msgid ""
"Using `format!` is usually the most succinct and readable way to combine "
"strings."
msgstr ""
"Usar `format!` geralmente é a maneira mais sucinta e legível de combinar "
"strings."

#: src\idioms/concat-format.md:29 src\idioms/deref.md:50
#: src\idioms/dtor-finally.md:47 src\idioms/mem-replace.md:87
#: src\idioms/on-stack-dyn-dispatch.md:54 src\idioms/ffi/errors.md:136
#: src\idioms/ffi/accepting-strings.md:141
#: src\idioms/ffi/passing-strings.md:103 src\idioms/pass-var-to-closure.md:57
#: src\idioms/temporary-mutability.md:42
#: src\idioms/return-consumed-arg-on-error.md:59
#: src\patterns/behavioural/newtype.md:77
#: src\patterns/behavioural/strategy.md:104
#: src\patterns/creational/builder.md:76
#: src\patterns/structural/compose-structs.md:81
#: src\patterns/structural/small-crates.md:22
#: src\patterns/structural/unsafe-mods.md:17 src\patterns/ffi/export.md:234
#: src\patterns/ffi/wrappers.md:69 src\anti_patterns/deref.md:81
#: src\functional/generics-type-classes.md:221
#, fuzzy
msgid "## Disadvantages"
msgstr "## Desvantagens"

#: src\idioms/concat-format.md:31
#, fuzzy
msgid ""
"It is usually not the most efficient way to combine strings - a series of "
"`push`\n"
"operations on a mutable string is usually the most efficient (especially if "
"the\n"
"string has been pre-allocated to the expected size)."
msgstr ""
"Geralmente não é a maneira mais eficiente de combinar strings - uma série de "
"`push`\n"
"operações em uma string mutável é geralmente a mais eficiente (especialmente "
"se o\n"
"string foi pré-alocada para o tamanho esperado)."

#: src\idioms/ctor.md:1
#, fuzzy
msgid "# Constructors\r"
msgstr "# Construtores\r"

#: src\idioms/ctor.md:3 src\idioms/rustdoc-init.md:3
#, fuzzy
msgid "## Description\r"
msgstr "## Descrição\r"

#: src\idioms/ctor.md:5
#, fuzzy
msgid ""
"Rust does not have constructors as a language construct. Instead, the\r\n"
"convention is to use an [associated function][associated function] `new` to "
"create an object:"
msgstr ""
"Rust não possui construtores como uma construção de linguagem. Em vez disso, "
"o\r\n"
"A convenção é usar uma [função associada][função associada] `new` para criar "
"um objeto:"

#: src\idioms/ctor.md:8
msgid ""
"````rust\r\n"
"/// Time in seconds.\r\n"
"///\r\n"
"/// # Example\r\n"
"///\r\n"
"/// ```\r\n"
"/// let s = Second::new(42);\r\n"
"/// assert_eq!(42, s.value());\r\n"
"/// ```\r\n"
"pub struct Second {\r\n"
"    value: u64\r\n"
"}\r\n"
"\r\n"
"impl Second {\r\n"
"    // Constructs a new instance of [`Second`].\r\n"
"    // Note this is an associated function - no self.\r\n"
"    pub fn new(value: u64) -> Self {\r\n"
"        Self { value }\r\n"
"    }\r\n"
"\r\n"
"    /// Returns the value in seconds.\r\n"
"    pub fn value(&self) -> u64 {\r\n"
"        self.value\r\n"
"    }\r\n"
"}\r\n"
"````"
msgstr ""

#: src\idioms/ctor.md:35
#, fuzzy
msgid "## Default Constructors\r"
msgstr "## Construtores Padrão\r"

#: src\idioms/ctor.md:37
#, fuzzy
msgid ""
"Rust supports default constructors with the [`Default`][std-default] trait:"
msgstr ""
"Rust suporta construtores padrão com o atributo [`Default`][std-default]:"

#: src\idioms/ctor.md:39
msgid ""
"````rust\r\n"
"/// Time in seconds.\r\n"
"///\r\n"
"/// # Example\r\n"
"///\r\n"
"/// ```\r\n"
"/// let s = Second::default();\r\n"
"/// assert_eq!(0, s.value());\r\n"
"/// ```\r\n"
"pub struct Second {\r\n"
"    value: u64\r\n"
"}\r\n"
"\r\n"
"impl Second {\r\n"
"    /// Returns the value in seconds.\r\n"
"    pub fn value(&self) -> u64 {\r\n"
"        self.value\r\n"
"    }\r\n"
"}\r\n"
"\r\n"
"impl Default for Second {\r\n"
"    fn default() -> Self {\r\n"
"        Self { value: 0 }\r\n"
"    }\r\n"
"}\r\n"
"````"
msgstr ""

#: src\idioms/ctor.md:66
#, fuzzy
msgid ""
"`Default` can also be derived if all types of all fields implement "
"`Default`,\r\n"
"like they do with `Second`:"
msgstr ""
"`Padrão` também pode ser derivado se todos os tipos de todos os campos "
"implementarem `Padrão`,\r\n"
"como eles fazem com `Second`:"

#: src\idioms/ctor.md:69
msgid ""
"````rust\r\n"
"/// Time in seconds.\r\n"
"///\r\n"
"/// # Example\r\n"
"///\r\n"
"/// ```\r\n"
"/// let s = Second::default();\r\n"
"/// assert_eq!(0, s.value());\r\n"
"/// ```\r\n"
"#[derive(Default)]\r\n"
"pub struct Second {\r\n"
"    value: u64\r\n"
"}\r\n"
"\r\n"
"impl Second {\r\n"
"    /// Returns the value in seconds.\r\n"
"    pub fn value(&self) -> u64 {\r\n"
"        self.value\r\n"
"    }\r\n"
"}\r\n"
"````"
msgstr ""

#: src\idioms/ctor.md:91
#, fuzzy
msgid ""
"**Note:** It is common and expected for types to implement both\r\n"
"`Default` and an empty `new` constructor. `new` is the constructor\r\n"
"convention in Rust, and users expect it to exist, so if it is\r\n"
"reasonable for the basic constructor to take no arguments, then it\r\n"
"should, even if it is functionally identical to default."
msgstr ""
"**Observação:** é comum e esperado que os tipos implementem ambos\r\n"
"`Default` e um construtor `new` vazio. `new` é o construtor\r\n"
"convenção em Rust, e os usuários esperam que ela exista, então se for\r\n"
"razoável para o construtor básico não receber argumentos, então\r\n"
"deve, mesmo que seja funcionalmente idêntico ao padrão."

#: src\idioms/ctor.md:97
#, fuzzy
msgid ""
"**Hint:** The advantage of implementing or deriving `Default` is that your "
"type\r\n"
"can now be used where a `Default` implementation is required, most "
"prominently,\r\n"
"any of the [`*or_default` functions in the standard library][std-or-default]."
msgstr ""
"**Dica:** A vantagem de implementar ou derivar `Default` é que seu tipo\r\n"
"agora pode ser usado onde uma implementação `Padrão` é necessária, "
"principalmente,\r\n"
"qualquer uma das funções [`*or_default` na biblioteca "
"padrão][std-or-default]."

#: src\idioms/ctor.md:101
#, fuzzy
msgid "## See also\r"
msgstr "## Veja também\r"

#: src\idioms/ctor.md:103
#, fuzzy
msgid ""
"- The [default idiom](default.md) for a more in-depth description of the\r\n"
"  `Default` trait.\r\n"
"\r\n"
"- The [builder pattern](../patterns/creational/builder.md) for "
"constructing\r\n"
"  objects where there are multiple configurations.\r\n"
"\r\n"
"- [API Guidelines/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS] for\r\n"
"  implementing both, `Default` and `new`.\r\n"
"\r"
msgstr ""
"- O [idioma padrão](default.md) para uma descrição mais detalhada do\r\n"
"  Traço `Padrão`.\r\n"
"\r\n"
"- O [padrão de construtor](../patterns/creational/builder.md) para "
"construir\r\n"
"  objetos onde existem múltiplas configurações.\r\n"
"\r\n"
"- [Diretrizes de API/C-COMMON-TRAITS][Diretrizes de API/C-COMMON-TRAITS] "
"para\r\n"
"  implementando ambos, `Default` e `new`.\r\n"
"\r"

#: src\idioms/default.md:1
#, fuzzy
msgid "# The `Default` Trait"
msgstr "# A Característica `Padrão`"

#: src\idioms/default.md:5
msgid ""
"Many types in Rust have a [constructor]. However, this is _specific_ to the\n"
"type; Rust cannot abstract over \"everything that has a `new()` method\". "
"To\n"
"allow this, the [`Default`] trait was conceived, which can be used with\n"
"containers and other generic types (e.g. see "
"[`Option::unwrap_or_default()`]).\n"
"Notably, some containers already implement it where applicable."
msgstr ""

#: src\idioms/default.md:11
#, fuzzy
msgid ""
"Not only do one-element containers like `Cow`, `Box` or `Arc` implement\n"
"`Default` for contained `Default` types, one can automatically\n"
"`#[derive(Default)]` for structs whose fields all implement it, so the more\n"
"types implement `Default`, the more useful it becomes."
msgstr ""
"Não apenas contêineres de um elemento como `Cow`, `Box` ou `Arc` "
"implementam\n"
"`Default` para tipos `Default` contidos, pode-se automaticamente\n"
"`#[derive(Default)]` para structs cujos campos todos o implementam, então "
"quanto mais\n"
"tipos implementam `Padrão`, mais útil ele se torna."

#: src\idioms/default.md:16
#, fuzzy
msgid ""
"On the other hand, constructors can take multiple arguments, while the\n"
"`default()` method does not. There can even be multiple constructors with\n"
"different names, but there can only be one `Default` implementation per type."
msgstr ""
"Por outro lado, os construtores podem receber vários argumentos, enquanto "
"os\n"
"O método `default()` não. Pode até haver vários construtores com\n"
"nomes diferentes, mas só pode haver uma implementação `Padrão` por tipo."

#: src\idioms/default.md:22
msgid ""
"```rust\n"
"use std::{path::PathBuf, time::Duration};\n"
"\n"
"// note that we can simply auto-derive Default here.\n"
"#[derive(Default, Debug, PartialEq)]\n"
"struct MyConfiguration {\n"
"    // Option defaults to None\n"
"    output: Option<PathBuf>,\n"
"    // Vecs default to empty vector\n"
"    search_path: Vec<PathBuf>,\n"
"    // Duration defaults to zero time\n"
"    timeout: Duration,\n"
"    // bool defaults to false\n"
"    check: bool,\n"
"}\n"
"\n"
"impl MyConfiguration {\n"
"    // add setters here\n"
"}\n"
"\n"
"fn main() {\n"
"    // construct a new instance with default values\n"
"    let mut conf = MyConfiguration::default();\n"
"    // do something with conf here\n"
"    conf.check = true;\n"
"    println!(\"conf = {:#?}\", conf);\n"
"        \n"
"    // partial initialization with default values, creates the same "
"instance\n"
"    let conf1 = MyConfiguration {\n"
"        check: true,\n"
"        ..Default::default()\n"
"    };\n"
"    assert_eq!(conf, conf1);\n"
"}\n"
"```"
msgstr ""

#: src\idioms/default.md:60
#, fuzzy
msgid ""
"- The [constructor] idiom is another way to generate instances that may or "
"may\n"
"  not be \"default\"\n"
"- The [`Default`] documentation (scroll down for the list of implementors)\n"
"- [`Option::unwrap_or_default()`]\n"
"- [`derive(new)`]"
msgstr ""
"- O idioma [constructor] é outra maneira de gerar instâncias que podem ou "
"podem\n"
"  não ser \"padrão\"\n"
"- A documentação [`Padrão`] (role para baixo para ver a lista de "
"implementadores)\n"
"- [`Option::unwrap_or_default()`]\n"
"- [`derivar(novo)`]"

#: src\idioms/deref.md:1
#, fuzzy
msgid "# Collections are smart pointers"
msgstr "# Coleções são ponteiros inteligentes"

#: src\idioms/deref.md:5
#, fuzzy
msgid ""
"Use the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)\n"
"trait to treat collections like smart pointers, offering owning\n"
"and borrowed views of data."
msgstr ""
"Use o [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)\n"
"característica para tratar coleções como ponteiros inteligentes, oferecendo "
"propriedade\n"
"e visualizações de dados emprestadas."

#: src\idioms/deref.md:11
msgid ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Vec<T> {\n"
"    data: RawVec<T>,\n"
"    //..\n"
"}\n"
"\n"
"impl<T> Deref for Vec<T> {\n"
"    type Target = [T];\n"
"\n"
"    fn deref(&self) -> &[T] {\n"
"        //..\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/deref.md:28
#, fuzzy
msgid ""
"A `Vec<T>` is an owning collection of `T`s, while a slice (`&[T]`) is a "
"borrowed\n"
"collection of `T`s. Implementing `Deref` for `Vec` allows implicit "
"dereferencing\n"
"from `&Vec<T>` to `&[T]` and includes the relationship in auto-derefencing\n"
"searches. Most methods you might expect to be implemented for `Vec`s are "
"instead\n"
"implemented for slices."
msgstr ""
"Um `Vec<T>` é uma coleção proprietária de `T`s, enquanto uma fatia (`&[T]`) "
"é um empréstimo\n"
"coleção de `T`s. A implementação de `Deref` para `Vec` permite a "
"desreferência implícita\n"
"de `&Vec<T>` para `&[T]` e inclui o relacionamento na desativação "
"automática\n"
"pesquisas. A maioria dos métodos que você pode esperar que sejam "
"implementados para `Vec`s são\n"
"implementado para fatias."

#: src\idioms/deref.md:34
#, fuzzy
msgid "Also `String` and `&str` have a similar relation."
msgstr "Além disso, `String` e `&str` têm uma relação semelhante."

#: src\idioms/deref.md:36 src\idioms/dtor-finally.md:32
#: src\idioms/mem-replace.md:57 src\idioms/on-stack-dyn-dispatch.md:37
#: src\idioms/ffi/accepting-strings.md:12 src\idioms/ffi/passing-strings.md:14
#: src\idioms/return-consumed-arg-on-error.md:43
#: src\patterns/behavioural/command.md:8
#: src\patterns/behavioural/interpreter.md:16
#: src\patterns/behavioural/newtype.md:56 src\patterns/behavioural/RAII.md:72
#: src\patterns/behavioural/strategy.md:19
#: src\patterns/behavioural/visitor.md:72 src\patterns/creational/builder.md:63
#: src\patterns/creational/fold.md:73
#: src\patterns/structural/compose-structs.md:71 src\patterns/ffi/export.md:15
#: src\anti_patterns/borrow_clone.md:30
#, fuzzy
msgid "## Motivation"
msgstr "## Motivação"

#: src\idioms/deref.md:38
#, fuzzy
msgid ""
"Ownership and borrowing are key aspects of the Rust language. Data "
"structures\n"
"must account for these semantics properly to give a good user\n"
"experience. When implementing a data structure that owns its data, offering "
"a\n"
"borrowed view of that data allows for more flexible APIs."
msgstr ""
"Propriedade e empréstimo são aspectos-chave da linguagem Rust. Estruturas de "
"dados\n"
"deve levar em conta essas semânticas adequadamente para dar a um bom "
"usuário\n"
"experiência. Ao implementar uma estrutura de dados proprietária de seus "
"dados, oferecendo uma\n"
"A visão emprestada desses dados permite APIs mais flexíveis."

#: src\idioms/deref.md:45
#, fuzzy
msgid ""
"Most methods can be implemented only for the borrowed view, they are then\n"
"implicitly available for the owning view."
msgstr ""
"A maioria dos métodos pode ser implementada apenas para a visão emprestada, "
"eles são então\n"
"implicitamente disponível para a exibição proprietária."

#: src\idioms/deref.md:48
#, fuzzy
msgid "Gives clients a choice between borrowing or taking ownership of data."
msgstr ""
"Dá aos clientes a escolha entre tomar emprestado ou se apropriar dos dados."

#: src\idioms/deref.md:52
#, fuzzy
msgid ""
"Methods and traits only available via dereferencing are not taken into "
"account\n"
"when bounds checking, so generic programming with data structures using "
"this\n"
"pattern can get complex (see the `Borrow` and `AsRef` traits, etc.)."
msgstr ""
"Métodos e características disponíveis apenas por desreferenciação não são "
"levados em consideração\n"
"ao verificar limites, então programação genérica com estruturas de dados "
"usando este\n"
"padrão pode se tornar complexo (veja as características `Borrow` e `AsRef`, "
"etc.)."

#: src\idioms/deref.md:56 src\idioms/dtor-finally.md:61
#: src\idioms/mem-replace.md:97 src\idioms/on-stack-dyn-dispatch.md:68
#: src\idioms/priv-extend.md:85 src\patterns/behavioural/command.md:203
#: src\patterns/behavioural/interpreter.md:103
#: src\patterns/behavioural/newtype.md:85 src\patterns/behavioural/RAII.md:83
#: src\patterns/behavioural/strategy.md:110
#: src\patterns/behavioural/visitor.md:79 src\patterns/creational/builder.md:81
#: src\patterns/creational/fold.md:85
#: src\patterns/structural/compose-structs.md:89 src\anti_patterns/deref.md:102
#, fuzzy
msgid "## Discussion"
msgstr "## Discussão"

#: src\idioms/deref.md:58
#, fuzzy
msgid ""
"Smart pointers and collections are analogous: a smart pointer points to a "
"single\n"
"object, whereas a collection points to many objects. From the point of view "
"of\n"
"the type system, there is little difference between the two. A collection "
"owns\n"
"its data if the only way to access each datum is via the collection and the\n"
"collection is responsible for deleting the data (even in cases of shared\n"
"ownership, some kind of borrowed view may be appropriate). If a collection "
"owns\n"
"its data, it is usually useful to provide a view of the data as borrowed so "
"that\n"
"it can be referenced multiple times."
msgstr ""
"Ponteiros inteligentes e coleções são análogos: um ponteiro inteligente "
"aponta para um único\n"
"objeto, enquanto uma coleção aponta para muitos objetos. Do ponto de vista "
"de\n"
"o sistema de tipo, há pouca diferença entre os dois. Uma coleção possui\n"
"seus dados se a única forma de acesso a cada dado for através da coleta e "
"do\n"
"coleta é responsável por excluir os dados (mesmo em casos de "
"compartilhamento\n"
"propriedade, algum tipo de visão emprestada pode ser apropriada). Se uma "
"coleção possui\n"
"seus dados, geralmente é útil fornecer uma visão dos dados como emprestados "
"para que\n"
"pode ser referenciado várias vezes."

#: src\idioms/deref.md:67
#, fuzzy
msgid ""
"Most smart pointers (e.g., `Foo<T>`) implement `Deref<Target=T>`. However,\n"
"collections will usually dereference to a custom type. `[T]` and `str` have "
"some\n"
"language support, but in the general case, this is not necessary. `Foo<T>` "
"can\n"
"implement `Deref<Target=Bar<T>>` where `Bar` is a dynamically sized type "
"and\n"
"`&Bar<T>` is a borrowed view of the data in `Foo<T>`."
msgstr ""
"A maioria dos ponteiros inteligentes (por exemplo, `Foo<T>`) implementam "
"`Deref<Target=T>`. No entanto,\n"
"as coleções geralmente desreferenciarão a um tipo personalizado. `[T]` e "
"`str` têm alguns\n"
"suporte a idiomas, mas no caso geral, isso não é necessário. `Foo<T>` pode\n"
"implemente `Deref<Target=Bar<T>>` onde `Bar` é um tipo de tamanho dinâmico "
"e\n"
"`&Bar<T>` é uma visão emprestada dos dados em `Foo<T>`."

#: src\idioms/deref.md:73
#, fuzzy
msgid ""
"Commonly, ordered collections will implement `Index` for `Range`s to "
"provide\n"
"slicing syntax. The target will be the borrowed view."
msgstr ""
"Normalmente, coleções ordenadas irão implementar `Index` para `Range`s para "
"fornecer\n"
"sintaxe de corte. O alvo será a visão emprestada."

#: src\idioms/deref.md:78
#, fuzzy
msgid ""
"- [Deref polymorphism anti-pattern](../anti_patterns/deref.md).\n"
"- [Documentation for `Deref` "
"trait](https://doc.rust-lang.org/std/ops/trait.Deref.html)."
msgstr ""
"- [Deref polimorfismo anti-padrão](../anti_patterns/deref.md).\n"
"- [Documentação para o trait "
"`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)."

#: src\idioms/dtor-finally.md:1
#, fuzzy
msgid "# Finalisation in destructors"
msgstr "# Finalização em destrutores"

#: src\idioms/dtor-finally.md:5
#, fuzzy
msgid ""
"Rust does not provide the equivalent to `finally` blocks - code that will "
"be\n"
"executed no matter how a function is exited. Instead, an object's destructor "
"can\n"
"be used to run code that must be run before exit."
msgstr ""
"Rust não fornece o equivalente aos blocos `finally` - código que será\n"
"executado, não importa como uma função é encerrada. Em vez disso, o "
"destruidor de um objeto pode\n"
"ser usado para executar o código que deve ser executado antes da saída."

#: src\idioms/dtor-finally.md:11
msgid ""
"```rust,ignore\n"
"fn bar() -> Result<(), ()> {\n"
"    // These don't need to be defined inside the function.\n"
"    struct Foo;\n"
"\n"
"    // Implement a destructor for Foo.\n"
"    impl Drop for Foo {\n"
"        fn drop(&mut self) {\n"
"            println!(\"exit\");\n"
"        }\n"
"    }\n"
"\n"
"    // The dtor of _exit will run however the function `bar` is exited.\n"
"    let _exit = Foo;\n"
"    // Implicit return with `?` operator.\n"
"    baz()?;\n"
"    // Normal return.\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src\idioms/dtor-finally.md:34
#, fuzzy
msgid ""
"If a function has multiple return points, then executing code on exit "
"becomes\n"
"difficult and repetitive (and thus bug-prone). This is especially the case "
"where\n"
"return is implicit due to a macro. A common case is the `?` operator which\n"
"returns if the result is an `Err`, but continues if it is `Ok`. `?` is used "
"as\n"
"an exception handling mechanism, but unlike Java (which has `finally`), "
"there is\n"
"no way to schedule code to run in both the normal and exceptional cases.\n"
"Panicking will also exit a function early."
msgstr ""
"Se uma função tiver vários pontos de retorno, a execução do código na saída "
"torna-se\n"
"difícil e repetitivo (e, portanto, propenso a erros). Este é especialmente o "
"caso onde\n"
"o retorno é implícito devido a uma macro. Um caso comum é o operador `?` "
"que\n"
"retorna se o resultado for um `Err`, mas continua se for `Ok`. `?` é usado "
"como\n"
"um mecanismo de manipulação de exceção, mas ao contrário de Java (que tem "
"`finally`), há\n"
"não há como agendar o código para execução em casos normais e excepcionais.\n"
"Entrar em pânico também sairá de uma função mais cedo."

#: src\idioms/dtor-finally.md:44
#, fuzzy
msgid ""
"Code in destructors will (nearly) always be run - copes with panics, early\n"
"returns, etc."
msgstr ""
"O código em destruidores será (quase) sempre executado - lida com pânicos,\n"
"devoluções, etc"

#: src\idioms/dtor-finally.md:49
#, fuzzy
msgid ""
"It is not guaranteed that destructors will run. For example, if there is an\n"
"infinite loop in a function or if running a function crashes before exit.\n"
"Destructors are also not run in the case of a panic in an already panicking\n"
"thread. Therefore, destructors cannot be relied on as finalizers where it "
"is\n"
"absolutely essential that finalisation happens."
msgstr ""
"Não é garantido que os destruidores serão executados. Por exemplo, se houver "
"um\n"
"loop infinito em uma função ou se a execução de uma função falhar antes de "
"sair.\n"
"Os destruidores também não são executados no caso de um pânico em um já em "
"pânico\n"
"fio. Portanto, os destruidores não podem ser usados como finalizadores onde "
"é\n"
"absolutamente essencial que a finalização aconteça."

#: src\idioms/dtor-finally.md:55
#, fuzzy
msgid ""
"This pattern introduces some hard to notice, implicit code. Reading a "
"function\n"
"gives no clear indication of destructors to be run on exit. This can make\n"
"debugging tricky."
msgstr ""
"Esse padrão introduz algum código implícito difícil de perceber. Lendo uma "
"função\n"
"não dá nenhuma indicação clara de destruidores a serem executados na saída. "
"isso pode fazer\n"
"depuração complicada."

#: src\idioms/dtor-finally.md:59
#, fuzzy
msgid ""
"Requiring an object and `Drop` impl just for finalisation is heavy on "
"boilerplate."
msgstr ""
"Exigir um objeto e impl `Drop` apenas para finalização é pesado em clichê."

#: src\idioms/dtor-finally.md:63
#, fuzzy
msgid ""
"There is some subtlety about how exactly to store the object used as a\n"
"finalizer. It must be kept alive until the end of the function and must then "
"be\n"
"destroyed. The object must always be a value or uniquely owned pointer "
"(e.g.,\n"
"`Box<Foo>`). If a shared pointer (such as `Rc`) is used, then the finalizer "
"can\n"
"be kept alive beyond the lifetime of the function. For similar reasons, the\n"
"finalizer should not be moved or returned."
msgstr ""
"Existe alguma sutileza sobre como exatamente armazenar o objeto usado como "
"um\n"
"finalizador. Deve ser mantido vivo até o final da função e deve então ser\n"
"destruído. O objeto deve ser sempre um valor ou um ponteiro de propriedade "
"exclusiva (por exemplo,\n"
"`Box<Foo>`). Se um ponteiro compartilhado (como `Rc`) for usado, o "
"finalizador pode\n"
"ser mantido vivo além do tempo de vida da função. Por razões semelhantes, o\n"
"finalizer não deve ser movido ou retornado."

#: src\idioms/dtor-finally.md:70
#, fuzzy
msgid ""
"The finalizer must be assigned into a variable, otherwise it will be "
"destroyed\n"
"immediately, rather than when it goes out of scope. The variable name must "
"start\n"
"with `_` if the variable is only used as a finalizer, otherwise the "
"compiler\n"
"will warn that the finalizer is never used. However, do not call the "
"variable\n"
"`_` with no suffix - in that case it will be destroyed immediately."
msgstr ""
"O finalizador deve ser atribuído a uma variável, caso contrário, será "
"destruído\n"
"imediatamente, em vez de quando sai do escopo. O nome da variável deve "
"começar\n"
"com `_` se a variável for usada apenas como finalizador, caso contrário, o "
"compilador\n"
"avisará que o finalizador nunca é usado. No entanto, não chame a variável\n"
"`_` sem sufixo - nesse caso será destruído imediatamente."

#: src\idioms/dtor-finally.md:76
#, fuzzy
msgid ""
"In Rust, destructors are run when an object goes out of scope. This happens\n"
"whether we reach the end of block, there is an early return, or the program\n"
"panics. When panicking, Rust unwinds the stack running destructors for each\n"
"object in each stack frame. So, destructors get called even if the panic "
"happens\n"
"in a function being called."
msgstr ""
"No Rust, os destruidores são executados quando um objeto sai do escopo. Isto "
"acontece\n"
"se chegamos ao final do bloco, há um retorno antecipado ou o programa\n"
"pânico. Ao entrar em pânico, Rust desenrola a pilha executando destruidores "
"para cada\n"
"objeto em cada quadro de pilha. Assim, os destruidores são chamados mesmo "
"que o pânico aconteça\n"
"em uma função que está sendo chamada."

#: src\idioms/dtor-finally.md:82
#, fuzzy
msgid ""
"If a destructor panics while unwinding, there is no good action to take, so "
"Rust\n"
"aborts the thread immediately, without running further destructors. This "
"means\n"
"that destructors are not absolutely guaranteed to run. It also means that "
"you\n"
"must take extra care in your destructors not to panic, since it could leave\n"
"resources in an unexpected state."
msgstr ""
"Se um destruidor entrar em pânico enquanto desenrola, não há nenhuma boa "
"ação a ser tomada, então Rust\n"
"aborta o thread imediatamente, sem executar mais destruidores. Isso "
"significa\n"
"que os destruidores não são absolutamente garantidos para serem executados. "
"Também significa que você\n"
"deve tomar cuidado extra em seus destruidores para não entrar em pânico, "
"pois pode deixar\n"
"recursos em um estado inesperado."

#: src\idioms/dtor-finally.md:90
#, fuzzy
msgid "[RAII guards](../patterns/behavioural/RAII.md)."
msgstr "[guardas RAII](../patterns/behavioural/RAII.md)."

#: src\idioms/mem-replace.md:1
#, fuzzy
msgid "# `mem::{take(_), replace(_)}` to keep owned values in changed enums"
msgstr ""
"# `mem::{take(_), replace(_)}` para manter os valores de propriedade em "
"enums alterados"

#: src\idioms/mem-replace.md:5
#, fuzzy
msgid ""
"Say we have a `&mut MyEnum` which has (at least) two variants,\n"
"`A { name: String, x: u8 }` and `B { name: String }`. Now we want to change\n"
"`MyEnum::A` to a `B` if `x` is zero, while keeping `MyEnum::B` intact."
msgstr ""
"Digamos que temos um `&mut MyEnum` que tem (pelo menos) duas variantes,\n"
"`A { nome: String, x: u8 }` e `B { nome: String }`. Agora queremos mudar\n"
"`MyEnum::A` para um `B` se `x` for zero, enquanto mantém `MyEnum::B` intacto."

#: src\idioms/mem-replace.md:9
#, fuzzy
msgid "We can do this without cloning the `name`."
msgstr "Podemos fazer isso sem clonar o `name`."

#: src\idioms/mem-replace.md:13
msgid ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MyEnum {\n"
"    A { name: String, x: u8 },\n"
"    B { name: String }\n"
"}\n"
"\n"
"fn a_to_b(e: &mut MyEnum) {\n"
"    if let MyEnum::A { name, x: 0 } = e {\n"
"        // this takes out our `name` and put in an empty String instead\n"
"        // (note that empty strings don't allocate).\n"
"        // Then, construct the new enum variant (which will\n"
"        // be assigned to `*e`).\n"
"        *e = MyEnum::B { name: mem::take(name) }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/mem-replace.md:32
#, fuzzy
msgid "This also works with more variants:"
msgstr "Isso também funciona com mais variantes:"

#: src\idioms/mem-replace.md:34
msgid ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MultiVariateEnum {\n"
"    A { name: String },\n"
"    B { name: String },\n"
"    C,\n"
"    D\n"
"}\n"
"\n"
"fn swizzle(e: &mut MultiVariateEnum) {\n"
"    use MultiVariateEnum::*;\n"
"    *e = match e {\n"
"        // Ownership rules do not allow taking `name` by value, but we "
"cannot\n"
"        // take the value out of a mutable reference, unless we replace it:\n"
"        A { name } => B { name: mem::take(name) },\n"
"        B { name } => A { name: mem::take(name) },\n"
"        C => D,\n"
"        D => C\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/mem-replace.md:59
#, fuzzy
msgid ""
"When working with enums, we may want to change an enum value in place, "
"perhaps\n"
"to another variant. This is usually done in two phases to keep the borrow\n"
"checker happy. In the first phase, we observe the existing value and look "
"at\n"
"its parts to decide what to do next. In the second phase we may "
"conditionally\n"
"change the value (as in the example above)."
msgstr ""
"Ao trabalhar com enums, podemos querer alterar um valor de enum no lugar, "
"talvez\n"
"para outra variante. Isso geralmente é feito em duas fases para manter o "
"empréstimo\n"
"verificador feliz. Na primeira fase, observamos o valor existente e "
"procuramos\n"
"suas partes para decidir o que fazer a seguir. Na segunda fase, podemos "
"condicionalmente\n"
"altere o valor (como no exemplo acima)."

#: src\idioms/mem-replace.md:65
#, fuzzy
msgid ""
"The borrow checker won't allow us to take out `name` of the enum (because\n"
"_something_ must be there.) We could of course `.clone()` name and put the "
"clone\n"
"into our `MyEnum::B`, but that would be an instance of the [Clone to satisfy "
"the borrow checker](../anti_patterns/borrow_clone.md) anti-pattern. Anyway, "
"we\n"
"can avoid the extra allocation by changing `e` with only a mutable borrow."
msgstr ""
"O verificador de empréstimo não nos permitirá remover `name` do enum "
"(porque\n"
"_algo_ deve estar lá.) É claro que poderíamos nomear `.clone()` e colocar o "
"clone\n"
"em nosso `MyEnum::B`, mas isso seria uma instância do anti-padrão [Clone "
"para satisfazer o verificador de "
"empréstimo](../anti_patterns/borrow_clone.md). De qualquer forma, nós\n"
"pode evitar a alocação extra alterando `e` apenas com um empréstimo mutável."

#: src\idioms/mem-replace.md:70
#, fuzzy
msgid ""
"`mem::take` lets us swap out the value, replacing it with it's default "
"value,\n"
"and returning the previous value. For `String`, the default value is an "
"empty\n"
"`String`, which does not need to allocate. As a result, we get the original\n"
"`name` _as an owned value_. We can then wrap this in another enum."
msgstr ""
"`mem::take` nos permite trocar o valor, substituindo-o por seu valor "
"padrão,\n"
"e retornando o valor anterior. Para `String`, o valor padrão é um vazio\n"
"`String`, que não precisa alocar. Como resultado, obtemos o original\n"
"`name` _como um valor de propriedade_. Podemos então envolver isso em outro "
"enum."

#: src\idioms/mem-replace.md:75
#, fuzzy
msgid ""
"**NOTE:** `mem::replace` is very similar, but allows us to specify what to\n"
"replace the value with. An equivalent to our `mem::take` line would be\n"
"`mem::replace(name, String::new())`."
msgstr ""
"**NOTA:** `mem::replace` é muito semelhante, mas nos permite especificar o "
"que\n"
"substitua o valor por. Um equivalente à nossa linha `mem::take` seria\n"
"`mem::replace(nome, String::new())`."

#: src\idioms/mem-replace.md:79
#, fuzzy
msgid ""
"Note, however, that if we are using an `Option` and want to replace its\n"
"value with a `None`, `Option`’s `take()` method provides a shorter and\n"
"more idiomatic alternative."
msgstr ""
"Observe, no entanto, que se estivermos usando uma `Option` e quisermos "
"substituir sua\n"
"valor com um `None`, o método `take()` de `Option` fornece um valor mais "
"curto e\n"
"alternativa mais idiomática."

#: src\idioms/mem-replace.md:85
#, fuzzy
msgid ""
"Look ma, no allocation! Also you may feel like Indiana Jones while doing it."
msgstr ""
"Olha ma, sem alocação! Além disso, você pode se sentir como Indiana Jones ao "
"fazê-lo."

#: src\idioms/mem-replace.md:89
#, fuzzy
msgid ""
"This gets a bit wordy. Getting it wrong repeatedly will make you hate the\n"
"borrow checker. The compiler may fail to optimize away the double store,\n"
"resulting in reduced performance as opposed to what you'd do in unsafe\n"
"languages."
msgstr ""
"Isso fica um pouco prolixo. Errar repetidamente fará com que você odeie o\n"
"verificador de empréstimo. O compilador pode falhar ao otimizar o "
"armazenamento duplo,\n"
"resultando em desempenho reduzido em oposição ao que você faria em ambientes "
"inseguros\n"
"línguas."

#: src\idioms/mem-replace.md:94
#, fuzzy
msgid ""
"Furthermore, the type you are taking needs to implement the [`Default` "
"trait](./default.md). However, if the type you're working with doesn't\n"
"implement this, you can instead use `mem::replace`."
msgstr ""
"Além disso, o tipo que você está tomando precisa implementar o [traço "
"`Default`](./default.md). No entanto, se o tipo com o qual você está "
"trabalhando não\n"
"implementar isso, você pode usar `mem::replace`."

#: src\idioms/mem-replace.md:99
#, fuzzy
msgid ""
"This pattern is only of interest in Rust. In GC'd languages, you'd take the\n"
"reference to the value by default (and the GC would keep track of refs), and "
"in\n"
"other low-level languages like C you'd simply alias the pointer and fix "
"things\n"
"later."
msgstr ""
"Esse padrão é interessante apenas no Rust. Em idiomas GC'd, você pegaria o\n"
"referência ao valor por padrão (e o GC manteria o controle de refs), e em\n"
"outras linguagens de baixo nível, como C, você simplesmente criaria um alias "
"para o ponteiro e consertaria as coisas\n"
"mais tarde."

#: src\idioms/mem-replace.md:104
#, fuzzy
msgid ""
"However, in Rust, we have to do a little more work to do this. An owned "
"value\n"
"may only have one owner, so to take it out, we need to put something back in "
"–\n"
"like Indiana Jones, replacing the artifact with a bag of sand."
msgstr ""
"No entanto, no Rust, temos que trabalhar um pouco mais para fazer isso. Um "
"valor de propriedade\n"
"pode ter apenas um dono, então, para retirá-lo, precisamos colocar algo de "
"volta –\n"
"como Indiana Jones, substituindo o artefato por um saco de areia."

#: src\idioms/mem-replace.md:110
#, fuzzy
msgid ""
"This gets rid of the [Clone to satisfy the borrow "
"checker](../anti_patterns/borrow_clone.md)\n"
"anti-pattern in a specific case."
msgstr ""
"Isso elimina o [Clone para satisfazer o verificador de "
"empréstimo](../anti_patterns/borrow_clone.md)\n"
"antipadrão em um caso específico."

#: src\idioms/on-stack-dyn-dispatch.md:1
#, fuzzy
msgid "# On-Stack Dynamic Dispatch"
msgstr "# Despacho Dinâmico On-Stack"

#: src\idioms/on-stack-dyn-dispatch.md:5
#, fuzzy
msgid ""
"We can dynamically dispatch over multiple values, however, to do so, we "
"need\n"
"to declare multiple variables to bind differently-typed objects. To extend "
"the\n"
"lifetime as necessary, we can use deferred conditional initialization, as "
"seen\n"
"below:"
msgstr ""
"Podemos despachar dinamicamente vários valores, no entanto, para fazer isso, "
"precisamos\n"
"para declarar várias variáveis para vincular objetos de tipos diferentes. "
"Para estender o\n"
"tempo de vida conforme necessário, podemos usar a inicialização condicional "
"adiada, como visto\n"
"abaixo:"

#: src\idioms/on-stack-dyn-dispatch.md:12
msgid ""
"```rust\n"
"use std::io;\n"
"use std::fs;\n"
"\n"
"# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
"# let arg = \"-\";\n"
"\n"
"// These must live longer than `readable`, and thus are declared first:\n"
"let (mut stdin_read, mut file_read);\n"
"\n"
"// We need to ascribe the type to get dynamic dispatch.\n"
"let readable: &mut dyn io::Read = if arg == \"-\" {\n"
"    stdin_read = io::stdin();\n"
"    &mut stdin_read\n"
"} else {\n"
"    file_read = fs::File::open(arg)?;\n"
"    &mut file_read\n"
"};\n"
"\n"
"// Read from `readable` here.\n"
"\n"
"# Ok(())\n"
"# }\n"
"```"
msgstr ""

#: src\idioms/on-stack-dyn-dispatch.md:39
#, fuzzy
msgid ""
"Rust monomorphises code by default. This means a copy of the code will be\n"
"generated for each type it is used with and optimized independently. While "
"this\n"
"allows for very fast code on the hot path, it also bloats the code in "
"places\n"
"where performance is not of the essence, thus costing compile time and "
"cache\n"
"usage."
msgstr ""
"Rust monomorfiza o código por padrão. Isso significa que uma cópia do código "
"será\n"
"gerado para cada tipo com o qual é usado e otimizado independentemente. "
"Enquanto isso\n"
"permite um código muito rápido no hot path, também incha o código em locais\n"
"onde o desempenho não é essencial, custando assim tempo de compilação e "
"cache\n"
"uso."

#: src\idioms/on-stack-dyn-dispatch.md:45
#, fuzzy
msgid ""
"Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly "
"ask\n"
"for it."
msgstr ""
"Felizmente, o Rust nos permite usar o dispatch dinâmico, mas temos que "
"perguntar explicitamente\n"
"para isso."

#: src\idioms/on-stack-dyn-dispatch.md:50
#, fuzzy
msgid ""
"We do not need to allocate anything on the heap. Neither do we need to\n"
"initialize something we won't use later, nor do we need to monomorphize the\n"
"whole code that follows to work with both `File` or `Stdin`."
msgstr ""
"Não precisamos alocar nada no heap. Nem nós precisamos\n"
"inicializar algo que não usaremos mais tarde, nem precisamos monomorfizar o\n"
"todo o código que segue para funcionar com `File` ou `Stdin`."

#: src\idioms/on-stack-dyn-dispatch.md:56
#, fuzzy
msgid "The code needs more moving parts than the `Box`-based version:"
msgstr "O código precisa de mais partes móveis do que a versão baseada em `Box`:"

#: src\idioms/on-stack-dyn-dispatch.md:58
msgid ""
"```rust,ignore\n"
"// We still need to ascribe the type for dynamic dispatch.\n"
"let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
"    Box::new(io::stdin())\n"
"} else {\n"
"    Box::new(fs::File::open(arg)?)\n"
"};\n"
"// Read from `readable` here.\n"
"```"
msgstr ""

#: src\idioms/on-stack-dyn-dispatch.md:70
#, fuzzy
msgid ""
"Rust newcomers will usually learn that Rust requires all variables to be\n"
"initialized _before use_, so it's easy to overlook the fact that _unused_\n"
"variables may well be uninitialized. Rust works quite hard to ensure that "
"this\n"
"works out fine and only the initialized values are dropped at the end of "
"their\n"
"scope."
msgstr ""
"Os recém-chegados ao Rust geralmente aprenderão que o Rust exige que todas "
"as variáveis sejam\n"
"inicializado _antes de usar_, então é fácil ignorar o fato de que _não "
"usado_\n"
"as variáveis podem muito bem ser não inicializadas. Rust trabalha bastante "
"para garantir que este\n"
"funciona bem e apenas os valores inicializados são descartados no final de "
"sua\n"
"escopo."

#: src\idioms/on-stack-dyn-dispatch.md:76
#, fuzzy
msgid "The example meets all the constraints Rust places on us:"
msgstr "O exemplo atende a todas as restrições que Rust nos impõe:"

#: src\idioms/on-stack-dyn-dispatch.md:78
#, fuzzy
msgid ""
"- All variables are initialized before using (in this case borrowing) them\n"
"- Each variable only holds values of a single type. In our example, `stdin` "
"is\n"
"  of type `Stdin`, `file` is of type `File` and `readable` is of type `&mut "
"dyn Read`\n"
"- Each borrowed value outlives all the references borrowed from it"
msgstr ""
"- Todas as variáveis são inicializadas antes de serem usadas (neste caso, "
"emprestadas)\n"
"- Cada variável contém apenas valores de um único tipo. Em nosso exemplo, "
"`stdin` é\n"
"  do tipo `Stdin`, `file` é do tipo `File` e `readable` é do tipo `&mut dyn "
"Read`\n"
"- Cada valor emprestado sobrevive a todas as referências emprestadas dele"

#: src\idioms/on-stack-dyn-dispatch.md:85
#, fuzzy
msgid ""
"- [Finalisation in destructors](dtor-finally.md) and\n"
"  [RAII guards](../patterns/behavioural/RAII.md) can benefit from tight "
"control over\n"
"  lifetimes.\n"
"- For conditionally filled `Option<&T>`s of (mutable) references, one can\n"
"  initialize an `Option<T>` directly and use its [`.as_ref()`] method to get "
"an\n"
"  optional reference."
msgstr ""
"- [Finalização em destruidores](dtor-finally.md) e\n"
"  [guardas RAII](../patterns/behavioural/RAII.md) podem se beneficiar de um "
"controle rígido sobre\n"
"  vidas.\n"
"- Para `Option<&T>`s de referências (mutáveis) preenchidas condicionalmente, "
"pode-se\n"
"  inicialize um `Option<T>` diretamente e use seu método [`.as_ref()`] para "
"obter um\n"
"  referência opcional."

#: src\idioms/ffi/intro.md:1
#, fuzzy
msgid "# FFI Idioms"
msgstr "# Idiomas FFI"

#: src\idioms/ffi/intro.md:3
#, fuzzy
msgid ""
"Writing FFI code is an entire course in itself.\n"
"However, there are several idioms here that can act as pointers, and avoid\n"
"traps for inexperienced users of `unsafe` Rust."
msgstr ""
"Escrever código FFI é um curso completo em si.\n"
"No entanto, existem vários idiomas aqui que podem atuar como ponteiros e "
"evitar\n"
"armadilhas para usuários inexperientes de Rust `inseguro`."

#: src\idioms/ffi/intro.md:7
#, fuzzy
msgid "This section contains idioms that may be useful when doing FFI."
msgstr ""
"Esta seção contém expressões idiomáticas que podem ser úteis ao fazer FFI."

#: src\idioms/ffi/intro.md:9
#, fuzzy
msgid ""
"1. [Idiomatic Errors](./errors.md) - Error handling with integer codes and\n"
"   sentinel return values (such as `NULL` pointers)\n"
"\n"
"2. [Accepting Strings](./accepting-strings.md) with minimal unsafe code\n"
"\n"
"3. [Passing Strings](./passing-strings.md) to FFI functions"
msgstr ""
"1. [Erros idiomáticos](./errors.md) - Tratamento de erros com códigos "
"inteiros e\n"
"   valores de retorno do sentinela (como ponteiros `NULL`)\n"
"\n"
"2. [Accepting Strings](./accepting-strings.md) com o mínimo de código "
"inseguro\n"
"\n"
"3. [Passing Strings](./passing-strings.md) para funções FFI"

#: src\idioms/ffi/errors.md:1
#, fuzzy
msgid "# Error Handling in FFI"
msgstr "# Tratamento de erros no FFI"

#: src\idioms/ffi/errors.md:5
#, fuzzy
msgid ""
"In foreign languages like C, errors are represented by return codes.\n"
"However, Rust's type system allows much more rich error information to be\n"
"captured and propogated through a full type."
msgstr ""
"Em idiomas estrangeiros como C, os erros são representados por códigos de "
"retorno.\n"
"No entanto, o sistema de tipos do Rust permite que informações de erro muito "
"mais ricas sejam\n"
"capturado e propagado através de um tipo completo."

#: src\idioms/ffi/errors.md:9
#, fuzzy
msgid ""
"This best practice shows different kinds of error codes, and how to expose "
"them\n"
"in a usable way:"
msgstr ""
"Esta prática recomendada mostra diferentes tipos de códigos de erro e como "
"expô-los\n"
"de forma utilizável:"

#: src\idioms/ffi/errors.md:12
#, fuzzy
msgid ""
"1. Flat Enums should be converted to integers and returned as codes.\n"
"2. Structured Enums should be converted to an integer code with a string "
"error\n"
"   message for detail.\n"
"3. Custom Error Types should become \"transparent\", with a C representation."
msgstr ""
"1. Flat Enums devem ser convertidos em inteiros e retornados como códigos.\n"
"2. Enums estruturados devem ser convertidos em um código inteiro com um erro "
"de string\n"
"   mensagem para detalhes.\n"
"3. Tipos de erro personalizados devem se tornar \"transparentes\", com uma "
"representação em C."

#: src\idioms/ffi/errors.md:17 src\idioms/ffi/accepting-strings.md:29
#: src\idioms/ffi/passing-strings.md:26 src\patterns/ffi/export.md:40
#: src\patterns/ffi/wrappers.md:23
#, fuzzy
msgid "## Code Example"
msgstr "## Exemplo de Código"

#: src\idioms/ffi/errors.md:19
#, fuzzy
msgid "### Flat Enums"
msgstr "### Enums Simples"

#: src\idioms/ffi/errors.md:21
msgid ""
"```rust,ignore\n"
"enum DatabaseError {\n"
"    IsReadOnly = 1, // user attempted a write operation\n"
"    IOError = 2, // user should read the C errno() for what it was\n"
"    FileCorrupted = 3, // user should run a repair tool to recover it\n"
"}\n"
"\n"
"impl From<DatabaseError> for libc::c_int {\n"
"    fn from(e: DatabaseError) -> libc::c_int {\n"
"        (e as i8).into()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/errors.md:35
#, fuzzy
msgid "### Structured Enums"
msgstr "### Enums estruturados"

#: src\idioms/ffi/errors.md:37
msgid ""
"```rust,ignore\n"
"pub mod errors {\n"
"    enum DatabaseError {\n"
"        IsReadOnly,\n"
"        IOError(std::io::Error),\n"
"        FileCorrupted(String), // message describing the issue\n"
"    }\n"
"\n"
"    impl From<DatabaseError> for libc::c_int {\n"
"        fn from(e: DatabaseError) -> libc::c_int {\n"
"            match e {\n"
"                DatabaseError::IsReadOnly => 1,\n"
"                DatabaseError::IOError(_) => 2,\n"
"                DatabaseError::FileCorrupted(_) => 3,\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub mod c_api {\n"
"    use super::errors::DatabaseError;\n"
"\n"
"    #[no_mangle]\n"
"    pub extern \"C\" fn db_error_description(\n"
"        e: *const DatabaseError\n"
"        ) -> *mut libc::c_char {\n"
"\n"
"        let error: &DatabaseError = unsafe {\n"
"            // SAFETY: pointer lifetime is greater than the current stack "
"frame\n"
"            &*e\n"
"        };\n"
"\n"
"        let error_str: String = match error {\n"
"            DatabaseError::IsReadOnly => {\n"
"                format!(\"cannot write to read-only database\");\n"
"            }\n"
"            DatabaseError::IOError(e) => {\n"
"                format!(\"I/O Error: {}\", e);\n"
"            }\n"
"            DatabaseError::FileCorrupted(s) => {\n"
"                format!(\"File corrupted, run repair: {}\", &s);\n"
"            }\n"
"        };\n"
"\n"
"        let c_error = unsafe {\n"
"            // SAFETY: copying error_str to an allocated buffer with a NUL\n"
"            // character at the end\n"
"            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as "
"*mut _;\n"
"\n"
"            if malloc.is_null() {\n"
"                return std::ptr::null_mut();\n"
"            }\n"
"\n"
"            let src = error_str.as_bytes().as_ptr();\n"
"\n"
"            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
"\n"
"            std::ptr::write(malloc.add(error_str.len()), 0);\n"
"\n"
"            malloc as *mut libc::c_char\n"
"        };\n"
"\n"
"        c_error\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/errors.md:104
#, fuzzy
msgid "### Custom Error Types"
msgstr "### Tipos de erro personalizados"

#: src\idioms/ffi/errors.md:106
msgid ""
"```rust,ignore\n"
"struct ParseError {\n"
"    expected: char,\n"
"    line: u32,\n"
"    ch: u16\n"
"}\n"
"\n"
"impl ParseError { /* ... */ }\n"
"\n"
"/* Create a second version which is exposed as a C structure */\n"
"#[repr(C)]\n"
"pub struct parse_error {\n"
"    pub expected: libc::c_char,\n"
"    pub line: u32,\n"
"    pub ch: u16\n"
"}\n"
"\n"
"impl From<ParseError> for parse_error {\n"
"    fn from(e: ParseError) -> parse_error {\n"
"        let ParseError { expected, line, ch } = e;\n"
"        parse_error { expected, line, ch }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/errors.md:133
#, fuzzy
msgid ""
"This ensures that the foreign language has clear access to error "
"information\n"
"while not compromising the Rust code's API at all."
msgstr ""
"Isso garante que o idioma estrangeiro tenha acesso claro às informações de "
"erro\n"
"sem comprometer a API do código Rust."

#: src\idioms/ffi/errors.md:138
#, fuzzy
msgid ""
"It's a lot of typing, and some types may not be able to be converted easily\n"
"to C."
msgstr ""
"É muita digitação e alguns tipos podem não ser convertidos facilmente\n"
"para C."

#: src\idioms/ffi/accepting-strings.md:1
#, fuzzy
msgid "# Accepting Strings"
msgstr "# Aceitando Strings"

#: src\idioms/ffi/accepting-strings.md:5
#, fuzzy
msgid ""
"When accepting strings via FFI through pointers, there are two principles "
"that\n"
"should be followed:"
msgstr ""
"Ao aceitar strings via FFI por meio de ponteiros, existem dois princípios "
"que\n"
"deve ser seguido:"

#: src\idioms/ffi/accepting-strings.md:8
#, fuzzy
msgid ""
"1. Keep foreign strings \"borrowed\", rather than copying them directly.\n"
"2. Minimize the amount of complexity and `unsafe` code involved in "
"converting\n"
"   from a C-style string to native Rust strings."
msgstr ""
"1. Mantenha strings estrangeiras \"emprestadas\", em vez de copiá-las "
"diretamente.\n"
"2. Minimize a complexidade e o código \"inseguro\" envolvido na conversão\n"
"   de uma string estilo C para strings Rust nativas."

#: src\idioms/ffi/accepting-strings.md:14
#, fuzzy
msgid ""
"The strings used in C have different behaviours to those used in Rust, "
"namely:"
msgstr ""
"As strings usadas em C possuem comportamentos diferentes das usadas em Rust, "
"a saber:"

#: src\idioms/ffi/accepting-strings.md:16
#, fuzzy
msgid ""
"- C strings are null-terminated while Rust strings store their length\n"
"- C strings can contain any arbitrary non-zero byte while Rust strings must "
"be\n"
"  UTF-8\n"
"- C strings are accessed and manipulated using `unsafe` pointer operations\n"
"  while interactions with Rust strings go through safe methods"
msgstr ""
"- As strings C são terminadas em nulo, enquanto as strings Rust armazenam "
"seu comprimento\n"
"- As strings C podem conter qualquer byte arbitrário diferente de zero, "
"enquanto as strings Rust devem ser\n"
"  UTF-8\n"
"- Strings C são acessadas e manipuladas usando operações de ponteiro "
"`inseguras`\n"
"  enquanto as interações com strings Rust passam por métodos seguros"

#: src\idioms/ffi/accepting-strings.md:22
#, fuzzy
msgid ""
"The Rust standard library comes with C equivalents of Rust's `String` and "
"`&str`\n"
"called `CString` and `&CStr`, that allow us to avoid a lot of the "
"complexity\n"
"and `unsafe` code involved in converting between C strings and Rust strings."
msgstr ""
"A biblioteca padrão do Rust vem com equivalentes em C de `String` e `&str` "
"do Rust\n"
"chamados `CString` e `&CStr`, que nos permitem evitar muita complexidade\n"
"e código `inseguro` envolvido na conversão entre strings C e strings Rust."

#: src\idioms/ffi/accepting-strings.md:26
#, fuzzy
msgid ""
"The `&CStr` type also allows us to work with borrowed data, meaning passing\n"
"strings between Rust and C is a zero-cost operation."
msgstr ""
"O tipo `&CStr` também nos permite trabalhar com dados emprestados, ou seja, "
"passar\n"
"strings entre Rust e C é uma operação de custo zero."

#: src\idioms/ffi/accepting-strings.md:31
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    /// Log a message at the specified level.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// It is the caller's guarantee to ensure `msg`:\n"
"    ///\n"
"    /// - is not a null pointer\n"
"    /// - points to valid, initialized data\n"
"    /// - points to memory ending in a null byte\n"
"    /// - won't be mutated for the duration of this function call\n"
"    #[no_mangle]\n"
"    pub unsafe extern \"C\" fn mylib_log(\n"
"        msg: *const libc::c_char,\n"
"        level: libc::c_int\n"
"    ) {\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        // SAFETY: The caller has already guaranteed this is okay (see the\n"
"        // `# Safety` section of the doc-comment).\n"
"        let msg_str: &str = match std::ffi::CStr::from_ptr(msg).to_str() {\n"
"            Ok(s) => s,\n"
"            Err(e) => {\n"
"                crate::log_error(\"FFI string conversion failed\");\n"
"                return;\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(msg_str, level);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/accepting-strings.md:70
#, fuzzy
msgid "The example is is written to ensure that:"
msgstr "O exemplo foi escrito para garantir que:"

#: src\idioms/ffi/accepting-strings.md:72
#, fuzzy
msgid ""
"1. The `unsafe` block is as small as possible.\n"
"2. The pointer with an \"untracked\" lifetime becomes a \"tracked\" shared\n"
"   reference"
msgstr ""
"1. O bloco `unsafe` é o menor possível.\n"
"2. O ponteiro com um tempo de vida \"não rastreado\" torna-se um "
"\"rastreado\" compartilhado\n"
"   referência"

#: src\idioms/ffi/accepting-strings.md:76
#, fuzzy
msgid "Consider an alternative, where the string is actually copied:"
msgstr "Considere uma alternativa, onde a string é realmente copiada:"

#: src\idioms/ffi/accepting-strings.md:78
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: "
"libc::c_int) {\n"
"        // DO NOT USE THIS CODE.\n"
"        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.\n"
"\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */\n"
"            libc::strlen(msg)\n"
"        };\n"
"\n"
"        let mut msg_data = Vec::with_capacity(msg_len + 1);\n"
"\n"
"        let msg_cstr: std::ffi::CString = unsafe {\n"
"            // SAFETY: copying from a foreign pointer expected to live\n"
"            // for the entire stack frame into owned memory\n"
"            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);\n"
"\n"
"            msg_data.set_len(msg_len + 1);\n"
"\n"
"            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
"        }\n"
"\n"
"        let msg_str: String = unsafe {\n"
"            match msg_cstr.into_string() {\n"
"                Ok(s) => s,\n"
"                Err(e) => {\n"
"                    crate::log_error(\"FFI string conversion failed\");\n"
"                    return;\n"
"                }\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(&msg_str, level);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/accepting-strings.md:120
#, fuzzy
msgid "This code in inferior to the original in two respects:"
msgstr "Este código é inferior ao original em dois aspectos:"

#: src\idioms/ffi/accepting-strings.md:122
#, fuzzy
msgid ""
"1. There is much more `unsafe` code, and more importantly, more invariants "
"it\n"
"   must uphold.\n"
"2. Due to the extensive arithmetic required, there is a bug in this version\n"
"   that cases Rust `undefined behaviour`."
msgstr ""
"1. Há muito mais código \"inseguro\" e, mais importante, mais invariantes\n"
"   deve sustentar.\n"
"2. Devido à extensa aritmética necessária, há um bug nesta versão\n"
"   que casos Rust `comportamento indefinido`."

#: src\idioms/ffi/accepting-strings.md:127
#, fuzzy
msgid ""
"The bug here is a simple mistake in pointer arithmetic: the string was "
"copied,\n"
"all `msg_len` bytes of it. However, the `NUL` terminator at the end was not."
msgstr ""
"O bug aqui é um erro simples na aritmética do ponteiro: a string foi "
"copiada,\n"
"todos os bytes `msg_len` dele. No entanto, o terminador `NUL` no final não "
"era."

#: src\idioms/ffi/accepting-strings.md:130
#, fuzzy
msgid ""
"The Vector then had its size _set_ to the length of the _zero padded string_ "
"--\n"
"rather than _resized_ to it, which could have added a zero at the end.\n"
"As a result, the last byte in the Vector is uninitialized memory.\n"
"When the `CString` is created at the bottom of the block, its read of the\n"
"Vector will cause `undefined behaviour`!"
msgstr ""
"O vetor então teve seu tamanho _definido_ para o comprimento da _string "
"preenchida com zero_ --\n"
"em vez de _redimensionado_ a ele, o que poderia ter adicionado um zero no "
"final.\n"
"Como resultado, o último byte no Vector é memória não inicializada.\n"
"Quando o `CString` é criado na parte inferior do bloco, sua leitura do\n"
"O vetor causará `comportamento indefinido`!"

#: src\idioms/ffi/accepting-strings.md:136
#, fuzzy
msgid ""
"Like many such issues, this would be difficult issue to track down.\n"
"Sometimes it would panic because the string was not `UTF-8`, sometimes it "
"would\n"
"put a weird character at the end of the string, sometimes it would just\n"
"completely crash."
msgstr ""
"Como muitos desses problemas, esse seria um problema difícil de rastrear.\n"
"Às vezes entrava em pânico porque a string não era `UTF-8`, às vezes\n"
"colocar um caractere estranho no final da string, às vezes seria apenas\n"
"travar completamente."

#: src\idioms/ffi/accepting-strings.md:143
#: src\idioms/ffi/passing-strings.md:105
#, fuzzy
msgid "None?"
msgstr "Nenhum?"

#: src\idioms/ffi/passing-strings.md:1
#, fuzzy
msgid "# Passing Strings"
msgstr "# Passando Cordas"

#: src\idioms/ffi/passing-strings.md:5
#, fuzzy
msgid ""
"When passing strings to FFI functions, there are four principles that should "
"be\n"
"followed:"
msgstr ""
"Ao passar strings para funções FFI, existem quatro princípios que devem ser\n"
"seguido:"

#: src\idioms/ffi/passing-strings.md:8
#, fuzzy
msgid ""
"1. Make the lifetime of owned strings as long as possible.\n"
"2. Minimize `unsafe` code during the conversion.\n"
"3. If the C code can modify the string data, use `Vec` instead of "
"`CString`.\n"
"4. Unless the Foreign Function API requires it, the ownership of the string\n"
"   should not transfer to the callee."
msgstr ""
"1. Faça com que a vida útil das strings próprias seja a maior possível.\n"
"2. Minimize o código `inseguro` durante a conversão.\n"
"3. Se o código C puder modificar os dados da string, use `Vec` em vez de "
"`CString`.\n"
"4. A menos que a API de função externa exija, a propriedade da string\n"
"   não deve transferir para o receptor."

#: src\idioms/ffi/passing-strings.md:16
#, fuzzy
msgid ""
"Rust has built-in support for C-style strings with its `CString` and `CStr`\n"
"types. However, there are different approaches one can take with strings "
"that\n"
"are being sent to a foreign function call from a Rust function."
msgstr ""
"Rust tem suporte embutido para strings no estilo C com seus `CString` e "
"`CStr`\n"
"tipos. No entanto, existem diferentes abordagens que podem ser adotadas com "
"strings que\n"
"estão sendo enviados para uma chamada de função estrangeira de uma função "
"Rust."

#: src\idioms/ffi/passing-strings.md:20
#, fuzzy
msgid ""
"The best practice is simple: use `CString` in such a way as to minimize\n"
"`unsafe` code. However, a secondary caveat is that\n"
"_the object must live long enough_, meaning the lifetime should be "
"maximized.\n"
"In addition, the documentation explains that \"round-tripping\" a `CString` "
"after\n"
"modification is UB, so additional work is necessary in that case."
msgstr ""
"A melhor prática é simples: use `CString` de forma a minimizar\n"
"código `inseguro`. No entanto, uma advertência secundária é que\n"
"_o objeto deve viver o suficiente_, o que significa que o tempo de vida deve "
"ser maximizado.\n"
"Além disso, a documentação explica que \"transmitir\" um `CString` após\n"
"modificação é UB, então trabalho adicional é necessário nesse caso."

#: src\idioms/ffi/passing-strings.md:28
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    extern \"C\" {\n"
"        fn seterr(message: *const libc::c_char);\n"
"        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -> "
"libc::c_int;\n"
"    }\n"
"\n"
"    fn report_error_to_ffi<S: Into<String>>(\n"
"        err: S\n"
"    ) -> Result<(), std::ffi::NulError>{\n"
"        let c_err = std::ffi::CString::new(err.into())?;\n"
"\n"
"        unsafe {\n"
"            // SAFETY: calling an FFI whose documentation says the pointer "
"is\n"
"            // const, so no modification should occur\n"
"            seterr(c_err.as_ptr());\n"
"        }\n"
"\n"
"        Ok(())\n"
"        // The lifetime of c_err continues until here\n"
"    }\n"
"\n"
"    fn get_error_from_ffi() -> Result<String, std::ffi::IntoStringError> {\n"
"        let mut buffer = vec![0u8; 1024];\n"
"        unsafe {\n"
"            // SAFETY: calling an FFI whose documentation implies\n"
"            // that the input need only live as long as the call\n"
"            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();\n"
"\n"
"            buffer.truncate(written + 1);\n"
"        }\n"
"\n"
"        std::ffi::CString::new(buffer).unwrap().into_string()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/passing-strings.md:70
#, fuzzy
msgid "The example is written in a way to ensure that:"
msgstr "O exemplo é escrito de forma a garantir que:"

#: src\idioms/ffi/passing-strings.md:72
#, fuzzy
msgid ""
"1. The `unsafe` block is as small as possible.\n"
"2. The `CString` lives long enough.\n"
"3. Errors with typecasts are always propagated when possible."
msgstr ""
"1. O bloco `unsafe` é o menor possível.\n"
"2. O `CString` vive o suficiente.\n"
"3. Erros com typecasts são sempre propagados quando possível."

#: src\idioms/ffi/passing-strings.md:76
#, fuzzy
msgid ""
"A common mistake (so common it's in the documentation) is to not use the\n"
"variable in the first block:"
msgstr ""
"Um erro comum (tão comum que está na documentação) é não usar o\n"
"variável no primeiro bloco:"

#: src\idioms/ffi/passing-strings.md:79
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    fn report_error<S: Into<String>>(err: S) -> Result<(), "
"std::ffi::NulError> {\n"
"        unsafe {\n"
"            // SAFETY: whoops, this contains a dangling pointer!\n"
"            seterr(std::ffi::CString::new(err.into())?.as_ptr());\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/ffi/passing-strings.md:94
#, fuzzy
msgid ""
"This code will result in a dangling pointer, because the lifetime of the\n"
"`CString` is not extended by the pointer creation, unlike if a reference "
"were\n"
"created."
msgstr ""
"Este código resultará em um ponteiro pendente, porque o tempo de vida do\n"
"`CString` não é estendido pela criação do ponteiro, ao contrário de uma "
"referência\n"
"criada."

#: src\idioms/ffi/passing-strings.md:98
#, fuzzy
msgid ""
"Another issue frequently raised is that the initialization of a 1k vector "
"of\n"
"zeroes is \"slow\". However, recent versions of Rust actually optimize that\n"
"particular macro to a call to `zmalloc`, meaning it is as fast as the "
"operating\n"
"system's ability to return zeroed memory (which is quite fast)."
msgstr ""
"Outra questão frequentemente levantada é que a inicialização de um vetor 1k "
"de\n"
"zeros é \"lento\". No entanto, versões recentes do Rust realmente otimizam "
"isso\n"
"macro específica para uma chamada para `zmalloc`, o que significa que é tão "
"rápido quanto a operação\n"
"a capacidade do sistema de retornar memória zerada (o que é bastante rápido)."

#: src\idioms/option-iter.md:1
#, fuzzy
msgid "# Iterating over an `Option`"
msgstr "# Iterando sobre uma `Option`"

#: src\idioms/option-iter.md:5
#, fuzzy
msgid ""
"`Option` can be viewed as a container that contains either zero or one\n"
"element. In particular, it implements the `IntoIterator` trait, and as such\n"
"can be used with generic code that needs such a type."
msgstr ""
"`Option` pode ser visto como um contêiner que contém zero ou um\n"
"elemento. Em particular, ele implementa o recurso `IntoIterator` e, como "
"tal,\n"
"pode ser usado com código genérico que precisa desse tipo."

#: src\idioms/option-iter.md:9 src\patterns/structural/small-crates.md:34
#: src\patterns/structural/unsafe-mods.md:22
#, fuzzy
msgid "## Examples"
msgstr "## Exemplos"

#: src\idioms/option-iter.md:11
#, fuzzy
msgid ""
"Since `Option` implements `IntoIterator`, it can be used as an argument to\n"
"[`.extend()`](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend):"
msgstr ""
"Como `Option` implementa `IntoIterator`, ele pode ser usado como um "
"argumento para\n"
"[`.extend()`](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend):"

#: src\idioms/option-iter.md:14
msgid ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"logicians.extend(turing);\n"
"\n"
"// equivalent to\n"
"if let Some(turing_inner) = turing {\n"
"    logicians.push(turing_inner);\n"
"}\n"
"```"
msgstr ""

#: src\idioms/option-iter.md:26
#, fuzzy
msgid ""
"If you need to tack an `Option` to the end of an existing iterator, you can\n"
"pass it to "
"[`.chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain):"
msgstr ""
"Se você precisar adicionar uma `Option` ao final de um iterador existente, "
"você pode\n"
"passe para "
"[`.chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain):"

#: src\idioms/option-iter.md:29
msgid ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"for logician in logicians.iter().chain(turing.iter()) {\n"
"    println!(\"{} is a logician\", logician);\n"
"}\n"
"```"
msgstr ""

#: src\idioms/option-iter.md:38
#, fuzzy
msgid ""
"Note that if the `Option` is always `Some`, then it is more idiomatic to "
"use\n"
"[`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) on the\n"
"element instead."
msgstr ""
"Note que se `Option` for sempre `Some`, então é mais idiomático usar\n"
"[`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) no\n"
"elemento em vez disso."

#: src\idioms/option-iter.md:42
#, fuzzy
msgid ""
"Also, since `Option` implements `IntoIterator`, it's possible to iterate "
"over\n"
"it using a `for` loop. This is equivalent to matching it with `if let "
"Some(..)`,\n"
"and in most cases you should prefer the latter."
msgstr ""
"Além disso, como `Option` implementa `IntoIterator`, é possível iterar "
"sobre\n"
"usando um loop `for`. Isso é equivalente a combiná-lo com `if let "
"Some(..)`,\n"
"e na maioria dos casos você deve preferir o último."

#: src\idioms/option-iter.md:48
#, fuzzy
msgid ""
"- [`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) is "
"an\n"
"  iterator which yields exactly one element. It's a more readable "
"alternative to\n"
"  `Some(foo).into_iter()`.\n"
"\n"
"- "
"[`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map)\n"
"  is a version of "
"[`Iterator::map`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map),\n"
"  specialized to mapping functions which return `Option`.\n"
"\n"
"- The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions\n"
"  for converting an `Option` to a zero- or one-element slice.\n"
"\n"
"- [Documentation for "
"`Option<T>`](https://doc.rust-lang.org/std/option/enum.Option.html)"
msgstr ""
"- [`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) é um\n"
"  iterator que produz exatamente um elemento. É uma alternativa mais legível "
"para\n"
"  `Some(foo).into_iter()`.\n"
"\n"
"- "
"[`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map)\n"
"  é uma versão do "
"[`Iterator::map`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map),\n"
"  especializado para funções de mapeamento que retornam `Option`.\n"
"\n"
"- A caixa [`ref_slice`](https://crates.io/crates/ref_slice) fornece funções\n"
"  para converter uma `Opção` em uma fatia de zero ou um elemento.\n"
"\n"
"- [Documentação para "
"`Option<T>`](https://doc.rust-lang.org/std/option/enum.Option.html)"

#: src\idioms/pass-var-to-closure.md:1
#, fuzzy
msgid "# Pass variables to closure"
msgstr "# Passa variáveis para encerramento"

#: src\idioms/pass-var-to-closure.md:5
#, fuzzy
msgid ""
"By default, closures capture their environment by borrowing. Or you can use\n"
"`move`-closure to move whole environment. However, often you want to move "
"just\n"
"some variables to closure, give it copy of some data, pass it by reference, "
"or\n"
"perform some other transformation."
msgstr ""
"Por padrão, os fechamentos capturam seu ambiente por empréstimo. Ou você "
"pode usar\n"
"fechamento `move` para mover todo o ambiente. No entanto, muitas vezes você "
"deseja mover apenas\n"
"algumas variáveis para fechamento, dar-lhe cópia de alguns dados, passá-lo "
"por referência ou\n"
"realizar alguma outra transformação."

#: src\idioms/pass-var-to-closure.md:10
#, fuzzy
msgid "Use variable rebinding in separate scope for that."
msgstr "Use a religação de variável em escopo separado para isso."

#: src\idioms/pass-var-to-closure.md:14
#, fuzzy
msgid "Use"
msgstr "Usar"

#: src\idioms/pass-var-to-closure.md:16
msgid ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"let closure = {\n"
"    // `num1` is moved\n"
"    let num2 = num2.clone();  // `num2` is cloned\n"
"    let num3 = num3.as_ref();  // `num3` is borrowed\n"
"    move || {\n"
"        *num1 + *num2 + *num3;\n"
"    }\n"
"};\n"
"```"
msgstr ""

#: src\idioms/pass-var-to-closure.md:32
#, fuzzy
msgid "instead of"
msgstr "em vez de"

#: src\idioms/pass-var-to-closure.md:34
msgid ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"\n"
"let num2_cloned = num2.clone();\n"
"let num3_borrowed = num3.as_ref();\n"
"let closure = move || {\n"
"    *num1 + *num2_cloned + *num3_borrowed;\n"
"};\n"
"```"
msgstr ""

#: src\idioms/pass-var-to-closure.md:50
#, fuzzy
msgid ""
"Copied data are grouped together with closure definition, so their purpose "
"is\n"
"more clear, and they will be dropped immediately even if they are not "
"consumed\n"
"by closure."
msgstr ""
"Os dados copiados são agrupados com a definição de fechamento, portanto, sua "
"finalidade é\n"
"mais claros, e eles serão descartados imediatamente, mesmo que não sejam "
"consumidos\n"
"por fechamento."

#: src\idioms/pass-var-to-closure.md:54
#, fuzzy
msgid ""
"Closure uses same variable names as surrounding code whether data are copied "
"or\n"
"moved."
msgstr ""
"Closure usa os mesmos nomes de variáveis que o código ao redor, sejam os "
"dados copiados ou\n"
"mudou-se."

#: src\idioms/pass-var-to-closure.md:59
#, fuzzy
msgid "Additional indentation of closure body."
msgstr "Recuo adicional do corpo da tampa."

#: src\idioms/priv-extend.md:1
#, fuzzy
msgid "# `#[non_exhaustive]` and private fields for extensibility"
msgstr "# `#[non_exhaustive]` e campos privados para extensibilidade"

#: src\idioms/priv-extend.md:5
#, fuzzy
msgid ""
"A small set of scenarios exist where a library author may want to add "
"public\n"
"fields to a public struct or new variants to an enum without breaking "
"backwards\n"
"compatibility."
msgstr ""
"Existe um pequeno conjunto de cenários em que um autor de biblioteca pode "
"querer adicionar\n"
"campos para uma estrutura pública ou novas variantes para uma enumeração sem "
"quebrar para trás\n"
"compatibilidade."

#: src\idioms/priv-extend.md:9
#, fuzzy
msgid "Rust offers two solutions to this problem:"
msgstr "Rust oferece duas soluções para este problema:"

#: src\idioms/priv-extend.md:11
#, fuzzy
msgid ""
"- Use `#[non_exhaustive]` on `struct`s, `enum`s, and `enum` variants.\n"
"  For extensive documentation on all the places where `#[non_exhaustive]` "
"can be\n"
"  used, see [the "
"docs](https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute).\n"
"\n"
"- You may add a private field to a struct to prevent it from being directly\n"
"  instantiated or matched against (see Alternative)"
msgstr ""
"- Use `#[non_exhaustive]` nas variantes `struct`s, `enum`s e `enum`.\n"
"  Para documentação extensa sobre todos os lugares onde `#[non_exhaustive]` "
"pode ser\n"
"  usado, consulte [os "
"documentos](https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute).\n"
"\n"
"- Você pode adicionar um campo privado a uma estrutura para evitar que ela "
"seja diretamente\n"
"  instanciado ou comparado (ver Alternativa)"

#: src\idioms/priv-extend.md:20
msgid ""
"```rust\n"
"mod a {\n"
"    // Public struct.\n"
"    #[non_exhaustive]\n"
"    pub struct S {\n"
"        pub foo: i32,\n"
"    }\n"
"    \n"
"    #[non_exhaustive]\n"
"    pub enum AdmitMoreVariants {\n"
"        VariantA,\n"
"        VariantB,\n"
"        #[non_exhaustive]\n"
"        VariantC { a: String }\n"
"    }\n"
"}\n"
"\n"
"fn print_matched_variants(s: a::S) {\n"
"    // Because S is `#[non_exhaustive]`, it cannot be named here and\n"
"    // we must use `..` in the pattern.\n"
"    let a::S { foo: _, ..} = s;\n"
"    \n"
"    let some_enum = a::AdmitMoreVariants::VariantA;\n"
"    match some_enum {\n"
"        a::AdmitMoreVariants::VariantA => println!(\"it's an A\"),\n"
"        a::AdmitMoreVariants::VariantB => println!(\"it's a b\"),\n"
"\n"
"        // .. required because this variant is non-exhaustive as well\n"
"        a::AdmitMoreVariants::VariantC { a, .. } => println!(\"it's a c\"),\n"
"\n"
"        // The wildcard match is required because more variants may be\n"
"        // added in the future\n"
"        _ => println!(\"it's a new variant\")\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\idioms/priv-extend.md:57
#, fuzzy
msgid "## Alternative: `Private fields` for structs"
msgstr "## Alternativa: `Campos privados` para structs"

#: src\idioms/priv-extend.md:59
#, fuzzy
msgid ""
"`#[non_exhaustive]` only works across crate boundaries.\n"
"Within a crate, the private field method may be used."
msgstr ""
"`#[non_exhaustive]` só funciona além dos limites da caixa.\n"
"Dentro de uma caixa, o método de campo privado pode ser usado."

#: src\idioms/priv-extend.md:62
#, fuzzy
msgid ""
"Adding a field to a struct is a mostly backwards compatible change.\n"
"However, if a client uses a pattern to deconstruct a struct instance, they\n"
"might name all the fields in the struct and adding a new one would break "
"that\n"
"pattern.\n"
"The client could name some fields and use `..` in the pattern, in which case "
"adding\n"
"another field is backwards compatible.\n"
"Making at least one of the struct's fields private forces clients to use the "
"latter\n"
"form of patterns, ensuring that the struct is future-proof."
msgstr ""
"Adicionar um campo a uma estrutura é uma alteração compatível com versões "
"anteriores.\n"
"No entanto, se um cliente usar um padrão para desconstruir uma instância "
"struct, ele\n"
"pode nomear todos os campos na estrutura e adicionar um novo quebraria isso\n"
"padrão.\n"
"O cliente pode nomear alguns campos e usar `..` no padrão, caso em que "
"adicionar\n"
"outro campo é compatível com versões anteriores.\n"
"Tornar privado pelo menos um dos campos da estrutura obriga os clientes a "
"usar o último\n"
"forma de padrões, garantindo que a estrutura seja à prova de futuro."

#: src\idioms/priv-extend.md:71
#, fuzzy
msgid ""
"The downside of this approach is that you might need to add an otherwise "
"unneeded\n"
"field to the struct.\n"
"You can use the `()` type so that there is no runtime overhead and prepend "
"`_` to\n"
"the field name to avoid the unused field warning."
msgstr ""
"A desvantagem dessa abordagem é que você pode precisar adicionar um\n"
"campo para a estrutura.\n"
"Você pode usar o tipo `()` para que não haja sobrecarga de tempo de execução "
"e anexar `_` para\n"
"o nome do campo para evitar o aviso de campo não utilizado."

#: src\idioms/priv-extend.md:76
msgid ""
"```rust\n"
"pub struct S {\n"
"    pub a: i32,\n"
"    // Because `b` is private, you cannot match on `S` without using `..` "
"and `S`\n"
"    //  cannot be directly instantiated or matched against\n"
"    _b: ()\n"
"}\n"
"```"
msgstr ""

#: src\idioms/priv-extend.md:87
#, fuzzy
msgid ""
"On `struct`s, `#[non_exhaustive]` allows adding additional fields in a "
"backwards\n"
"compatible way.\n"
"It will also prevent clients from using the struct constructor, even if all "
"the\n"
"fields are public.\n"
"This may be helpful, but it's worth considering if you _want_ an additional "
"field\n"
"to be found by clients as a compiler error rather than something that may be "
"silently\n"
"undiscovered."
msgstr ""
"Em `struct`s, `#[non_exhaustive]` permite adicionar campos adicionais de "
"forma inversa\n"
"maneira compatível.\n"
"Também impedirá que os clientes usem o construtor struct, mesmo que todos "
"os\n"
"campos são públicos.\n"
"Isso pode ser útil, mas vale a pena considerar se você _quer_ um campo "
"adicional\n"
"ser encontrado pelos clientes como um erro do compilador em vez de algo que "
"pode ser silenciosamente\n"
"não descoberto."

#: src\idioms/priv-extend.md:95
#, fuzzy
msgid ""
"`#[non_exhaustive]` can be applied to enum variants as well.\n"
"A `#[non_exhaustive]` variant behaves in the same way as a "
"`#[non_exhaustive]` struct."
msgstr ""
"`#[non_exhaustive]` também pode ser aplicado a variantes de enumeração.\n"
"Uma variante `#[non_exhaustive]` se comporta da mesma forma que uma "
"estrutura `#[non_exhaustive]`."

#: src\idioms/priv-extend.md:98
#, fuzzy
msgid ""
"Use this deliberately and with caution: incrementing the major version when "
"adding\n"
"fields or variants is often a better option.\n"
"`#[non_exhaustive]` may be appropriate in scenarios where you're modeling an "
"external\n"
"resource that may change out-of-sync with your library, but is not a general "
"purpose\n"
"tool."
msgstr ""
"Use isso deliberadamente e com cautela: incrementando a versão principal ao "
"adicionar\n"
"campos ou variantes geralmente é uma opção melhor.\n"
"`#[non_exhaustive]` pode ser apropriado em cenários onde você está modelando "
"um externo\n"
"recurso que pode ficar fora de sincronia com sua biblioteca, mas não é um "
"propósito geral\n"
"ferramenta."

#: src\idioms/priv-extend.md:104
#, fuzzy
msgid "### Disadvantages"
msgstr "### Desvantagens"

#: src\idioms/priv-extend.md:106
#, fuzzy
msgid ""
"`#[non_exhaustive]` can make your code much less ergonomic to use, "
"especially when\n"
"forced to handle unknown enum variants.\n"
"It should only be used when these sorts of evolutions are required "
"**without**\n"
"incrementing the major version."
msgstr ""
"`#[non_exhaustive]` pode tornar seu código muito menos ergonômico de usar, "
"especialmente quando\n"
"forçado a lidar com variantes de enumeração desconhecidas.\n"
"Só deve ser usado quando esses tipos de evoluções são necessários **sem**\n"
"incrementando a versão principal."

#: src\idioms/priv-extend.md:111
msgid ""
"When `#[non_exhaustive]` is applied to `enum`s, it forces clients to handle "
"a\n"
"wildcard variant.\n"
"If there is no sensible action to take in this case, this may lead to "
"awkward\n"
"code and code paths that are only executed in extremely rare circumstances.\n"
"If a client decides to `panic!()` in this scenario, it may have been better "
"to\n"
"expose this error at compile time.\n"
"In fact, `#[non_exhaustive]` forces clients to handle the \"Something else\" "
"case;\n"
"there is rarely a sensible action to take in this scenario."
msgstr ""

#: src\idioms/priv-extend.md:122
#, fuzzy
msgid ""
"- [RFC introducing #[non_exhaustive] attribute for enums and "
"structs](https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"
msgstr ""
"- [RFC introduzindo o atributo #[non_exhaustive] para enums e "
"structs](https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"

#: src\idioms/rustdoc-init.md:1
#, fuzzy
msgid "# Easy doc initialization\r"
msgstr "# Fácil inicialização do documento\r"

#: src\idioms/rustdoc-init.md:5
#, fuzzy
msgid ""
"If a struct takes significant effort to initialize when writing docs, it can "
"be\r\n"
"quicker to wrap your example with a helper function which takes the struct "
"as an\r\n"
"argument."
msgstr ""
"Se uma estrutura requer um esforço significativo para inicializar ao "
"escrever documentos, pode ser\r\n"
"mais rápido para agrupar seu exemplo com uma função auxiliar que usa a "
"estrutura como um\r\n"
"argumento."

#: src\idioms/rustdoc-init.md:9
#, fuzzy
msgid "## Motivation\r"
msgstr "## Motivação\r"

#: src\idioms/rustdoc-init.md:11
#, fuzzy
msgid ""
"Sometimes there is a struct with multiple or complicated parameters and "
"several\r\n"
"methods. Each of these methods should have examples."
msgstr ""
"Às vezes, há uma estrutura com parâmetros múltiplos ou complicados e "
"vários\r\n"
"métodos. Cada um desses métodos deve ter exemplos."

#: src\idioms/rustdoc-init.md:14
#, fuzzy
msgid "For example:"
msgstr "Por exemplo:"

#: src\idioms/rustdoc-init.md:16
msgid ""
"````rust,ignore\r\n"
"struct Connection {\r\n"
"    name: String,\r\n"
"    stream: TcpStream,\r\n"
"}\r\n"
"\r\n"
"impl Connection {\r\n"
"    /// Sends a request over the connection.\r\n"
"    ///\r\n"
"    /// # Example\r\n"
"    /// ```no_run\r\n"
"    /// # // Boilerplate are required to get an example working.\r\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\");\r\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), stream "
"};\r\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\");\r\n"
"    /// let response = connection.send_request(request);\r\n"
"    /// assert!(response.is_ok());\r\n"
"    /// ```\r\n"
"    fn send_request(&self, request: Request) -> Result<Status, SendErr> {\r\n"
"        // ...\r\n"
"    }\r\n"
"\r\n"
"    /// Oh no, all that boilerplate needs to be repeated here!\r\n"
"    fn check_status(&self) -> Status {\r\n"
"        // ...\r\n"
"    }\r\n"
"}\r\n"
"````"
msgstr ""

#: src\idioms/rustdoc-init.md:45
#, fuzzy
msgid "## Example\r"
msgstr "## Exemplo\r"

#: src\idioms/rustdoc-init.md:47
#, fuzzy
msgid ""
"Instead of typing all of this boilerplate to create a `Connection` and\r\n"
"`Request`, it is easier to just create a wrapping helper function which "
"takes\r\n"
"them as arguments:"
msgstr ""
"Em vez de digitar todo esse clichê para criar uma `Conexão` e\r\n"
"`Request`, é mais fácil apenas criar uma função auxiliar de empacotamento "
"que leva\r\n"
"como argumentos:"

#: src\idioms/rustdoc-init.md:51
msgid ""
"````rust,ignore\r\n"
"struct Connection {\r\n"
"    name: String,\r\n"
"    stream: TcpStream,\r\n"
"}\r\n"
"\r\n"
"impl Connection {\r\n"
"    /// Sends a request over the connection.\r\n"
"    ///\r\n"
"    /// # Example\r\n"
"    /// ```\r\n"
"    /// # fn call_send(connection: Connection, request: Request) {\r\n"
"    /// let response = connection.send_request(request);\r\n"
"    /// assert!(response.is_ok());\r\n"
"    /// # }\r\n"
"    /// ```\r\n"
"    fn send_request(&self, request: Request) {\r\n"
"        // ...\r\n"
"    }\r\n"
"}\r\n"
"````"
msgstr ""

#: src\idioms/rustdoc-init.md:73
msgid ""
"**Note** in the above example the line `assert!(response.is_ok());` will "
"not\r\n"
"actually run while testing because it is inside a function which is never\r\n"
"invoked."
msgstr ""

#: src\idioms/rustdoc-init.md:77
#, fuzzy
msgid "## Advantages\r"
msgstr "## Vantagens\r"

#: src\idioms/rustdoc-init.md:79
#, fuzzy
msgid "This is much more concise and avoids repetitive code in examples."
msgstr "Isso é muito mais conciso e evita código repetitivo em exemplos."

#: src\idioms/rustdoc-init.md:81
#, fuzzy
msgid "## Disadvantages\r"
msgstr "## Desvantagens\r"

#: src\idioms/rustdoc-init.md:83
#, fuzzy
msgid ""
"As example is in a function, the code will not be tested. Though it will "
"still be\r\n"
"checked to make sure it compiles when running a `cargo test`. So this "
"pattern is\r\n"
"most useful when you need `no_run`. With this, you do not need to add "
"`no_run`."
msgstr ""
"Como o exemplo está em uma função, o código não será testado. Embora ainda "
"seja\r\n"
"verificado para garantir que ele compila ao executar um `teste de carga`. "
"Então esse padrão é\r\n"
"mais útil quando você precisa de `no_run`. Com isso, você não precisa "
"adicionar `no_run`."

#: src\idioms/rustdoc-init.md:87
#, fuzzy
msgid "## Discussion\r"
msgstr "## Discussão\r"

#: src\idioms/rustdoc-init.md:89
#, fuzzy
msgid "If assertions are not required this pattern works well."
msgstr "Se as asserções não forem necessárias, esse padrão funcionará bem."

#: src\idioms/rustdoc-init.md:91
#, fuzzy
msgid ""
"If they are, an alternative can be to create a public method to create a "
"helper\r\n"
"instance which is annotated with `#[doc(hidden)]` (so that users won't see "
"it).\r\n"
"Then this method can be called inside of rustdoc because it is part of "
"the\r\n"
"crate's public API."
msgstr ""
"Se forem, uma alternativa pode ser criar um método público para criar um "
"auxiliar\r\n"
"instância que é anotada com `#[doc(hidden)]` (para que os usuários não a "
"vejam).\r\n"
"Então este método pode ser chamado dentro do rustdoc porque faz parte do\r\n"
"API pública da caixa."

#: src\idioms/temporary-mutability.md:1
#, fuzzy
msgid "# Temporary mutability"
msgstr "# Mutabilidade temporária"

#: src\idioms/temporary-mutability.md:5
#, fuzzy
msgid ""
"Often it is necessary to prepare and process some data, but after that data "
"are\n"
"only inspected and never modified. The intention can be made explicit by "
"redefining\n"
"the mutable variable as immutable."
msgstr ""
"Muitas vezes é necessário preparar e processar alguns dados, mas depois "
"disso os dados são\n"
"apenas inspecionado e nunca modificado. A intenção pode ser tornada "
"explícita redefinindo\n"
"a variável mutável como imutável."

#: src\idioms/temporary-mutability.md:9
#, fuzzy
msgid ""
"It can be done either by processing data within a nested block or by "
"redefining\n"
"the variable."
msgstr ""
"Isso pode ser feito processando dados dentro de um bloco aninhado ou "
"redefinindo\n"
"a variável."

#: src\idioms/temporary-mutability.md:14
#, fuzzy
msgid "Say, vector must be sorted before usage."
msgstr "Diga, o vetor deve ser classificado antes do uso."

#: src\idioms/temporary-mutability.md:16
#, fuzzy
msgid "Using nested block:"
msgstr "Usando bloco aninhado:"

#: src\idioms/temporary-mutability.md:18
msgid ""
"```rust,ignore\n"
"let data = {\n"
"    let mut data = get_vec();\n"
"    data.sort();\n"
"    data\n"
"};\n"
"\n"
"// Here `data` is immutable.\n"
"```"
msgstr ""

#: src\idioms/temporary-mutability.md:28
#, fuzzy
msgid "Using variable rebinding:"
msgstr "Usando religação de variável:"

#: src\idioms/temporary-mutability.md:30
msgid ""
"```rust,ignore\n"
"let mut data = get_vec();\n"
"data.sort();\n"
"let data = data;\n"
"\n"
"// Here `data` is immutable.\n"
"```"
msgstr ""

#: src\idioms/temporary-mutability.md:40
#, fuzzy
msgid ""
"Compiler ensures that you don't accidentally mutate data after some point."
msgstr ""
"O compilador garante que você não modifique dados acidentalmente após algum "
"ponto."

#: src\idioms/temporary-mutability.md:44
#, fuzzy
msgid ""
"Nested block requires additional indentation of block body.\n"
"One more line to return data from block or redefine variable."
msgstr ""
"O bloco aninhado requer recuo adicional do corpo do bloco.\n"
"Mais uma linha para retornar dados do bloco ou redefinir variável."

#: src\idioms/return-consumed-arg-on-error.md:1
#, fuzzy
msgid "# Return consumed argument on error"
msgstr "# Retorna o argumento consumido em caso de erro"

#: src\idioms/return-consumed-arg-on-error.md:5
#, fuzzy
msgid ""
"If a fallible function consumes (moves) an argument, return that argument "
"back inside\n"
"an error."
msgstr ""
"Se uma função falível consumir (mover) um argumento, retorne esse argumento "
"para dentro\n"
"um erro."

#: src\idioms/return-consumed-arg-on-error.md:10
msgid ""
"```rust\n"
"pub fn send(value: String) -> Result<(), SendError> {\n"
"    println!(\"using {value} in a meaningful way\");\n"
"    // Simulate non-deterministic fallible action.\n"
"    use std::time::SystemTime;\n"
"    let period = "
"SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();\n"
"    if period.subsec_nanos() % 2 == 1 {\n"
"        Ok(())\n"
"    } else {\n"
"        Err(SendError(value))\n"
"    }\n"
"}\n"
"\n"
"pub struct SendError(String);\n"
"\n"
"fn main() {\n"
"    let mut value = \"imagine this is very long string\".to_string();\n"
"\n"
"    let success = 's: {\n"
"        // Try to send value two times.\n"
"        for _ in 0..2 {\n"
"            value = match send(value) {\n"
"                Ok(()) => break 's true,\n"
"                Err(SendError(value)) => value,\n"
"            }\n"
"        }\n"
"        false\n"
"    };\n"
"\n"
"    println!(\"success: {}\", success);\n"
"}\n"
"```"
msgstr ""

#: src\idioms/return-consumed-arg-on-error.md:45
#, fuzzy
msgid ""
"In case of error you may want to try some alternative way or to\n"
"retry action in case of non-deterministic function. But if the argument\n"
"is always consumed, you are forced to clone it on every call, which\n"
"is not very efficient."
msgstr ""
"Em caso de erro, você pode querer tentar alguma forma alternativa ou\n"
"repetir a ação em caso de função não determinística. Mas se o argumento\n"
"é sempre consumido, você é forçado a cloná-lo em todas as chamadas, o que\n"
"não é muito eficiente."

#: src\idioms/return-consumed-arg-on-error.md:50
#, fuzzy
msgid ""
"The standard library uses this approach in e.g. `String::from_utf8` method.\n"
"When given a vector that doesn't contain valid UTF-8, a `FromUtf8Error`\n"
"is returned.\n"
"You can get original vector back using `FromUtf8Error::into_bytes` method."
msgstr ""
"A biblioteca padrão usa esta abordagem em, por exemplo, Método "
"`String::from_utf8`.\n"
"Quando dado um vetor que não contém UTF-8 válido, um `FromUtf8Error`\n"
"é devolvido.\n"
"Você pode recuperar o vetor original usando o método "
"`FromUtf8Error::into_bytes`."

#: src\idioms/return-consumed-arg-on-error.md:57
#, fuzzy
msgid "Better performance because of moving arguments whenever possible."
msgstr "Melhor desempenho devido a argumentos em movimento sempre que possível."

#: src\idioms/return-consumed-arg-on-error.md:61
#, fuzzy
msgid "Slightly more complex error types."
msgstr "Tipos de erro um pouco mais complexos."

#: src\patterns/index.md:1
#, fuzzy
msgid "# Design Patterns"
msgstr "# Padrões de design"

#: src\patterns/index.md:3
#, fuzzy
msgid ""
"[Design patterns](https://en.wikipedia.org/wiki/Software_design_pattern) "
"are\n"
"\"general reusable solutions to a commonly occurring problem within a given\n"
"context in software design\". Design patterns are a great way to describe "
"the\n"
"culture of a programming language. Design patterns are very "
"language-specific -\n"
"what is a pattern in one language may be unnecessary in another due to a\n"
"language feature, or impossible to express due to a missing feature."
msgstr ""
"[Padrões de design](https://en.wikipedia.org/wiki/Software_design_pattern) "
"são\n"
"“soluções gerais reutilizáveis para um problema que ocorre comumente dentro "
"de um determinado\n"
"contexto no design de software\". Os padrões de design são uma ótima maneira "
"de descrever o\n"
"cultura de uma linguagem de programação. Os padrões de design são muito "
"específicos da linguagem -\n"
"o que é um padrão em um idioma pode ser desnecessário em outro devido a uma\n"
"recurso de linguagem ou impossível de expressar devido a um recurso ausente."

#: src\patterns/index.md:10
#, fuzzy
msgid ""
"If overused, design patterns can add unnecessary complexity to programs.\n"
"However, they are a great way to share intermediate and advanced level "
"knowledge\n"
"about a programming language."
msgstr ""
"Se usados em excesso, os padrões de projeto podem adicionar complexidade "
"desnecessária aos programas.\n"
"No entanto, eles são uma ótima maneira de compartilhar conhecimentos de "
"nível intermediário e avançado\n"
"sobre uma linguagem de programação."

#: src\patterns/index.md:16
#, fuzzy
msgid ""
"Rust has many unique features. These features give us great benefit by "
"removing\n"
"whole classes of problems. Some of them are also patterns that are _unique_ "
"to Rust."
msgstr ""
"Rust tem muitos recursos exclusivos. Esses recursos nos dão grande benefício "
"ao remover\n"
"classes inteiras de problemas. Alguns deles também são padrões _exclusivos_ "
"do Rust."

#: src\patterns/index.md:19
#, fuzzy
msgid "## YAGNI"
msgstr "## YAGNI"

#: src\patterns/index.md:21
#, fuzzy
msgid ""
"YAGNI is an acronym that stands for `You Aren't Going to Need It`.\n"
"It's a vital software design principle to apply as you write code."
msgstr ""
"YAGNI é um acrônimo que significa `You Are not Going to Need It`.\n"
"É um princípio de design de software vital a ser aplicado enquanto você "
"escreve o código."

#: src\patterns/index.md:24
#, fuzzy
msgid "> The best code I ever wrote was code I never wrote."
msgstr "> O melhor código que já escrevi foi um código que nunca escrevi."

#: src\patterns/index.md:26
#, fuzzy
msgid ""
"If we apply YAGNI to design patterns, we see that the features of Rust allow "
"us to\n"
"throw out many patterns. For instance, there is no need for the [strategy "
"pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"in Rust because we can just use "
"[traits](https://doc.rust-lang.org/book/traits.html)."
msgstr ""
"Se aplicarmos o YAGNI aos padrões de projeto, veremos que os recursos do "
"Rust nos permitem\n"
"jogue fora muitos padrões. Por exemplo, não há necessidade do [padrão de "
"estratégia](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"em Rust porque podemos usar apenas "
"[traits](https://doc.rust-lang.org/book/traits.html)."

#: src\patterns/behavioural/intro.md:1
#, fuzzy
msgid "# Behavioural Patterns"
msgstr "# Padrões Comportamentais"

#: src\patterns/behavioural/intro.md:3
#, fuzzy
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern):"
msgstr "Da [Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern):"

#: src\patterns/behavioural/intro.md:5
#, fuzzy
msgid ""
"> Design patterns that identify common communication patterns among "
"objects.\n"
"> By doing so, these patterns increase flexibility in carrying out "
"communication."
msgstr ""
"> Padrões de design que identificam padrões comuns de comunicação entre "
"objetos.\n"
"> Ao fazer isso, esses padrões aumentam a flexibilidade na realização da "
"comunicação."

#: src\patterns/behavioural/command.md:1
#, fuzzy
msgid "# Command"
msgstr "# Comando"

#: src\patterns/behavioural/command.md:5
#, fuzzy
msgid ""
"The basic idea of the Command pattern is to separate out actions into its "
"own\n"
"objects and pass them as parameters."
msgstr ""
"A ideia básica do padrão Command é separar as ações em seu próprio\n"
"objetos e passá-los como parâmetros."

#: src\patterns/behavioural/command.md:10
#, fuzzy
msgid ""
"Suppose we have a sequence of actions or transactions encapsulated as "
"objects.\n"
"We want these actions or commands to be executed or invoked in some order "
"later\n"
"at different time. These commands may also be triggered as a result of some "
"event.\n"
"For example, when a user pushes a button, or on arrival of a data packet.\n"
"In addition, these commands might be undoable. This may come in useful for\n"
"operations of an editor. We might want to store logs of executed commands so "
"that\n"
"we could reapply the changes later if the system crashes."
msgstr ""
"Suponha que tenhamos uma sequência de ações ou transações encapsuladas como "
"objetos.\n"
"Queremos que essas ações ou comandos sejam executados ou invocados em alguma "
"ordem posteriormente\n"
"em tempo diferente. Esses comandos também podem ser acionados como resultado "
"de algum evento.\n"
"Por exemplo, quando um usuário pressiona um botão ou na chegada de um pacote "
"de dados.\n"
"Além disso, esses comandos podem ser desfeitos. Isso pode ser útil para\n"
"operações de um editor. Podemos querer armazenar logs de comandos executados "
"para que\n"
"poderíamos reaplicar as alterações mais tarde se o sistema travar."

#: src\patterns/behavioural/command.md:20
#, fuzzy
msgid ""
"Define two database operations `create table` and `add field`. Each of "
"these\n"
"operations is a command which knows how to undo the command, e.g., `drop "
"table`\n"
"and `remove field`. When a user invokes a database migration operation then "
"each\n"
"command is executed in the defined order, and when the user invokes the "
"rollback\n"
"operation then the whole set of commands is invoked in reverse order."
msgstr ""
"Defina duas operações de banco de dados `create table` e `add field`. Cada "
"um desses\n"
"operações é um comando que sabe como desfazer o comando, por exemplo, `drop "
"table`\n"
"e `remover campo`. Quando um usuário invoca uma operação de migração de "
"banco de dados, cada\n"
"comando é executado na ordem definida e quando o usuário invoca o rollback\n"
"operação, então todo o conjunto de comandos é invocado na ordem inversa."

#: src\patterns/behavioural/command.md:26
#, fuzzy
msgid "## Approach: Using trait objects"
msgstr "## Abordagem: Usando objetos de característica"

#: src\patterns/behavioural/command.md:28
#, fuzzy
msgid ""
"We define a common trait which encapsulates our command with two operations\n"
"`execute` and `rollback`. All command `structs` must implement this trait."
msgstr ""
"Definimos uma característica comum que encapsula nosso comando com duas "
"operações\n"
"`execute` e `rollback`. Todos os `structs` de comando devem implementar esta "
"característica."

#: src\patterns/behavioural/command.md:31
msgid ""
"```rust\n"
"pub trait Migration {\n"
"    fn execute(&self) -> &str;\n"
"    fn rollback(&self) -> &str;\n"
"}\n"
"\n"
"pub struct CreateTable;\n"
"impl Migration for CreateTable {\n"
"    fn execute(&self) -> &str {\n"
"        \"create table\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"drop table\"\n"
"    }\n"
"}\n"
"\n"
"pub struct AddField;\n"
"impl Migration for AddField {\n"
"    fn execute(&self) -> &str {\n"
"        \"add field\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"remove field\"\n"
"    }\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Box<dyn Migration>>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"\n"
"    fn add_migration(&mut self, cmd: Box<dyn Migration>) {\n"
"        self.commands.push(cmd);\n"
"    }\n"
"\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev() // reverse iterator's direction\n"
"            .map(|cmd| cmd.rollback())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"\n"
"    let cmd = Box::new(CreateTable);\n"
"    schema.add_migration(cmd);\n"
"    let cmd = Box::new(AddField);\n"
"    schema.add_migration(cmd);\n"
"\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/command.md:95
#, fuzzy
msgid "## Approach: Using function pointers"
msgstr "## Abordagem: Usando ponteiros de função"

#: src\patterns/behavioural/command.md:97
#, fuzzy
msgid ""
"We could follow another approach by creating each individual command as\n"
"a different function and store function pointers to invoke these functions "
"later\n"
"at a different time. Since function pointers implement all three traits "
"`Fn`,\n"
"`FnMut`, and `FnOnce` we could as well pass and store closures instead of\n"
"function pointers."
msgstr ""
"Poderíamos seguir outra abordagem criando cada comando individual como\n"
"uma função diferente e armazenar ponteiros de função para invocar essas "
"funções mais tarde\n"
"em um momento diferente. Como os ponteiros de função implementam todas as "
"três características `Fn`,\n"
"`FnMut` e `FnOnce`, poderíamos passar e armazenar encerramentos em vez de\n"
"ponteiros de função."

#: src\patterns/behavioural/command.md:103
msgid ""
"```rust\n"
"type FnPtr = fn() -> String;\n"
"struct Command {\n"
"    execute: FnPtr,\n"
"    rollback: FnPtr,\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Command>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"    fn add_migration(&mut self, execute: FnPtr, rollback: FnPtr) {\n"
"        self.commands.push(Command { execute, rollback });\n"
"    }\n"
"    fn execute(&self) -> Vec<String> {\n"
"        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<String> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev()\n"
"            .map(|cmd| (cmd.rollback)())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> String {\n"
"    \"add field\".to_string()\n"
"}\n"
"\n"
"fn remove_field() -> String {\n"
"    \"remove field\".to_string()\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\".to_string(), || \"drop "
"table\".to_string());\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/command.md:150
#, fuzzy
msgid "## Approach: Using `Fn` trait objects"
msgstr "## Abordagem: Usando objetos de característica `Fn`"

#: src\patterns/behavioural/command.md:152
#, fuzzy
msgid ""
"Finally, instead of defining a common command trait we could store\n"
"each command implementing the `Fn` trait separately in vectors."
msgstr ""
"Finalmente, em vez de definir um traço de comando comum, poderíamos "
"armazenar\n"
"cada comando implementando o traço `Fn` separadamente em vetores."

#: src\patterns/behavioural/command.md:155
msgid ""
"```rust\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
"\n"
"struct Schema<'a> {\n"
"    executes: Vec<Migration<'a>>,\n"
"    rollbacks: Vec<Migration<'a>>,\n"
"}\n"
"\n"
"impl<'a> Schema<'a> {\n"
"    fn new() -> Self {\n"
"        Self {\n"
"            executes: vec![],\n"
"            rollbacks: vec![],\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    where\n"
"        E: Fn() -> &'a str + 'static,\n"
"        R: Fn() -> &'a str + 'static,\n"
"    {\n"
"        self.executes.push(Box::new(execute));\n"
"        self.rollbacks.push(Box::new(rollback));\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str {\n"
"    \"add field\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str {\n"
"    \"remove field\"\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\", || \"drop table\");\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/command.md:205
#, fuzzy
msgid ""
"If our commands are small and may be defined as functions or passed as a "
"closure\n"
"then using function pointers might be preferable since it does not exploit\n"
"dynamic dispatch. But if our command is a whole struct with a bunch of "
"functions\n"
"and variables defined as seperated module then using trait objects would be\n"
"more suitable. A case of application can be found in "
"[`actix`](https://actix.rs/),\n"
"which uses trait objects when it registers a handler function for routes.\n"
"In case of using `Fn` trait objects we can create and use commands in the "
"same\n"
"way as we used in case of function pointers."
msgstr ""
"Se nossos comandos são pequenos e podem ser definidos como funções ou "
"passados como encerramento\n"
"usar ponteiros de função pode ser preferível, pois não explora\n"
"despacho dinâmico. Mas se nosso comando for uma estrutura inteira com um "
"monte de funções\n"
"e variáveis definidas como módulo separado, então usar objetos de "
"característica seria\n"
"mais adequado. Um caso de aplicação pode ser encontrado em "
"[`actix`](https://actix.rs/),\n"
"que usa objetos trait quando registra uma função de manipulador para rotas.\n"
"No caso de usar objetos de característica `Fn`, podemos criar e usar "
"comandos no mesmo\n"
"maneira como usamos no caso de ponteiros de função."

#: src\patterns/behavioural/command.md:214
#, fuzzy
msgid ""
"As performance, there is always a trade-off between performance and code\n"
"simplicity and organisation. Static dispatch gives faster performance, "
"while\n"
"dynamic dispatch provides flexibility when we structure our application."
msgstr ""
"Como desempenho, sempre há uma troca entre desempenho e código\n"
"simplicidade e organização. O despacho estático oferece desempenho mais "
"rápido, enquanto\n"
"o despacho dinâmico fornece flexibilidade quando estruturamos nosso "
"aplicativo."

#: src\patterns/behavioural/command.md:220
#, fuzzy
msgid ""
"- [Command pattern](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [Another example for the `command` "
"pattern](https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"
msgstr ""
"- [Padrão de comando](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [Outro exemplo para o padrão "
"`command`](https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"

#: src\patterns/behavioural/interpreter.md:1
#, fuzzy
msgid "# Interpreter"
msgstr "# Intérprete"

#: src\patterns/behavioural/interpreter.md:5
#, fuzzy
msgid ""
"If a problem occurs very often and requires long and repetitive steps to "
"solve\n"
"it, then the problem instances might be expressed in a simple language and "
"an\n"
"interpreter object could solve it by interpreting the sentences written in "
"this\n"
"simple language."
msgstr ""
"Se um problema ocorre com muita frequência e requer etapas longas e "
"repetitivas para resolver\n"
"isso, então as instâncias do problema podem ser expressas em uma linguagem "
"simples e um\n"
"objeto intérprete poderia resolvê-lo interpretando as frases escritas neste\n"
"linguagem simples."

#: src\patterns/behavioural/interpreter.md:10
#, fuzzy
msgid "Basically, for any kind of problems we define:"
msgstr "Basicamente, para qualquer tipo de problema definimos:"

#: src\patterns/behavioural/interpreter.md:12
#, fuzzy
msgid ""
"- A [domain specific "
"language](https://en.wikipedia.org/wiki/Domain-specific_language),\n"
"- A grammar for this language,\n"
"- An interpreter that solves the problem instances."
msgstr ""
"- Um [idioma específico do "
"domínio](https://en.wikipedia.org/wiki/Domain-specific_language),\n"
"- Uma gramática para esta linguagem,\n"
"- Um interpretador que resolve as instâncias do problema."

#: src\patterns/behavioural/interpreter.md:18
#, fuzzy
msgid ""
"Our goal is to translate simple mathematical expressions into postfix "
"expressions\n"
"(or [Reverse Polish "
"notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation))\n"
"For simplicity, our expressions consist of ten digits `0`, ..., `9` and two\n"
"operations `+`, `-`. For example, the expression `2 + 4` is translated into\n"
"`2 4 +`."
msgstr ""
"Nosso objetivo é traduzir expressões matemáticas simples em expressões "
"pós-fixadas\n"
"(ou [notação polonesa "
"reversa](https://en.wikipedia.org/wiki/Reverse_Polish_notation))\n"
"Para simplificar, nossas expressões consistem em dez dígitos `0`, ..., `9` e "
"dois\n"
"operações `+`, `-`. Por exemplo, a expressão `2 + 4` é traduzida para\n"
"`2 4 +`."

#: src\patterns/behavioural/interpreter.md:24
#, fuzzy
msgid "## Context Free Grammar for our problem"
msgstr "## Gramática livre de contexto para o nosso problema"

#: src\patterns/behavioural/interpreter.md:26
#, fuzzy
msgid ""
"Our task is translating infix expressions into postfix ones. Let's define a "
"context\n"
"free grammar for a set of infix expressions over `0`, ..., `9`, `+`, and "
"`-`,\n"
"where:"
msgstr ""
"Nossa tarefa é traduzir expressões infixas em pós-fixadas. Vamos definir um "
"contexto\n"
"gramática livre para um conjunto de expressões infixas sobre `0`, ..., `9`, "
"`+` e `-`,\n"
"onde:"

#: src\patterns/behavioural/interpreter.md:30
#, fuzzy
msgid ""
"- Terminal symbols: `0`, `...`, `9`, `+`, `-`\n"
"- Non-terminal symbols: `exp`, `term`\n"
"- Start symbol is `exp`\n"
"- And the following are production rules"
msgstr ""
"- Símbolos de terminais: `0`, `...`, `9`, `+`, `-`\n"
"- Símbolos não terminais: `exp`, `term`\n"
"- O símbolo inicial é `exp`\n"
"- E as seguintes são regras de produção"

#: src\patterns/behavioural/interpreter.md:35
msgid ""
"```ignore\n"
"exp -> exp + term\n"
"exp -> exp - term\n"
"exp -> term\n"
"term -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
"```"
msgstr ""

#: src\patterns/behavioural/interpreter.md:42
#, fuzzy
msgid ""
"**NOTE:** This grammar should be further transformed depending on what we "
"are going\n"
"to do with it. For example, we might need to remove left recursion. For "
"more\n"
"details please see [Compilers: Principles,Techniques, and "
"Tools](https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools)\n"
"(aka Dragon Book)."
msgstr ""
"**NOTA:** Esta gramática deve ser transformada dependendo do que vamos\n"
"fazer com isso. Por exemplo, podemos precisar remover a recursão à esquerda. "
"Para mais\n"
"detalhes, consulte [Compilers: Principles,Techniques, and "
"Tools](https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools)\n"
"(também conhecido como Livro do Dragão)."

#: src\patterns/behavioural/interpreter.md:47
#, fuzzy
msgid "## Solution"
msgstr "## Solução"

#: src\patterns/behavioural/interpreter.md:49
#, fuzzy
msgid ""
"We simply implement a recursive descent parser. For simplicity's sake, the "
"code\n"
"panics when an expression is syntactically wrong (for example `2-34` or "
"`2+5-`\n"
"are wrong according to the grammar definition)."
msgstr ""
"Simplesmente implementamos um analisador descendente recursivo. Para "
"simplificar, o código\n"
"entra em pânico quando uma expressão está sintaticamente errada (por exemplo "
"`2-34` ou `2+5-`\n"
"estão errados de acordo com a definição gramatical)."

#: src\patterns/behavioural/interpreter.md:53
msgid ""
"```rust\n"
"pub struct Interpreter<'a> {\n"
"    it: std::str::Chars<'a>,\n"
"}\n"
"\n"
"impl<'a> Interpreter<'a> {\n"
"\n"
"    pub fn new(infix: &'a str) -> Self {\n"
"        Self { it: infix.chars() }\n"
"    }\n"
"\n"
"    fn next_char(&mut self) -> Option<char> {\n"
"        self.it.next()\n"
"    }\n"
"\n"
"    pub fn interpret(&mut self, out: &mut String) {\n"
"        self.term(out);\n"
"\n"
"        while let Some(op) = self.next_char() {\n"
"            if op == '+' || op == '-' {\n"
"                self.term(out);\n"
"                out.push(op);\n"
"            } else {\n"
"                panic!(\"Unexpected symbol '{}'\", op);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    fn term(&mut self, out: &mut String) {\n"
"        match self.next_char() {\n"
"            Some(ch) if ch.is_digit(10) => out.push(ch),\n"
"            Some(ch) => panic!(\"Unexpected symbol '{}'\", ch),\n"
"            None => panic!(\"Unexpected end of string\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let mut intr = Interpreter::new(\"2+3\");\n"
"    let mut postfix = String::new();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"23+\");\n"
"\n"
"    intr = Interpreter::new(\"1-2+3-4\");\n"
"    postfix.clear();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"12-3+4-\");\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/interpreter.md:105
#, fuzzy
msgid ""
"There may be a wrong perception that the Interpreter design pattern is about "
"design\n"
"grammars for formal languages and implementation of parsers for these "
"grammars.\n"
"In fact, this pattern is about expressing problem instances in a more "
"specific\n"
"way and implementing functions/classes/structs that solve these problem "
"instances.\n"
"Rust language has `macro_rules!` that allow us to define special syntax and "
"rules\n"
"on how to expand this syntax into source code."
msgstr ""
"Pode haver uma percepção errada de que o padrão de projeto Interpreter é "
"sobre design\n"
"gramáticas para linguagens formais e implementação de parsers para essas "
"gramáticas.\n"
"Na verdade, esse padrão é sobre expressar instâncias de problemas de uma "
"forma mais específica.\n"
"maneira e implementando funções/classes/estruturas que resolvem essas "
"instâncias do problema.\n"
"A linguagem Rust tem `macro_rules!` que nos permite definir sintaxe e regras "
"especiais\n"
"sobre como expandir essa sintaxe no código-fonte."

#: src\patterns/behavioural/interpreter.md:112
#, fuzzy
msgid ""
"In the following example we create a simple `macro_rules!` that computes\n"
"[Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) of `n`\n"
"dimensional vectors. Writing `norm!(x,1,2)` might be easier to express and "
"more\n"
"efficient than packing `x,1,2` into a `Vec` and calling a function "
"computing\n"
"the length."
msgstr ""
"No exemplo a seguir, criamos um `macro_rules!` simples que calcula\n"
"[Comprimento euclidiano](https://en.wikipedia.org/wiki/Euclidean_distance) "
"de `n`\n"
"vetores dimensionais. Escrever `norma!(x,1,2)` pode ser mais fácil de "
"expressar e mais\n"
"eficiente do que empacotar `x,1,2` em um `Vec` e chamar uma função de "
"computação\n"
"O comprimento."

#: src\patterns/behavioural/interpreter.md:118
msgid ""
"```rust\n"
"macro_rules! norm {\n"
"    ($($element:expr),*) => {\n"
"        {\n"
"            let mut n = 0.0;\n"
"            $(\n"
"                n += ($element as f64)*($element as f64);\n"
"            )*\n"
"            n.sqrt()\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -3f64;\n"
"    let y = 4f64;\n"
"\n"
"    assert_eq!(3f64, norm!(x));\n"
"    assert_eq!(5f64, norm!(x, y));\n"
"    assert_eq!(0f64, norm!(0, 0, 0)); \n"
"    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/interpreter.md:144
#, fuzzy
msgid ""
"- [Interpreter pattern](https://en.wikipedia.org/wiki/Interpreter_pattern)\n"
"- [Context free "
"grammar](https://en.wikipedia.org/wiki/Context-free_grammar)\n"
"- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"
msgstr ""
"- [Padrão de intérprete](https://en.wikipedia.org/wiki/Interpreter_pattern)\n"
"- [Gramática livre de "
"contexto](https://en.wikipedia.org/wiki/Context-free_grammar)\n"
"- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"

#: src\patterns/behavioural/newtype.md:1
#, fuzzy
msgid "# Newtype"
msgstr "# Novotipo"

#: src\patterns/behavioural/newtype.md:3
#, fuzzy
msgid ""
"What if in some cases we want a type to behave similar to another type or\n"
"enforce some behaviour at compile time when using only type aliases would\n"
"not be enough?"
msgstr ""
"E se em alguns casos quisermos que um tipo se comporte de maneira semelhante "
"a outro tipo ou\n"
"impor algum comportamento em tempo de compilação ao usar apenas aliases de "
"tipo\n"
"não ser suficiente?"

#: src\patterns/behavioural/newtype.md:7
#, fuzzy
msgid ""
"For example, if we want to create a custom `Display` implementation for "
"`String`\n"
"due to security considerations (e.g. passwords)."
msgstr ""
"Por exemplo, se quisermos criar uma implementação `Display` personalizada "
"para `String`\n"
"devido a considerações de segurança (por exemplo, senhas)."

#: src\patterns/behavioural/newtype.md:10
#, fuzzy
msgid ""
"For such cases we could use the `Newtype` pattern to provide **type "
"safety**\n"
"and **encapsulation**."
msgstr ""
"Para tais casos, poderíamos usar o padrão `Newtype` para fornecer ** "
"segurança de tipo **\n"
"e **encapsulamento**."

#: src\patterns/behavioural/newtype.md:15
#, fuzzy
msgid ""
"Use a tuple struct with a single field to make an opaque wrapper for a "
"type.\n"
"This creates a new type, rather than an alias to a type (`type` items)."
msgstr ""
"Use uma estrutura de tupla com um único campo para criar um wrapper opaco "
"para um tipo.\n"
"Isso cria um novo tipo, em vez de um alias para um tipo (itens `type`)."

#: src\patterns/behavioural/newtype.md:20
msgid ""
"```rust,ignore\n"
"// Some type, not necessarily in the same module or even crate.\n"
"struct Foo {\n"
"    //..\n"
"}\n"
"\n"
"impl Foo {\n"
"    // These functions are not present on Bar.\n"
"    //..\n"
"}\n"
"\n"
"// The newtype.\n"
"pub struct Bar(Foo);\n"
"\n"
"impl Bar {\n"
"    // Constructor.\n"
"    pub fn new(\n"
"        //..\n"
"    ) -> Self {\n"
"\n"
"        //..\n"
"\n"
"    }\n"
"\n"
"    //..\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar::new(...);\n"
"\n"
"    // Foo and Bar are type incompatible, the following do not type check.\n"
"    // let f: Foo = b;\n"
"    // let b: Bar = Foo { ... };\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/newtype.md:58
#, fuzzy
msgid ""
"The primary motivation for newtypes is abstraction. It allows you to share\n"
"implementation details between types while precisely controlling the "
"interface.\n"
"By using a newtype rather than exposing the implementation type as part of "
"an\n"
"API, it allows you to change implementation backwards compatibly."
msgstr ""
"A principal motivação para newtypes é a abstração. Ele permite que você "
"compartilhe\n"
"detalhes de implementação entre tipos enquanto controla com precisão a "
"interface.\n"
"Usando um newtype em vez de expor o tipo de implementação como parte de um\n"
"API, permite que você altere a implementação de forma compatível com versões "
"anteriores."

#: src\patterns/behavioural/newtype.md:63
#, fuzzy
msgid ""
"Newtypes can be used for distinguishing units, e.g., wrapping `f64` to give\n"
"distinguishable `Miles` and `Kilometres`."
msgstr ""
"Newtypes podem ser usados para distinguir unidades, por exemplo, agrupando "
"`f64` para dar\n"
"distinguíveis 'Milhas' e 'Quilômetros'."

#: src\patterns/behavioural/newtype.md:68
#, fuzzy
msgid ""
"The wrapped and wrapper types are not type compatible (as opposed to using\n"
"`type`), so users of the newtype will never 'confuse' the wrapped and "
"wrapper\n"
"types."
msgstr ""
"Os tipos wrapper e wrapper não são compatíveis (ao contrário de usar\n"
"`type`), então os usuários do newtype nunca irão 'confundir' o wrapper e o "
"wrapper\n"
"tipos."

#: src\patterns/behavioural/newtype.md:72
#, fuzzy
msgid "Newtypes are a zero-cost abstraction - there is no runtime overhead."
msgstr ""
"Newtypes são uma abstração de custo zero - não há sobrecarga de tempo de "
"execução."

#: src\patterns/behavioural/newtype.md:74
#, fuzzy
msgid ""
"The privacy system ensures that users cannot access the wrapped type (if "
"the\n"
"field is private, which it is by default)."
msgstr ""
"O sistema de privacidade garante que os usuários não possam acessar o tipo "
"encapsulado (se o\n"
"campo é privado, o que é por padrão)."

#: src\patterns/behavioural/newtype.md:79
#, fuzzy
msgid ""
"The downside of newtypes (especially compared with type aliases), is that "
"there\n"
"is no special language support. This means there can be _a lot_ of "
"boilerplate.\n"
"You need a 'pass through' method for every method you want to expose on the\n"
"wrapped type, and an impl for every trait you want to also be implemented "
"for\n"
"the wrapper type."
msgstr ""
"A desvantagem de newtypes (especialmente em comparação com aliases de tipo) "
"é que há\n"
"não há suporte de idioma especial. Isso significa que pode haver _muito_ "
"clichê.\n"
"Você precisa de um método 'pass through' para cada método que deseja expor "
"no\n"
"tipo embrulhado e um impl para cada característica que você deseja que "
"também seja implementado para\n"
"o tipo de invólucro."

#: src\patterns/behavioural/newtype.md:87
#, fuzzy
msgid ""
"Newtypes are very common in Rust code. Abstraction or representing units are "
"the\n"
"most common uses, but they can be used for other reasons:"
msgstr ""
"Newtypes são muito comuns em código Rust. Unidades de abstração ou "
"representação são as\n"
"usos mais comuns, mas podem ser usados por outros motivos:"

#: src\patterns/behavioural/newtype.md:90
#, fuzzy
msgid ""
"- restricting functionality (reduce the functions exposed or traits "
"implemented),\n"
"- making a type with copy semantics have move semantics,\n"
"- abstraction by providing a more concrete type and thus hiding internal "
"types,\n"
"  e.g.,"
msgstr ""
"- funcionalidade restritiva (reduzir as funções expostas ou características "
"implementadas),\n"
"- fazer um tipo com semântica de cópia tem semântica de movimento,\n"
"- abstração ao fornecer um tipo mais concreto e, assim, ocultar os tipos "
"internos,\n"
"  por exemplo.,"

#: src\patterns/behavioural/newtype.md:95
msgid ""
"```rust,ignore\n"
"pub struct Foo(Bar<T1, T2>);\n"
"```"
msgstr ""

#: src\patterns/behavioural/newtype.md:99
#, fuzzy
msgid ""
"Here, `Bar` might be some public, generic type and `T1` and `T2` are some "
"internal\n"
"types. Users of our module shouldn't know that we implement `Foo` by using a "
"`Bar`,\n"
"but what we're really hiding here is the types `T1` and `T2`, and how they "
"are used\n"
"with `Bar`."
msgstr ""
"Aqui, `Bar` pode ser algum tipo público e genérico e `T1` e `T2` são alguns "
"tipos internos\n"
"tipos. Os usuários do nosso módulo não devem saber que implementamos `Foo` "
"usando um `Bar`,\n"
"mas o que realmente estamos escondendo aqui são os tipos `T1` e `T2`, e como "
"eles são usados\n"
"com 'Barra'."

#: src\patterns/behavioural/newtype.md:106
#, fuzzy
msgid ""
"- [Advanced Types in the "
"book](https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-abstraction)\n"
"- [Newtypes in Haskell](https://wiki.haskell.org/Newtype)\n"
"- [Type "
"aliases](https://doc.rust-lang.org/stable/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases)\n"
"- [derive_more](https://crates.io/crates/derive_more), a crate for deriving "
"many\n"
"  builtin traits on newtypes.\n"
"- [The Newtype Pattern In "
"Rust](https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html)"
msgstr ""
"- [Tipos avançados no "
"livro](https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety "
"-e-abstração)\n"
"- [Novos tipos em Haskell](https://wiki.haskell.org/Newtype)\n"
"- [aliases de "
"tipo](https://doc.rust-lang.org/stable/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases)\n"
"- [derive_more](https://crates.io/crates/derive_more), uma caixa para "
"derivar muitos\n"
"  traços embutidos em novos tipos.\n"
"- [O padrão Newtype em "
"Rust](https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html)"

#: src\patterns/behavioural/RAII.md:1
#, fuzzy
msgid "# RAII with guards"
msgstr "# RAII com guardas"

#: src\patterns/behavioural/RAII.md:5
#, fuzzy
msgid ""
"[RAII][wikipedia] stands for \"Resource Acquisition is Initialisation\" "
"which is a\n"
"terrible name. The essence of the pattern is that resource initialisation is "
"done\n"
"in the constructor of an object and finalisation in the destructor. This "
"pattern\n"
"is extended in Rust by using a RAII object as a guard of some resource and "
"relying\n"
"on the type system to ensure that access is always mediated by the guard "
"object."
msgstr ""
"[RAII][wikipedia] significa \"Resource Acquisition is Initialisation\" que é "
"um\n"
"nome terrível. A essência do padrão é que a inicialização do recurso é "
"feita\n"
"no construtor de um objeto e a finalização no destruidor. Esse padrão\n"
"é estendido em Rust usando um objeto RAII como guarda de algum recurso e "
"contando\n"
"no sistema de tipos para garantir que o acesso seja sempre mediado pelo "
"objeto de guarda."

#: src\patterns/behavioural/RAII.md:13
#, fuzzy
msgid ""
"Mutex guards are the classic example of this pattern from the std library "
"(this\n"
"is a simplified version of the real implementation):"
msgstr ""
"Mutex guards são o exemplo clássico deste padrão da biblioteca std (este\n"
"é uma versão simplificada da implementação real):"

#: src\patterns/behavioural/RAII.md:16
msgid ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"struct Mutex<T> {\n"
"    // We keep a reference to our data: T here.\n"
"    //..\n"
"}\n"
"\n"
"struct MutexGuard<'a, T: 'a> {\n"
"    data: &'a T,\n"
"    //..\n"
"}\n"
"\n"
"// Locking the mutex is explicit.\n"
"impl<T> Mutex<T> {\n"
"    fn lock(&self) -> MutexGuard<T> {\n"
"        // Lock the underlying OS mutex.\n"
"        //..\n"
"\n"
"        // MutexGuard keeps a reference to self\n"
"        MutexGuard {\n"
"            data: self,\n"
"            //..\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Destructor for unlocking the mutex.\n"
"impl<'a, T> Drop for MutexGuard<'a, T> {\n"
"    fn drop(&mut self) {\n"
"        // Unlock the underlying OS mutex.\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"// Implementing Deref means we can treat MutexGuard like a pointer to T.\n"
"impl<'a, T> Deref for MutexGuard<'a, T> {\n"
"    type Target = T;\n"
"\n"
"    fn deref(&self) -> &T {\n"
"        self.data\n"
"    }\n"
"}\n"
"\n"
"fn baz(x: Mutex<Foo>) {\n"
"    let xx = x.lock();\n"
"    xx.foo(); // foo is a method on Foo.\n"
"    // The borrow checker ensures we can't store a reference to the "
"underlying\n"
"    // Foo which will outlive the guard xx.\n"
"\n"
"    // x is unlocked when we exit this function and xx's destructor is "
"executed.\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/RAII.md:74
#, fuzzy
msgid ""
"Where a resource must be finalised after use, RAII can be used to do this\n"
"finalisation. If it is an error to access that resource after finalisation, "
"then\n"
"this pattern can be used to prevent such errors."
msgstr ""
"Onde um recurso deve ser finalizado após o uso, o RAII pode ser usado para "
"fazer isso\n"
"finalização. Se for um erro acessar esse recurso após a finalização, então\n"
"esse padrão pode ser usado para evitar tais erros."

#: src\patterns/behavioural/RAII.md:80
#, fuzzy
msgid ""
"Prevents errors where a resource is not finalised and where a resource is "
"used\n"
"after finalisation."
msgstr ""
"Evita erros onde um recurso não é finalizado e onde um recurso é usado\n"
"após a finalização."

#: src\patterns/behavioural/RAII.md:85
#, fuzzy
msgid ""
"RAII is a useful pattern for ensuring resources are properly deallocated or\n"
"finalised. We can make use of the borrow checker in Rust to statically "
"prevent\n"
"errors stemming from using resources after finalisation takes place."
msgstr ""
"RAII é um padrão útil para garantir que os recursos sejam devidamente "
"desalocados ou\n"
"finalizado. Podemos usar o verificador de empréstimo no Rust para prevenir "
"estaticamente\n"
"erros decorrentes do uso de recursos após a finalização."

#: src\patterns/behavioural/RAII.md:89
#, fuzzy
msgid ""
"The core aim of the borrow checker is to ensure that references to data do "
"not\n"
"outlive that data. The RAII guard pattern works because the guard object\n"
"contains a reference to the underlying resource and only exposes such\n"
"references. Rust ensures that the guard cannot outlive the underlying "
"resource\n"
"and that references to the resource mediated by the guard cannot outlive "
"the\n"
"guard. To see how this works it is helpful to examine the signature of "
"`deref`\n"
"without lifetime elision:"
msgstr ""
"O principal objetivo do verificador de empréstimos é garantir que as "
"referências aos dados não\n"
"sobreviver a esses dados. O padrão de guarda RAII funciona porque o objeto "
"de guarda\n"
"contém uma referência ao recurso subjacente e apenas expõe tal\n"
"referências. A ferrugem garante que o guarda não sobreviva ao recurso "
"subjacente\n"
"e que as referências ao recurso mediado pela guarda não podem sobreviver ao\n"
"guarda. Para ver como isso funciona, é útil examinar a assinatura de "
"`deref`\n"
"sem elisão vitalícia:"

#: src\patterns/behavioural/RAII.md:97
msgid ""
"```rust,ignore\n"
"fn deref<'a>(&'a self) -> &'a T {\n"
"    //..\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/RAII.md:103
#, fuzzy
msgid ""
"The returned reference to the resource has the same lifetime as `self` "
"(`'a`).\n"
"The borrow checker therefore ensures that the lifetime of the reference to "
"`T`\n"
"is shorter than the lifetime of `self`."
msgstr ""
"A referência retornada ao recurso tem o mesmo tempo de vida que `self` "
"(`'a`).\n"
"O verificador de empréstimo, portanto, garante que o tempo de vida da "
"referência a `T`\n"
"é mais curto que o tempo de vida de `self`."

#: src\patterns/behavioural/RAII.md:107
#, fuzzy
msgid ""
"Note that implementing `Deref` is not a core part of this pattern, it only "
"makes\n"
"using the guard object more ergonomic. Implementing a `get` method on the "
"guard\n"
"works just as well."
msgstr ""
"Observe que a implementação de `Deref` não é uma parte essencial desse "
"padrão, apenas torna\n"
"usando o objeto de guarda mais ergonômico. Implementando um método `get` no "
"guarda\n"
"funciona tão bem."

#: src\patterns/behavioural/RAII.md:113
#, fuzzy
msgid "[Finalisation in destructors idiom](../../idioms/dtor-finally.md)"
msgstr "[Finalização no idioma dos destruidores](../../idioms/dtor-finally.md)"

#: src\patterns/behavioural/RAII.md:115
#, fuzzy
msgid ""
"RAII is a common pattern in C++: "
"[cppreference.com](http://en.cppreference.com/w/cpp/language/raii),\n"
"[wikipedia][wikipedia]."
msgstr ""
"RAII é um padrão comum em C++: "
"[cppreference.com](http://en.cppreference.com/w/cpp/language/raii),\n"
"[wikipedia][wikipedia]."

#: src\patterns/behavioural/RAII.md:120
#, fuzzy
msgid ""
"[Style guide "
"entry](https://doc.rust-lang.org/1.0.0/style/ownership/raii.html)\n"
"(currently just a placeholder)."
msgstr ""
"[Entrada do guia de "
"estilo](https://doc.rust-lang.org/1.0.0/style/ownership/raii.html)\n"
"(atualmente apenas um espaço reservado)."

#: src\patterns/behavioural/strategy.md:1
#, fuzzy
msgid "# Strategy (aka Policy)"
msgstr "# Estratégia (também conhecida como Política)"

#: src\patterns/behavioural/strategy.md:5
#, fuzzy
msgid ""
"The [Strategy design "
"pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"is a technique that enables separation of concerns.\n"
"It also allows to decouple software modules through [Dependency "
"Inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle)."
msgstr ""
"O [padrão de design de "
"estratégia](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"é uma técnica que permite a separação de preocupações.\n"
"Também permite desacoplar módulos de software por meio de [Inversão de "
"dependência](https://en.wikipedia.org/wiki/Dependency_inversion_principle)."

#: src\patterns/behavioural/strategy.md:9
#, fuzzy
msgid ""
"The basic idea behind the Strategy pattern is that, given an algorithm "
"solving\n"
"a particular problem, we define only the skeleton of the algorithm at an "
"abstract\n"
"level, and we separate the specific algorithm’s implementation into "
"different parts."
msgstr ""
"A ideia básica por trás do padrão Strategy é que, dado um algoritmo "
"resolvendo\n"
"um problema particular, definimos apenas o esqueleto do algoritmo em um "
"resumo\n"
"nível, e separamos a implementação do algoritmo específico em diferentes "
"partes."

#: src\patterns/behavioural/strategy.md:13
#, fuzzy
msgid ""
"In this way, a client using the algorithm may choose a specific "
"implementation,\n"
"while the general algorithm workflow remains the same. In other words, the "
"abstract\n"
"specification of the class does not depend on the specific implementation of "
"the\n"
"derived class, but specific implementation must adhere to the abstract "
"specification.\n"
"This is why we call it \"Dependency Inversion\"."
msgstr ""
"Desta forma, um cliente usando o algoritmo pode escolher uma implementação "
"específica,\n"
"enquanto o fluxo de trabalho do algoritmo geral permanece o mesmo. Em outras "
"palavras, o resumo\n"
"especificação da classe não depende da implementação específica do\n"
"classe derivada, mas a implementação específica deve aderir à especificação "
"abstrata.\n"
"É por isso que chamamos de \"Inversão de Dependência\"."

#: src\patterns/behavioural/strategy.md:21
#, fuzzy
msgid ""
"Imagine we are working on a project that generates reports every month.\n"
"We need the reports to be generated in different formats (strategies), "
"e.g.,\n"
"in `JSON` or `Plain Text` formats.\n"
"But things vary over time, and we don't know what kind of requirement we may "
"get\n"
"in the future. For example, we may need to generate our report in a "
"completely new\n"
"format, or just modify one of the existing formats."
msgstr ""
"Imagine que estamos trabalhando em um projeto que gera relatórios todos os "
"meses.\n"
"Precisamos que os relatórios sejam gerados em diferentes formatos "
"(estratégias), por exemplo,\n"
"nos formatos `JSON` ou `Texto Simples`.\n"
"Mas as coisas variam ao longo do tempo e não sabemos que tipo de exigência "
"podemos obter\n"
"no futuro. Por exemplo, podemos precisar gerar nosso relatório em um formato "
"completamente novo\n"
"formato, ou apenas modifique um dos formatos existentes."

#: src\patterns/behavioural/strategy.md:30
#, fuzzy
msgid ""
"In this example our invariants (or abstractions) are `Context`, "
"`Formatter`,\n"
"and `Report`, while `Text` and `Json` are our strategy structs. These "
"strategies\n"
"have to implement the `Formatter` trait."
msgstr ""
"Neste exemplo, nossas invariantes (ou abstrações) são `Context`, "
"`Formatter`,\n"
"e `Report`, enquanto `Text` e `Json` são nossas estruturas de estratégia. "
"Essas estratégias\n"
"tem que implementar o trait `Formatter`."

#: src\patterns/behavioural/strategy.md:34
msgid ""
"```rust\n"
"use std::collections::HashMap;\n"
"\n"
"type Data = HashMap<String, u32>;\n"
"\n"
"trait Formatter {\n"
"    fn format(&self, data: &Data, buf: &mut String);\n"
"}\n"
"\n"
"struct Report;\n"
"\n"
"impl Report {\n"
"    // Write should be used but we kept it as String to ignore error "
"handling\n"
"    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
"        // backend operations...\n"
"        let mut data = HashMap::new();\n"
"        data.insert(\"one\".to_string(), 1);\n"
"        data.insert(\"two\".to_string(), 2);\n"
"        // generate report\n"
"        g.format(&data, s);\n"
"    }\n"
"}\n"
"\n"
"struct Text;\n"
"impl Formatter for Text {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        for (k, v) in data {\n"
"            let entry = format!(\"{} {}\\n"
"\", k, v);\n"
"            buf.push_str(&entry);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Json;\n"
"impl Formatter for Json {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        buf.push('[');\n"
"        for (k, v) in data.into_iter() {\n"
"            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
"            buf.push_str(&entry);\n"
"            buf.push(',');\n"
"        }\n"
"        if !data.is_empty() {\n"
"            buf.pop(); // remove extra , at the end\n"
"        }\n"
"        buf.push(']');\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut s = String::from(\"\");\n"
"    Report::generate(Text, &mut s);\n"
"    assert!(s.contains(\"one 1\"));\n"
"    assert!(s.contains(\"two 2\"));\n"
"\n"
"    s.clear(); // reuse the same buffer\n"
"    Report::generate(Json, &mut s);\n"
"    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
"    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/strategy.md:98
#, fuzzy
msgid ""
"The main advantage is separation of concerns. For example, in this case "
"`Report`\n"
"does not know anything about specific implementations of `Json` and `Text`,\n"
"whereas the output implementations does not care about how data is "
"preprocessed,\n"
"stored, and fetched. The only thing they have to know is context and a "
"specific\n"
"trait and method to implement, i.e,`Formatter` and `run`."
msgstr ""
"A principal vantagem é a separação de interesses. Por exemplo, neste caso "
"`Relatório`\n"
"não sabe nada sobre implementações específicas de `Json` e `Text`,\n"
"considerando que as implementações de saída não se preocupam com a forma "
"como os dados são pré-processados,\n"
"armazenado e obtido. A única coisa que eles precisam saber é o contexto e "
"um\n"
"trait e método para implementar, ou seja, `Formatter` e `run`."

#: src\patterns/behavioural/strategy.md:106
#, fuzzy
msgid ""
"For each strategy there must be implemented at least one module, so number "
"of modules\n"
"increases with number of strategies. If there are many strategies to choose "
"from\n"
"then users have to know how strategies differ from one another."
msgstr ""
"Para cada estratégia deve ser implementado pelo menos um módulo, então o "
"número de módulos\n"
"aumenta com o número de estratégias. Se houver muitas estratégias para "
"escolher\n"
"então os usuários precisam saber como as estratégias diferem umas das outras."

#: src\patterns/behavioural/strategy.md:112
#, fuzzy
msgid ""
"In the previous example all strategies are implemented in a single file.\n"
"Ways of providing different strategies includes:"
msgstr ""
"No exemplo anterior todas as estratégias são implementadas em um único "
"arquivo.\n"
"Formas de fornecer diferentes estratégias incluem:"

#: src\patterns/behavioural/strategy.md:115
#, fuzzy
msgid ""
"- All in one file (as shown in this example, similar to being separated as "
"modules)\n"
"- Separated as modules, E.g. `formatter::json` module, `formatter::text` "
"module\n"
"- Use compiler feature flags, E.g. `json` feature, `text` feature\n"
"- Separated as crates, E.g. `json` crate, `text` crate"
msgstr ""
"- Tudo em um arquivo (conforme mostrado neste exemplo, semelhante a ser "
"separado como módulos)\n"
"- Separados como módulos, por ex. módulo `formatter::json`, módulo "
"`formatter::text`\n"
"- Use sinalizadores de recursos do compilador, por exemplo recurso `json`, "
"recurso `texto`\n"
"- Separados como caixotes, por ex. caixa `json`, caixa `text`"

#: src\patterns/behavioural/strategy.md:120
#, fuzzy
msgid ""
"Serde crate is a good example of the `Strategy` pattern in action. Serde "
"allows\n"
"[full customization](https://serde.rs/custom-serialization.html) of the "
"serialization\n"
"behavior by manually implementing `Serialize` and `Deserialize` traits for "
"our\n"
"type. For example, we could easily swap `serde_json` with `serde_cbor` since "
"they\n"
"expose similar methods. Having this makes the helper crate `serde_transcode` "
"much\n"
"more useful and ergonomic."
msgstr ""
"Serde crate é um bom exemplo do padrão `Strategy` em ação. Serde permite\n"
"[customização completa](https://serde.rs/custom-serialization.html) da "
"serialização\n"
"comportamento implementando manualmente as características `Serialize` e "
"`Deserialize` para o nosso\n"
"tipo. Por exemplo, poderíamos facilmente trocar `serde_json` por "
"`serde_cbor` já que eles\n"
"expor métodos semelhantes. Ter isso faz com que o auxiliar crie "
"`serde_transcode` muito\n"
"mais útil e ergonômico."

#: src\patterns/behavioural/strategy.md:127
#, fuzzy
msgid ""
"However, we don't need to use traits in order to design this pattern in Rust."
msgstr ""
"No entanto, não precisamos usar traits para projetar esse padrão no Rust."

#: src\patterns/behavioural/strategy.md:129
#, fuzzy
msgid ""
"The following toy example demonstrates the idea of the Strategy pattern "
"using Rust\n"
"`closures`:"
msgstr ""
"O exemplo de brinquedo a seguir demonstra a ideia do padrão Strategy usando "
"Rust\n"
"`encerramentos`:"

#: src\patterns/behavioural/strategy.md:132
msgid ""
"```rust\n"
"struct Adder;\n"
"impl Adder {\n"
"    pub fn add<F>(x: u8, y: u8, f: F) -> u8\n"
"    where\n"
"        F: Fn(u8, u8) -> u8,\n"
"    {\n"
"        f(x, y)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let arith_adder = |x, y| x + y;\n"
"    let bool_adder = |x, y| {\n"
"        if x == 1 || y == 1 {\n"
"            1\n"
"        } else {\n"
"            0\n"
"        }\n"
"    };\n"
"    let custom_adder = |x, y| 2 * x + y;\n"
"\n"
"    assert_eq!(9, Adder::add(4, 5, arith_adder));\n"
"    assert_eq!(0, Adder::add(0, 0, bool_adder));\n"
"    assert_eq!(5, Adder::add(1, 3, custom_adder));\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/strategy.md:160
#, fuzzy
msgid "In fact, Rust already uses this idea for `Options`'s `map` method:"
msgstr "Na verdade, Rust já usa essa ideia para o método `map` de `Options`:"

#: src\patterns/behavioural/strategy.md:162
msgid ""
"```rust\n"
"fn main() {\n"
"    let val = Some(\"Rust\");\n"
"\n"
"    let len_strategy = |s: &str| s.len();\n"
"    assert_eq!(4, val.map(len_strategy).unwrap());\n"
"\n"
"    let first_byte_strategy = |s: &str| s.bytes().next().unwrap();\n"
"    assert_eq!(82, val.map(first_byte_strategy).unwrap());\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/strategy.md:176
#, fuzzy
msgid ""
"- [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"- [Dependency "
"Injection](https://en.wikipedia.org/wiki/Dependency_injection)\n"
"- [Policy Based "
"Design](https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-based_design)"
msgstr ""
"- [Padrão de Estratégia](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"- [Injeção de "
"dependência](https://en.wikipedia.org/wiki/Dependency_injection)\n"
"- [Design baseado em "
"políticas](https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-based_design)"

#: src\patterns/behavioural/visitor.md:1
#, fuzzy
msgid "# Visitor"
msgstr "# Visitante"

#: src\patterns/behavioural/visitor.md:5
#, fuzzy
msgid ""
"A visitor encapsulates an algorithm that operates over a heterogeneous\n"
"collection of objects. It allows multiple different algorithms to be "
"written\n"
"over the same data without having to modify the data (or their primary\n"
"behaviour)."
msgstr ""
"Um visitante encapsula um algoritmo que opera em uma rede heterogênea\n"
"coleção de objetos. Ele permite que vários algoritmos diferentes sejam "
"escritos\n"
"sobre os mesmos dados sem ter que modificar os dados (ou seus principais\n"
"comportamento)."

#: src\patterns/behavioural/visitor.md:10
#, fuzzy
msgid ""
"Furthermore, the visitor pattern allows separating the traversal of\n"
"a collection of objects from the operations performed on each object."
msgstr ""
"Além disso, o padrão do visitante permite separar a travessia de\n"
"uma coleção de objetos das operações executadas em cada objeto."

#: src\patterns/behavioural/visitor.md:15
msgid ""
"```rust,ignore\n"
"// The data we will visit\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Expr),\n"
"        Let(Name, Expr),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// The abstract visitor\n"
"mod visit {\n"
"    use ast::*;\n"
"\n"
"    pub trait Visitor<T> {\n"
"        fn visit_name(&mut self, n: &Name) -> T;\n"
"        fn visit_stmt(&mut self, s: &Stmt) -> T;\n"
"        fn visit_expr(&mut self, e: &Expr) -> T;\n"
"    }\n"
"}\n"
"\n"
"use visit::*;\n"
"use ast::*;\n"
"\n"
"// An example concrete implementation - walks the AST interpreting it as "
"code.\n"
"struct Interpreter;\n"
"impl Visitor<i64> for Interpreter {\n"
"    fn visit_name(&mut self, n: &Name) -> i64 { panic!() }\n"
"    fn visit_stmt(&mut self, s: &Stmt) -> i64 {\n"
"        match *s {\n"
"            Stmt::Expr(ref e) => self.visit_expr(e),\n"
"            Stmt::Let(..) => unimplemented!(),\n"
"        }\n"
"    }\n"
"\n"
"    fn visit_expr(&mut self, e: &Expr) -> i64 {\n"
"        match *e {\n"
"            Expr::IntLit(n) => n,\n"
"            Expr::Add(ref lhs, ref rhs) => self.visit_expr(lhs) + "
"self.visit_expr(rhs),\n"
"            Expr::Sub(ref lhs, ref rhs) => self.visit_expr(lhs) - "
"self.visit_expr(rhs),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/visitor.md:69
#, fuzzy
msgid ""
"One could implement further visitors, for example a type checker, without "
"having\n"
"to modify the AST data."
msgstr ""
"Pode-se implementar mais visitantes, por exemplo, um verificador de tipo, "
"sem ter\n"
"para modificar os dados AST."

#: src\patterns/behavioural/visitor.md:74
#, fuzzy
msgid ""
"The visitor pattern is useful anywhere that you want to apply an algorithm "
"to\n"
"heterogeneous data. If data is homogeneous, you can use an iterator-like "
"pattern.\n"
"Using a visitor object (rather than a functional approach) allows the "
"visitor to\n"
"be stateful and thus communicate information between nodes."
msgstr ""
"O padrão do visitante é útil em qualquer lugar que você deseja aplicar um "
"algoritmo para\n"
"dados heterogêneos. Se os dados forem homogêneos, você pode usar um padrão "
"do tipo iterador.\n"
"O uso de um objeto de visitante (em vez de uma abordagem funcional) permite "
"que o visitante\n"
"ser stateful e, assim, comunicar informações entre os nós."

#: src\patterns/behavioural/visitor.md:81
#, fuzzy
msgid ""
"It is common for the `visit_*` methods to return void (as opposed to in the\n"
"example). In that case it is possible to factor out the traversal code and "
"share\n"
"it between algorithms (and also to provide noop default methods). In Rust, "
"the\n"
"common way to do this is to provide `walk_*` functions for each datum. For\n"
"example,"
msgstr ""
"É comum que os métodos `visit_*` retornem void (em oposição ao método\n"
"exemplo). Nesse caso, é possível fatorar o código de travessia e "
"compartilhar\n"
"entre algoritmos (e também para fornecer métodos padrão noop). Em Ferrugem, "
"o\n"
"A maneira comum de fazer isso é fornecer funções `walk_*` para cada dado. "
"Para\n"
"exemplo,"

#: src\patterns/behavioural/visitor.md:87
msgid ""
"```rust,ignore\n"
"pub fn walk_expr(visitor: &mut Visitor, e: &Expr) {\n"
"    match *e {\n"
"        Expr::IntLit(_) => {},\n"
"        Expr::Add(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"        Expr::Sub(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\patterns/behavioural/visitor.md:103
#, fuzzy
msgid ""
"In other languages (e.g., Java) it is common for data to have an `accept` "
"method\n"
"which performs the same duty."
msgstr ""
"Em outras linguagens (por exemplo, Java) é comum que os dados tenham um "
"método `accept`\n"
"que cumpre a mesma função."

#: src\patterns/behavioural/visitor.md:108
#, fuzzy
msgid "The visitor pattern is a common pattern in most OO languages."
msgstr ""
"O padrão de visitante é um padrão comum na maioria das linguagens orientadas "
"a objetos."

#: src\patterns/behavioural/visitor.md:110
#, fuzzy
msgid "[Wikipedia article](https://en.wikipedia.org/wiki/Visitor_pattern)"
msgstr "[Artigo da Wikipédia](https://en.wikipedia.org/wiki/Visitor_pattern)"

#: src\patterns/behavioural/visitor.md:112
#, fuzzy
msgid ""
"The [fold](../creational/fold.md) pattern is similar to visitor but "
"produces\n"
"a new version of the visited data structure."
msgstr ""
"O padrão [fold](../creational/fold.md) é semelhante ao do visitante, mas "
"produz\n"
"uma nova versão da estrutura de dados visitada."

#: src\patterns/creational/intro.md:1
#, fuzzy
msgid "# Creational Patterns"
msgstr "# Padrões Criacionais"

#: src\patterns/creational/intro.md:3
#, fuzzy
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern):"
msgstr "Da [Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern):"

#: src\patterns/creational/intro.md:5
#, fuzzy
msgid ""
"> Design patterns that deal with object creation mechanisms, trying to "
"create objects\n"
"> in a manner suitable to the situation. The basic form of object creation "
"could\n"
"> result in design problems or in added complexity to the design. Creational "
"design\n"
"> patterns solve this problem by somehow controlling this object creation."
msgstr ""
"> Padrões de design que lidam com mecanismos de criação de objetos, tentando "
"criar objetos\n"
"> de forma adequada à situação. A forma básica de criação de objetos "
"poderia\n"
"> resultar em problemas de projeto ou em complexidade adicional ao projeto. "
"design criacional\n"
"> os padrões resolvem esse problema controlando de alguma forma a criação "
"desse objeto."

#: src\patterns/creational/builder.md:1
#, fuzzy
msgid "# Builder"
msgstr "# Construtor"

#: src\patterns/creational/builder.md:5
#, fuzzy
msgid "Construct an object with calls to a builder helper."
msgstr "Construa um objeto com chamadas para um auxiliar de construtor."

#: src\patterns/creational/builder.md:9
msgid ""
"```rust\n"
"#[derive(Debug, PartialEq)]\n"
"pub struct Foo {\n"
"    // Lots of complicated fields.\n"
"    bar: String,\n"
"}\n"
"\n"
"impl Foo {\n"
"    // This method will help users to discover the builder\n"
"    pub fn builder() -> FooBuilder {\n"
"        FooBuilder::default()\n"
"    }\n"
"}\n"
"\n"
"#[derive(Default)]\n"
"pub struct FooBuilder {\n"
"    // Probably lots of optional fields.\n"
"    bar: String,\n"
"}\n"
"\n"
"impl FooBuilder {\n"
"    pub fn new(/* ... */) -> FooBuilder {\n"
"        // Set the minimally required fields of Foo.\n"
"        FooBuilder {\n"
"            bar: String::from(\"X\"),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(mut self, bar: String) -> FooBuilder {\n"
"        // Set the name on the builder itself, and return the builder by "
"value.\n"
"        self.bar = bar;\n"
"        self\n"
"    }\n"
"\n"
"    // If we can get away with not consuming the Builder here, that is an\n"
"    // advantage. It means we can use the FooBuilder as a template for "
"constructing\n"
"    // many Foos.\n"
"    pub fn build(self) -> Foo {\n"
"        // Create a Foo from the FooBuilder, applying all settings in "
"FooBuilder\n"
"        // to Foo.\n"
"        Foo { bar: self.bar }\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn builder_test() {\n"
"    let foo = Foo {\n"
"        bar: String::from(\"Y\"),\n"
"    };\n"
"    let foo_from_builder: Foo = "
"FooBuilder::new().name(String::from(\"Y\")).build();\n"
"    assert_eq!(foo, foo_from_builder);\n"
"}\n"
"```"
msgstr ""

#: src\patterns/creational/builder.md:65
#, fuzzy
msgid ""
"Useful when you would otherwise require many constructors or where\n"
"construction has side effects."
msgstr ""
"Útil quando você precisaria de muitos construtores ou onde\n"
"construção tem efeitos colaterais."

#: src\patterns/creational/builder.md:70
#, fuzzy
msgid "Separates methods for building from other methods."
msgstr "Separa métodos para construção de outros métodos."

#: src\patterns/creational/builder.md:72
#, fuzzy
msgid "Prevents proliferation of constructors."
msgstr "Previne a proliferação de construtores."

#: src\patterns/creational/builder.md:74
#, fuzzy
msgid ""
"Can be used for one-liner initialisation as well as more complex "
"construction."
msgstr ""
"Pode ser usado para inicialização de uma linha, bem como construções mais "
"complexas."

#: src\patterns/creational/builder.md:78
#, fuzzy
msgid ""
"More complex than creating a struct object directly, or a simple "
"constructor\n"
"function."
msgstr ""
"Mais complexo do que criar um objeto struct diretamente ou um construtor "
"simples\n"
"função."

#: src\patterns/creational/builder.md:83
#, fuzzy
msgid ""
"This pattern is seen more frequently in Rust (and for simpler objects) than "
"in\n"
"many other languages because Rust lacks overloading. Since you can only have "
"a\n"
"single method with a given name, having multiple constructors is less nice "
"in\n"
"Rust than in C++, Java, or others."
msgstr ""
"Esse padrão é visto com mais frequência em Rust (e para objetos mais "
"simples) do que em\n"
"muitas outras linguagens porque Rust não tem sobrecarga. Como você só pode "
"ter um\n"
"método único com um determinado nome, ter vários construtores é menos "
"agradável em\n"
"Rust do que em C++, Java ou outros."

#: src\patterns/creational/builder.md:88
#, fuzzy
msgid ""
"This pattern is often used where the builder object is useful in its own "
"right,\n"
"rather than being just a builder. For example, see\n"
"[`std::process::Command`](https://doc.rust-lang.org/std/process/struct.Command.html)\n"
"is a builder for "
"[`Child`](https://doc.rust-lang.org/std/process/struct.Child.html)\n"
"(a process). In these cases, the `T` and `TBuilder` naming pattern is not "
"used."
msgstr ""
"Esse padrão é frequentemente usado onde o objeto construtor é útil por si "
"só,\n"
"em vez de ser apenas um construtor. Por exemplo, veja\n"
"[`std::process::Command`](https://doc.rust-lang.org/std/process/struct.Command.html)\n"
"é um construtor para "
"[`Child`](https://doc.rust-lang.org/std/process/struct.Child.html)\n"
"(um processo). Nesses casos, o padrão de nomenclatura `T` e `TBuilder` não é "
"usado."

#: src\patterns/creational/builder.md:94
#, fuzzy
msgid ""
"The example takes and returns the builder by value. It is often more "
"ergonomic\n"
"(and more efficient) to take and return the builder as a mutable reference. "
"The\n"
"borrow checker makes this work naturally. This approach has the advantage "
"that\n"
"one can write code like"
msgstr ""
"O exemplo pega e retorna o construtor por valor. Muitas vezes é mais "
"ergonômico\n"
"(e mais eficiente) para obter e retornar o construtor como uma referência "
"mutável. O\n"
"o verificador de empréstimo faz isso funcionar naturalmente. Esta abordagem "
"tem a vantagem de\n"
"pode-se escrever código como"

#: src\patterns/creational/builder.md:99
msgid ""
"```rust,ignore\n"
"let mut fb = FooBuilder::new();\n"
"fb.a();\n"
"fb.b();\n"
"let f = fb.build();\n"
"```"
msgstr ""

#: src\patterns/creational/builder.md:106
#, fuzzy
msgid "as well as the `FooBuilder::new().a().b().build()` style."
msgstr "assim como o estilo `FooBuilder::new().a().b().build()`."

#: src\patterns/creational/builder.md:110
#, fuzzy
msgid ""
"- [Description in the style "
"guide](https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html)\n"
"- [derive_builder](https://crates.io/crates/derive_builder), a crate for "
"automatically\n"
"  implementing this pattern while avoiding the boilerplate.\n"
"- [Constructor pattern](../../idioms/ctor.md) for when construction is "
"simpler.\n"
"- [Builder pattern "
"(wikipedia)](https://en.wikipedia.org/wiki/Builder_pattern)\n"
"- [Construction of complex "
"values](https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder)"
msgstr ""
"- [Descrição no guia de "
"estilo](https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html)\n"
"- [derive_builder](https://crates.io/crates/derive_builder), uma caixa para "
"automaticamente\n"
"  implementando esse padrão enquanto evita o clichê.\n"
"- [Padrão construtor](../../idioms/ctor.md) para quando a construção é mais "
"simples.\n"
"- [Padrão do construtor "
"(wikipedia)](https://en.wikipedia.org/wiki/Builder_pattern)\n"
"- [Construção de valores "
"complexos](https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder)"

#: src\patterns/creational/fold.md:1
#, fuzzy
msgid "# Fold"
msgstr "# Dobrar"

#: src\patterns/creational/fold.md:5
#, fuzzy
msgid ""
"Run an algorithm over each item in a collection of data to create a new "
"item,\n"
"thus creating a whole new collection."
msgstr ""
"Execute um algoritmo sobre cada item em uma coleção de dados para criar um "
"novo item,\n"
"criando assim uma coleção totalmente nova."

#: src\patterns/creational/fold.md:8
#, fuzzy
msgid ""
"The etymology here is unclear to me. The terms 'fold' and 'folder' are used\n"
"in the Rust compiler, although it appears to me to be more like a map than "
"a\n"
"fold in the usual sense. See the discussion below for more details."
msgstr ""
"A etimologia aqui não é clara para mim. Os termos 'dobrar' e 'pasta' são "
"usados\n"
"no compilador Rust, embora me pareça mais um mapa do que um\n"
"dobrar no sentido usual. Veja a discussão abaixo para mais detalhes."

#: src\patterns/creational/fold.md:14
msgid ""
"```rust,ignore\n"
"// The data we will fold, a simple AST.\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Box<Expr>),\n"
"        Let(Box<Name>, Box<Expr>),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// The abstract folder\n"
"mod fold {\n"
"    use ast::*;\n"
"\n"
"    pub trait Folder {\n"
"        // A leaf node just returns the node itself. In some cases, we can "
"do this\n"
"        // to inner nodes too.\n"
"        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
"        // Create a new inner node by folding its children.\n"
"        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
"            match *s {\n"
"                Stmt::Expr(e) => Box::new(Stmt::Expr(self.fold_expr(e))),\n"
"                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
"self.fold_expr(e))),\n"
"            }\n"
"        }\n"
"        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
"    }\n"
"}\n"
"\n"
"use fold::*;\n"
"use ast::*;\n"
"\n"
"// An example concrete implementation - renames every name to 'foo'.\n"
"struct Renamer;\n"
"impl Folder for Renamer {\n"
"    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
"        Box::new(Name { value: \"foo\".to_owned() })\n"
"    }\n"
"    // Use the default methods for the other nodes.\n"
"}\n"
"```"
msgstr ""

#: src\patterns/creational/fold.md:65
#, fuzzy
msgid ""
"The result of running the `Renamer` on an AST is a new AST identical to the "
"old\n"
"one, but with every name changed to `foo`. A real life folder might have "
"some\n"
"state preserved between nodes in the struct itself."
msgstr ""
"O resultado da execução do `Renamer` em um AST é um novo AST idêntico ao "
"antigo\n"
"um, mas com todos os nomes alterados para `foo`. Uma pasta da vida real pode "
"ter alguns\n"
"estado preservado entre nós na própria estrutura."

#: src\patterns/creational/fold.md:69
#, fuzzy
msgid ""
"A folder can also be defined to map one data structure to a different (but\n"
"usually similar) data structure. For example, we could fold an AST into a "
"HIR\n"
"tree (HIR stands for high-level intermediate representation)."
msgstr ""
"Uma pasta também pode ser definida para mapear uma estrutura de dados para "
"outra (mas\n"
"geralmente semelhante) estrutura de dados. Por exemplo, poderíamos dobrar um "
"AST em um HIR\n"
"árvore (HIR significa representação intermediária de alto nível)."

#: src\patterns/creational/fold.md:75
#, fuzzy
msgid ""
"It is common to want to map a data structure by performing some operation "
"on\n"
"each node in the structure. For simple operations on simple data "
"structures,\n"
"this can be done using `Iterator::map`. For more complex operations, "
"perhaps\n"
"where earlier nodes can affect the operation on later nodes, or where "
"iteration\n"
"over the data structure is non-trivial, using the fold pattern is more\n"
"appropriate."
msgstr ""
"É comum querer mapear uma estrutura de dados realizando alguma operação em\n"
"cada nó da estrutura. Para operações simples em estruturas de dados "
"simples,\n"
"isso pode ser feito usando `Iterator::map`. Para operações mais complexas, "
"talvez\n"
"onde nós anteriores podem afetar a operação em nós posteriores, ou onde a "
"iteração\n"
"sobre a estrutura de dados não é trivial, usar o padrão de dobra é mais\n"
"apropriado."

#: src\patterns/creational/fold.md:82
#, fuzzy
msgid ""
"Like the visitor pattern, the fold pattern allows us to separate traversal "
"of a\n"
"data structure from the operations performed to each node."
msgstr ""
"Assim como o padrão Visitor, o padrão Fold nos permite separar a travessia "
"de um\n"
"estrutura de dados das operações realizadas para cada nó."

#: src\patterns/creational/fold.md:87
#, fuzzy
msgid ""
"Mapping data structures in this fashion is common in functional languages. "
"In OO\n"
"languages, it would be more common to mutate the data structure in place. "
"The\n"
"'functional' approach is common in Rust, mostly due to the preference for\n"
"immutability. Using fresh data structures, rather than mutating old ones, "
"makes\n"
"reasoning about the code easier in most circumstances."
msgstr ""
"Mapear estruturas de dados dessa maneira é comum em linguagens funcionais. "
"Eu não\n"
"idiomas, seria mais comum alterar a estrutura de dados no local. O\n"
"abordagem 'funcional' é comum em Rust, principalmente devido à preferência "
"por\n"
"imutabilidade. Usar novas estruturas de dados, em vez de modificar "
"estruturas antigas, torna\n"
"Raciocinar sobre o código é mais fácil na maioria das circunstâncias."

#: src\patterns/creational/fold.md:93
#, fuzzy
msgid ""
"The trade-off between efficiency and reusability can be tweaked by changing "
"how\n"
"nodes are accepted by the `fold_*` methods."
msgstr ""
"A compensação entre eficiência e reutilização pode ser ajustada alterando a "
"forma como\n"
"nós são aceitos pelos métodos `fold_*`."

#: src\patterns/creational/fold.md:96
#, fuzzy
msgid ""
"In the above example we operate on `Box` pointers. Since these own their "
"data\n"
"exclusively, the original copy of the data structure cannot be re-used. On "
"the\n"
"other hand if a node is not changed, reusing it is very efficient."
msgstr ""
"No exemplo acima, operamos em ponteiros `Box`. Uma vez que estes possuem "
"seus dados\n"
"exclusivamente, a cópia original da estrutura de dados não pode ser "
"reutilizada. No\n"
"por outro lado, se um nó não for alterado, reutilizá-lo é muito eficiente."

#: src\patterns/creational/fold.md:100
msgid ""
"If we were to operate on borrowed references, the original data structure "
"can be\n"
"reused; however, a node must be cloned even if unchanged, which can be\n"
"expensive."
msgstr ""

#: src\patterns/creational/fold.md:104
#, fuzzy
msgid ""
"Using a reference counted pointer gives the best of both worlds - we can "
"reuse\n"
"the original data structure, and we don't need to clone unchanged nodes. "
"However,\n"
"they are less ergonomic to use and mean that the data structures cannot be\n"
"mutable."
msgstr ""
"Usar um ponteiro de contagem de referência oferece o melhor dos dois mundos "
"- podemos reutilizar\n"
"a estrutura de dados original e não precisamos clonar nós inalterados. No "
"entanto,\n"
"eles são menos ergonômicos de usar e significam que as estruturas de dados "
"não podem ser\n"
"mutável."

#: src\patterns/creational/fold.md:111
#, fuzzy
msgid ""
"Iterators have a `fold` method, however this folds a data structure into a\n"
"value, rather than into a new data structure. An iterator's `map` is more "
"like\n"
"this fold pattern."
msgstr ""
"Os iteradores têm um método `fold`, no entanto, isso dobra uma estrutura de "
"dados em um\n"
"valor, em vez de em uma nova estrutura de dados. O `map` de um iterador é "
"mais parecido com\n"
"este padrão de dobra."

#: src\patterns/creational/fold.md:115
#, fuzzy
msgid ""
"In other languages, fold is usually used in the sense of Rust's iterators,\n"
"rather than this pattern. Some functional languages have powerful constructs "
"for\n"
"performing flexible maps over data structures."
msgstr ""
"Em outras linguagens, fold é geralmente usado no sentido dos iteradores do "
"Rust,\n"
"em vez deste padrão. Algumas linguagens funcionais têm construções poderosas "
"para\n"
"realizando mapas flexíveis sobre estruturas de dados."

#: src\patterns/creational/fold.md:119
#, fuzzy
msgid ""
"The [visitor](../behavioural/visitor.md) pattern is closely related to "
"fold.\n"
"They share the concept of walking a data structure performing an operation "
"on\n"
"each node. However, the visitor does not create a new data structure nor "
"consume\n"
"the old one."
msgstr ""
"O padrão [visitor](../behavioural/visitor.md) está intimamente relacionado à "
"dobra.\n"
"Eles compartilham o conceito de percorrer uma estrutura de dados realizando "
"uma operação em\n"
"cada nó. No entanto, o visitante não cria uma nova estrutura de dados nem "
"consome\n"
"o antigo."

#: src\patterns/structural/intro.md:1
#, fuzzy
msgid "# Structural Patterns"
msgstr "# Padrões Estruturais"

#: src\patterns/structural/intro.md:3
#, fuzzy
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern):"
msgstr "Da [Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern):"

#: src\patterns/structural/intro.md:5
#, fuzzy
msgid ""
"> Design patterns that ease the design by identifying a simple way to "
"realize relationships\n"
"> among entities."
msgstr ""
"> Padrões de design que facilitam o design identificando uma maneira simples "
"de realizar relacionamentos\n"
"> entre entidades."

#: src\patterns/structural/compose-structs.md:1
#, fuzzy
msgid "# Compose structs together for better borrowing"
msgstr "# Compor estruturas juntas para melhor empréstimo"

#: src\patterns/structural/compose-structs.md:3
#, fuzzy
msgid "TODO - this is not a very snappy name"
msgstr "TODO - este não é um nome muito rápido"

#: src\patterns/structural/compose-structs.md:7
#, fuzzy
msgid ""
"Sometimes a large struct will cause issues with the borrow checker - "
"although\n"
"fields can be borrowed independently, sometimes the whole struct ends up "
"being\n"
"used at once, preventing other uses. A solution might be to decompose the "
"struct\n"
"into several smaller structs. Then compose these together into the original\n"
"struct. Then each struct can be borrowed separately and have more flexible\n"
"behaviour."
msgstr ""
"Às vezes, uma estrutura grande causará problemas com o verificador de "
"empréstimo - embora\n"
"campos podem ser emprestados de forma independente, às vezes toda a "
"estrutura acaba sendo\n"
"usados de uma só vez, impedindo outros usos. Uma solução pode ser decompor a "
"estrutura\n"
"em várias estruturas menores. Em seguida, componha-os juntos no original\n"
"struct. Em seguida, cada struct pode ser emprestado separadamente e ter mais "
"flexibilidade\n"
"comportamento."

#: src\patterns/structural/compose-structs.md:14
#, fuzzy
msgid ""
"This will often lead to a better design in other ways: applying this design\n"
"pattern often reveals smaller units of functionality."
msgstr ""
"Isso geralmente leva a um design melhor de outras maneiras: aplicando esse "
"design\n"
"padrão geralmente revela unidades menores de funcionalidade."

#: src\patterns/structural/compose-structs.md:19
#, fuzzy
msgid ""
"Here is a contrived example of where the borrow checker foils us in our plan "
"to\n"
"use a struct:"
msgstr ""
"Aqui está um exemplo forjado de onde o verificador de empréstimos nos "
"frustra em nosso plano de\n"
"use uma estrutura:"

#: src\patterns/structural/compose-structs.md:22
msgid ""
"```rust\n"
"struct A {\n"
"    f1: u32,\n"
"    f2: u32,\n"
"    f3: u32,\n"
"}\n"
"\n"
"fn foo(a: &mut A) -> &u32 { &a.f2 }\n"
"fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }\n"
"\n"
"fn baz(a: &mut A) {\n"
"    // The later usage of x causes a to be borrowed for the rest of the "
"function.\n"
"    let x = foo(a);\n"
"    // Borrow checker error:\n"
"    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more than "
"once\n"
"                       //          at a time\n"
"    println!(\"{}\", x);\n"
"}\n"
"```"
msgstr ""

#: src\patterns/structural/compose-structs.md:42
#, fuzzy
msgid ""
"We can apply this design pattern and refactor `A` into two smaller structs, "
"thus\n"
"solving the borrow checking issue:"
msgstr ""
"Podemos aplicar esse padrão de design e refatorar `A` em duas estruturas "
"menores, assim\n"
"resolvendo o problema de verificação de empréstimo:"

#: src\patterns/structural/compose-structs.md:45
msgid ""
"```rust\n"
"// A is now composed of two structs - B and C.\n"
"struct A {\n"
"    b: B,\n"
"    c: C,\n"
"}\n"
"struct B {\n"
"    f2: u32,\n"
"}\n"
"struct C {\n"
"    f1: u32,\n"
"    f3: u32,\n"
"}\n"
"\n"
"// These functions take a B or C, rather than A.\n"
"fn foo(b: &mut B) -> &u32 { &b.f2 }\n"
"fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }\n"
"\n"
"fn baz(a: &mut A) {\n"
"    let x = foo(&mut a.b);\n"
"    // Now it's OK!\n"
"    let y = bar(&mut a.c);\n"
"    println!(\"{}\", x);\n"
"}\n"
"```"
msgstr ""

#: src\patterns/structural/compose-structs.md:73
#, fuzzy
msgid "TODO Why and where you should use the pattern"
msgstr "TODO Por que e onde você deve usar o padrão"

#: src\patterns/structural/compose-structs.md:77
#, fuzzy
msgid "Lets you work around limitations in the borrow checker."
msgstr "Permite contornar as limitações no verificador de empréstimos."

#: src\patterns/structural/compose-structs.md:79
#, fuzzy
msgid "Often produces a better design."
msgstr "Muitas vezes produz um design melhor."

#: src\patterns/structural/compose-structs.md:83
#, fuzzy
msgid "Leads to more verbose code."
msgstr "Leva a um código mais detalhado."

#: src\patterns/structural/compose-structs.md:85
#, fuzzy
msgid ""
"Sometimes, the smaller structs are not good abstractions, and so we end up "
"with\n"
"a worse design. That is probably a 'code smell', indicating that the "
"program\n"
"should be refactored in some way."
msgstr ""
"Às vezes, as estruturas menores não são boas abstrações e, portanto, "
"acabamos com\n"
"um projeto pior. Isso é provavelmente um 'cheiro de código', indicando que o "
"programa\n"
"deve ser refatorado de alguma forma."

#: src\patterns/structural/compose-structs.md:91
#, fuzzy
msgid ""
"This pattern is not required in languages that don't have a borrow checker, "
"so\n"
"in that sense is unique to Rust. However, making smaller units of "
"functionality\n"
"often leads to cleaner code: a widely acknowledged principle of software\n"
"engineering, independent of the language."
msgstr ""
"Esse padrão não é necessário em idiomas que não possuem um verificador de "
"empréstimo, então\n"
"nesse sentido, é exclusivo do Rust. No entanto, fazer unidades menores de "
"funcionalidade\n"
"muitas vezes leva a um código mais limpo: um princípio de software "
"amplamente reconhecido\n"
"engenharia, independente do idioma."

#: src\patterns/structural/compose-structs.md:96
#, fuzzy
msgid ""
"This pattern relies on Rust's borrow checker to be able to borrow fields\n"
"independently of each other. In the example, the borrow checker knows that "
"`a.b`\n"
"and `a.c` are distinct and can be borrowed independently, it does not try "
"to\n"
"borrow all of `a`, which would make this pattern useless."
msgstr ""
"Esse padrão depende do verificador de empréstimo do Rust para poder "
"emprestar campos\n"
"independentemente um do outro. No exemplo, o verificador de empréstimo sabe "
"que `a.b`\n"
"e `a.c` são distintos e podem ser emprestados independentemente, ele não "
"tenta\n"
"pegue emprestado todo `a`, o que tornaria esse padrão inútil."

#: src\patterns/structural/small-crates.md:1
#, fuzzy
msgid "# Prefer small crates"
msgstr "# Prefira caixotes pequenos"

#: src\patterns/structural/small-crates.md:5
#, fuzzy
msgid "Prefer small crates that do one thing well."
msgstr "Prefira caixas pequenas que façam uma coisa bem."

#: src\patterns/structural/small-crates.md:7
#, fuzzy
msgid ""
"Cargo and crates.io make it easy to add third-party libraries, much more so "
"than\n"
"in say C or C++. Moreover, since packages on crates.io cannot be edited or "
"removed\n"
"after publication, any build that works now should continue to work in the "
"future.\n"
"We should take advantage of this tooling, and use smaller, more fine-grained "
"dependencies."
msgstr ""
"Cargo e crates.io facilitam a adição de bibliotecas de terceiros, muito mais "
"do que\n"
"digamos em C ou C++. Além disso, como os pacotes no crates.io não podem ser "
"editados ou removidos\n"
"após a publicação, qualquer compilação que funcione agora deve continuar "
"funcionando no futuro.\n"
"Devemos aproveitar essas ferramentas e usar dependências menores e mais "
"refinadas."

#: src\patterns/structural/small-crates.md:14
#, fuzzy
msgid ""
"- Small crates are easier to understand, and encourage more modular code.\n"
"- Crates allow for re-using code between projects.\n"
"  For example, the `url` crate was developed as part of the Servo browser "
"engine,\n"
"  but has since found wide use outside the project.\n"
"- Since the compilation unit\n"
"  of Rust is the crate, splitting a project into multiple crates can allow "
"more of\n"
"  the code to be built in parallel."
msgstr ""
"- Caixas pequenas são mais fáceis de entender e incentivam um código mais "
"modular.\n"
"- As caixas permitem a reutilização de código entre projetos.\n"
"  Por exemplo, a caixa `url` foi desenvolvida como parte do mecanismo do "
"navegador Servo,\n"
"  mas desde então encontrou amplo uso fora do projeto.\n"
"- Desde a unidade de compilação\n"
"  de Rust é a caixa, dividir um projeto em várias caixas pode permitir mais\n"
"  o código a ser construído em paralelo."

#: src\patterns/structural/small-crates.md:24
#, fuzzy
msgid ""
"- This can lead to \"dependency hell\", when a project depends on multiple "
"conflicting\n"
"  versions of a crate at the same time. For example, the `url` crate has "
"both versions\n"
"  1.0 and 0.5. Since the `Url` from `url:1.0` and the `Url` from `url:0.5` "
"are\n"
"  different types, an HTTP client that uses `url:0.5` would not accept `Url` "
"values\n"
"  from a web scraper that uses `url:1.0`.\n"
"- Packages on crates.io are not curated. A crate may be poorly written, "
"have\n"
"  unhelpful documentation, or be outright malicious.\n"
"- Two small crates may be less optimized than one large one, since the "
"compiler\n"
"  does not perform link-time optimization (LTO) by default."
msgstr ""
"- Isso pode levar ao \"inferno da dependência\", quando um projeto depende "
"de vários\n"
"  versões de uma caixa ao mesmo tempo. Por exemplo, a caixa `url` tem ambas "
"as versões\n"
"  1,0 e 0,5. Como o `Url` de `url:1.0` e o `Url` de `url:0.5` são\n"
"  tipos diferentes, um cliente HTTP que usa `url:0.5` não aceitaria valores "
"`Url`\n"
"  de um web scraper que usa `url:1.0`.\n"
"- Pacotes em crates.io não são selecionados. Uma caixa pode estar mal "
"escrita, ter\n"
"  documentação inútil ou totalmente malicioso.\n"
"- Duas caixas pequenas podem ser menos otimizadas do que uma grande, pois o "
"compilador\n"
"  não executa otimização de tempo de link (LTO) por padrão."

#: src\patterns/structural/small-crates.md:36
#, fuzzy
msgid ""
"The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions\n"
"for converting `&T` to `&[T]`."
msgstr ""
"A caixa [`ref_slice`](https://crates.io/crates/ref_slice) fornece funções\n"
"para converter `&T` em `&[T]`."

#: src\patterns/structural/small-crates.md:39
#, fuzzy
msgid ""
"The [`url`](https://crates.io/crates/url) crate provides tools for working "
"with\n"
"URLs."
msgstr ""
"A caixa [`url`](https://crates.io/crates/url) fornece ferramentas para "
"trabalhar com\n"
"URLs."

#: src\patterns/structural/small-crates.md:42
#, fuzzy
msgid ""
"The [`num_cpus`](https://crates.io/crates/num_cpus) crate provides a "
"function to\n"
"query the number of CPUs on a machine."
msgstr ""
"A caixa [`num_cpus`](https://crates.io/crates/num_cpus) fornece uma função "
"para\n"
"consultar o número de CPUs em uma máquina."

#: src\patterns/structural/small-crates.md:47
#, fuzzy
msgid "- [crates.io: The Rust community crate host](https://crates.io/)"
msgstr "- [crates.io: o host de caixas da comunidade Rust](https://crates.io/)"

#: src\patterns/structural/unsafe-mods.md:1
#, fuzzy
msgid "# Contain unsafety in small modules"
msgstr "# Conter a insegurança em pequenos módulos"

#: src\patterns/structural/unsafe-mods.md:5
#, fuzzy
msgid ""
"If you have `unsafe` code, create the smallest possible module that can "
"uphold\n"
"the needed invariants to build a minimal safe interface upon the unsafety. "
"Embed\n"
"this into a larger module that contains only safe code and presents an "
"ergonomic\n"
"interface. Note that the outer module can contain unsafe functions and "
"methods\n"
"that call directly into the unsafe code. Users may use this to gain speed "
"benefits."
msgstr ""
"Se você tiver um código `inseguro`, crie o menor módulo possível que possa "
"suportar\n"
"as invariantes necessárias para construir uma interface segura mínima sobre "
"a insegurança. Embutir\n"
"isso em um módulo maior que contém apenas código seguro e apresenta um "
"design ergonômico\n"
"interface. Observe que o módulo externo pode conter funções e métodos "
"inseguros\n"
"que chamam diretamente para o código inseguro. Os usuários podem usar isso "
"para obter benefícios de velocidade."

#: src\patterns/structural/unsafe-mods.md:13
#, fuzzy
msgid ""
"- This restricts the unsafe code that must be audited\n"
"- Writing the outer module is much easier, since you can count on the "
"guarantees\n"
"  of the inner module"
msgstr ""
"- Isso restringe o código inseguro que deve ser auditado\n"
"- Escrever o módulo externo é muito mais fácil, pois você pode contar com as "
"garantias\n"
"  do módulo interno"

#: src\patterns/structural/unsafe-mods.md:19
#, fuzzy
msgid ""
"- Sometimes, it may be hard to find a suitable interface.\n"
"- The abstraction may introduce inefficiencies."
msgstr ""
"- Às vezes, pode ser difícil encontrar uma interface adequada.\n"
"- A abstração pode introduzir ineficiências."

#: src\patterns/structural/unsafe-mods.md:24
#, fuzzy
msgid ""
"- The [`toolshed`](https://docs.rs/toolshed) crate contains its unsafe "
"operations\n"
"  in submodules, presenting a safe interface to users.\n"
"- `std`'s `String` class is a wrapper over `Vec<u8>` with the added "
"invariant\n"
"  that the contents must be valid UTF-8. The operations on `String` ensure "
"this\n"
"  behavior.\n"
"  However, users have the option of using an `unsafe` method to create a "
"`String`,\n"
"  in which case the onus is on them to guarantee the validity of the "
"contents."
msgstr ""
"- A caixa [`toolshed`](https://docs.rs/toolshed) contém suas operações "
"inseguras\n"
"  em submódulos, apresentando uma interface segura aos usuários.\n"
"- A classe `String` de `std` é um wrapper sobre `Vec<u8>` com a invariante "
"adicionada\n"
"  que o conteúdo deve ser UTF-8 válido. As operações em `String` garantem "
"isso\n"
"  comportamento.\n"
"  No entanto, os usuários têm a opção de usar um método `inseguro` para "
"criar uma `String`,\n"
"  neste caso, cabe a eles o ônus de garantir a validade do conteúdo."

#: src\patterns/structural/unsafe-mods.md:34
#, fuzzy
msgid ""
"- [Ralf Jung's Blog about invariants in unsafe "
"code](https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html)"
msgstr ""
"- [Blog de Ralf Jung sobre invariantes em código "
"inseguro](https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html)"

#: src\patterns/ffi/intro.md:1
#, fuzzy
msgid "# FFI Patterns"
msgstr "# Padrões FFI"

#: src\patterns/ffi/intro.md:3
#, fuzzy
msgid ""
"Writing FFI code is an entire course in itself.\n"
"However, there are several idioms here that can act as pointers, and avoid "
"traps\n"
"for inexperienced users of unsafe Rust."
msgstr ""
"Escrever código FFI é um curso completo em si.\n"
"No entanto, existem vários idiomas aqui que podem atuar como ponteiros e "
"evitar armadilhas\n"
"para usuários inexperientes de Rust inseguro."

#: src\patterns/ffi/intro.md:7
#, fuzzy
msgid "This section contains design patterns that may be useful when doing FFI."
msgstr "Esta seção contém padrões de projeto que podem ser úteis ao fazer FFI."

#: src\patterns/ffi/intro.md:9
#, fuzzy
msgid ""
"1. [Object-Based API](./export.md) design that has good memory safety "
"characteristics,\n"
"   and a clean boundary of what is safe and what is unsafe\n"
"\n"
"2. [Type Consolidation into Wrappers](./wrappers.md) - group multiple Rust "
"types\n"
"   together into an opaque \"object\""
msgstr ""
"1. Design de [API baseada em objeto](./export.md) que possui boas "
"características de segurança de memória,\n"
"   e um limite claro do que é seguro e do que não é seguro\n"
"\n"
"2. [Digite Consolidação em Wrappers](./wrappers.md) - agrupe vários tipos de "
"Rust\n"
"   juntos em um \"objeto\" opaco"

#: src\patterns/ffi/export.md:1
#, fuzzy
msgid "# Object-Based APIs"
msgstr "# APIs baseadas em objetos"

#: src\patterns/ffi/export.md:5
#, fuzzy
msgid ""
"When designing APIs in Rust which are exposed to other languages, there are "
"some\n"
"important design principles which are contrary to normal Rust API design:"
msgstr ""
"Ao projetar APIs em Rust expostas a outras linguagens, existem algumas\n"
"princípios de design importantes que são contrários ao design normal da Rust "
"API:"

#: src\patterns/ffi/export.md:8
#, fuzzy
msgid ""
"1. All Encapsulated types should be _owned_ by Rust, _managed_ by the user,\n"
"   and _opaque_.\n"
"2. All Transactional data types should be _owned_ by the user, and "
"_transparent_.\n"
"3. All library behavior should be functions acting upon Encapsulated types.\n"
"4. All library behavior should be encapsulated into types not based on "
"structure,\n"
"   but _provenance/lifetime_."
msgstr ""
"1. Todos os tipos encapsulados devem ser _propriedade_ da Rust, "
"_gerenciados_ pelo usuário,\n"
"   e _opaco_.\n"
"2. Todos os tipos de dados transacionais devem ser _propriedade_ do usuário "
"e _transparentes_.\n"
"3. Todo o comportamento da biblioteca deve ser funções agindo sobre tipos "
"encapsulados.\n"
"4. Todo o comportamento da biblioteca deve ser encapsulado em tipos não "
"baseados em estrutura,\n"
"   mas _proveniência/tempo de vida_."

#: src\patterns/ffi/export.md:17
#, fuzzy
msgid ""
"Rust has built-in FFI support to other languages.\n"
"It does this by providing a way for crate authors to provide C-compatible "
"APIs\n"
"through different ABIs (though that is unimportant to this practice)."
msgstr ""
"Rust possui suporte FFI integrado para outros idiomas.\n"
"Ele faz isso fornecendo uma maneira para os autores de caixas fornecerem "
"APIs compatíveis com C\n"
"através de diferentes ABIs (embora isso não seja importante para esta "
"prática)."

#: src\patterns/ffi/export.md:21
#, fuzzy
msgid ""
"Well-designed Rust FFI follows C API design principles, while compromising "
"the\n"
"design in Rust as little as possible. There are three goals with any foreign "
"API:"
msgstr ""
"O Rust FFI bem projetado segue os princípios de design da API C, ao mesmo "
"tempo em que compromete o\n"
"projete em Rust o mínimo possível. Existem três objetivos com qualquer API "
"estrangeira:"

#: src\patterns/ffi/export.md:24
#, fuzzy
msgid ""
"1. Make it easy to use in the target language.\n"
"2. Avoid the API dictating internal unsafety on the Rust side as much as "
"possible.\n"
"3. Keep the potential for memory unsafety and Rust `undefined behaviour` as "
"small\n"
"   as possible."
msgstr ""
"1. Facilite o uso no idioma de destino.\n"
"2. Evite o máximo possível a API ditando a insegurança interna no lado da "
"Rust.\n"
"3. Mantenha o potencial de insegurança de memória e \"comportamento "
"indefinido\" Rust como pequeno\n"
"   que possível."

#: src\patterns/ffi/export.md:29
#, fuzzy
msgid ""
"Rust code must trust the memory safety of the foreign language beyond a "
"certain\n"
"point. However, every bit of `unsafe` code on the Rust side is an "
"opportunity for\n"
"bugs, or to exacerbate `undefined behaviour`."
msgstr ""
"O código Rust deve confiar na segurança da memória do idioma estrangeiro "
"além de um certo\n"
"apontar. No entanto, cada pedaço de código `inseguro` no lado do Rust é uma "
"oportunidade para\n"
"bugs, ou para exacerbar `comportamento indefinido`."

#: src\patterns/ffi/export.md:33
#, fuzzy
msgid ""
"For example, if a pointer provenance is wrong, that may be a segfault due "
"to\n"
"invalid memory access. But if it is manipulated by unsafe code, it could "
"become\n"
"full-blown heap corruption."
msgstr ""
"Por exemplo, se a proveniência de um ponteiro estiver errada, isso pode ser "
"uma falha de segmentação devido a\n"
"acesso inválido à memória. Mas se for manipulado por código inseguro, pode "
"tornar-se\n"
"corrupção total da pilha."

#: src\patterns/ffi/export.md:37
#, fuzzy
msgid ""
"The Object-Based API design allows for writing shims that have good memory "
"safety\n"
"characteristics, and a clean boundary of what is safe and what is `unsafe`."
msgstr ""
"O design da API baseada em objeto permite escrever shims com boa segurança "
"de memória\n"
"características e um limite claro do que é seguro e do que é 'inseguro'."

#: src\patterns/ffi/export.md:42
#, fuzzy
msgid ""
"The POSIX standard defines the API to access an on-file database, known as "
"[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h).\n"
"It is an excellent example of an \"object-based\" API."
msgstr ""
"O padrão POSIX define a API para acessar um banco de dados on-file, "
"conhecido como "
"[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h) "
".\n"
"É um excelente exemplo de uma API \"baseada em objeto\"."

#: src\patterns/ffi/export.md:45
#, fuzzy
msgid ""
"Here is the definition in C, which hopefully should be easy to read for "
"those\n"
"involved in FFI. The commentary below should help explain it for those who\n"
"miss the subtleties."
msgstr ""
"Aqui está a definição em C, que deve ser fácil de ler para aqueles\n"
"envolvidos no FFI. O comentário abaixo deve ajudar a explicá-lo para aqueles "
"que\n"
"perca as sutilezas."

#: src\patterns/ffi/export.md:49
msgid ""
"```C\n"
"struct DBM;\n"
"typedef struct { void *dptr, size_t dsize } datum;\n"
"\n"
"int     dbm_clearerr(DBM *);\n"
"void    dbm_close(DBM *);\n"
"int     dbm_delete(DBM *, datum);\n"
"int     dbm_error(DBM *);\n"
"datum   dbm_fetch(DBM *, datum);\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"DBM    *dbm_open(const char *, int, mode_t);\n"
"int     dbm_store(DBM *, datum, datum, int);\n"
"```"
msgstr ""

#: src\patterns/ffi/export.md:64
#, fuzzy
msgid "This API defines two types: `DBM` and `datum`."
msgstr "Esta API define dois tipos: `DBM` e `datum`."

#: src\patterns/ffi/export.md:66
#, fuzzy
msgid ""
"The `DBM` type was called an \"encapsulated\" type above.\n"
"It is designed to contain internal state, and acts as an entry point for "
"the\n"
"library's behavior."
msgstr ""
"O tipo `DBM` foi chamado de tipo \"encapsulado\" acima.\n"
"Ele é projetado para conter o estado interno e atua como um ponto de entrada "
"para o\n"
"comportamento da biblioteca."

#: src\patterns/ffi/export.md:70
#, fuzzy
msgid ""
"It is completely opaque to the user, who cannot create a `DBM` themselves "
"since\n"
"they don't know its size or layout. Instead, they must call `dbm_open`, and "
"that\n"
"only gives them _a pointer to one_."
msgstr ""
"É completamente opaco para o usuário, que não pode criar um `DBM` por conta "
"própria, pois\n"
"eles não sabem seu tamanho ou layout. Em vez disso, eles devem chamar "
"`dbm_open`, e isso\n"
"apenas dá a eles _um ponteiro para um_."

#: src\patterns/ffi/export.md:74
#, fuzzy
msgid ""
"This means all `DBM`s are \"owned\" by the library in a Rust sense.\n"
"The internal state of unknown size is kept in memory controlled by the "
"library,\n"
"not the user. The user can only manage its life cycle with `open` and "
"`close`,\n"
"and perform operations on it with the other functions."
msgstr ""
"Isso significa que todos os `DBM`s são \"propriedade\" da biblioteca no "
"sentido Rust.\n"
"O estado interno de tamanho desconhecido é mantido na memória controlada "
"pela biblioteca,\n"
"não o usuário. O usuário só pode gerenciar seu ciclo de vida com 'abrir' e "
"'fechar',\n"
"e executar operações nele com as outras funções."

#: src\patterns/ffi/export.md:79
#, fuzzy
msgid ""
"The `datum` type was called a \"transactional\" type above.\n"
"It is designed to facilitate the exchange of information between the library "
"and\n"
"its user."
msgstr ""
"O tipo `datum` foi chamado de tipo \"transacional\" acima.\n"
"Ele é projetado para facilitar a troca de informações entre a biblioteca e "
"os\n"
"seu usuário."

#: src\patterns/ffi/export.md:83
#, fuzzy
msgid ""
"The database is designed to store \"unstructured data\", with no pre-defined "
"length\n"
"or meaning. As a result, the `datum` is the C equivalent of a Rust slice: a "
"bunch\n"
"of bytes, and a count of how many there are. The main difference is that "
"there is\n"
"no type information, which is what `void` indicates."
msgstr ""
"O banco de dados é projetado para armazenar \"dados não estruturados\", sem "
"comprimento pré-definido\n"
"ou significado. Como resultado, o `datum` é o equivalente em C de uma fatia "
"Rust: um monte\n"
"de bytes e uma contagem de quantos existem. A principal diferença é que "
"existe\n"
"nenhuma informação de tipo, que é o que `void` indica."

#: src\patterns/ffi/export.md:88
#, fuzzy
msgid ""
"Keep in mind that this header is written from the library's point of view.\n"
"The user likely has some type they are using, which has a known size.\n"
"But the library does not care, and by the rules of C casting, any type "
"behind a\n"
"pointer can be cast to `void`."
msgstr ""
"Tenha em mente que este cabeçalho foi escrito do ponto de vista da "
"biblioteca.\n"
"O usuário provavelmente tem algum tipo que está usando, que tem um tamanho "
"conhecido.\n"
"Mas a biblioteca não se importa, e pelas regras do C casting, qualquer tipo "
"por trás de um\n"
"ponteiro pode ser convertido em `void`."

#: src\patterns/ffi/export.md:93
#, fuzzy
msgid ""
"As noted earlier, this type is _transparent_ to the user. But also, this "
"type is\n"
"_owned_ by the user.\n"
"This has subtle ramifications, due to that pointer inside it.\n"
"The question is, who owns the memory that pointer points to?"
msgstr ""
"Conforme observado anteriormente, esse tipo é _transparent_ para o usuário. "
"Mas também, este tipo é\n"
"_propriedade_ do usuário.\n"
"Isso tem ramificações sutis, devido ao ponteiro dentro dele.\n"
"A questão é: a quem pertence a memória para a qual o ponteiro aponta?"

#: src\patterns/ffi/export.md:98
#, fuzzy
msgid ""
"The answer for best memory safety is, \"the user\".\n"
"But in cases such as retrieving a value, the user does not know how to "
"allocate\n"
"it correctly (since they don't know how long the value is). In this case, "
"the library\n"
"code is expected to use the heap that the user has access to -- such as the "
"C library\n"
"`malloc` and `free` -- and then _transfer ownership_ in the Rust sense."
msgstr ""
"A resposta para a melhor segurança de memória é \"o usuário\".\n"
"Mas em casos como recuperar um valor, o usuário não sabe como alocar\n"
"corretamente (já que eles não sabem quanto tempo é o valor). Neste caso, a "
"biblioteca\n"
"espera-se que o código use o heap ao qual o usuário tem acesso -- como a "
"biblioteca C\n"
"`malloc` e `free` -- e então _transferir propriedade_ no sentido Rust."

#: src\patterns/ffi/export.md:104
#, fuzzy
msgid ""
"This may all seem speculative, but this is what a pointer means in C.\n"
"It means the same thing as Rust: \"user defined lifetime.\"\n"
"The user of the library needs to read the documentation in order to use it "
"correctly.\n"
"That said, there are some decisions that have fewer or greater consequences "
"if users\n"
"do it wrong. Minimizing those are what this best practice is about, and the "
"key\n"
"is to _transfer ownership of everything that is transparent_."
msgstr ""
"Tudo isso pode parecer especulativo, mas é isso que um ponteiro significa em "
"C.\n"
"Significa a mesma coisa que Rust: \"tempo de vida definido pelo usuário\".\n"
"O usuário da biblioteca precisa ler a documentação para utilizá-la "
"corretamente.\n"
"Dito isso, há algumas decisões que têm menos ou mais consequências se os "
"usuários\n"
"faça errado. Minimizá-los é o objetivo desta melhor prática, e a chave\n"
"é _transferir a propriedade de tudo que é transparente_."

#: src\patterns/ffi/export.md:113
#, fuzzy
msgid ""
"This minimizes the number of memory safety guarantees the user must uphold "
"to a\n"
"relatively small number:"
msgstr ""
"Isso minimiza o número de garantias de segurança de memória que o usuário "
"deve manter a um\n"
"número relativamente pequeno:"

#: src\patterns/ffi/export.md:116
#, fuzzy
msgid ""
"1. Do not call any function with a pointer not returned by `dbm_open` "
"(invalid\n"
"   access or corruption).\n"
"2. Do not call any function on a pointer after close (use after free).\n"
"3. The `dptr` on any `datum` must be `NULL`, or point to a valid slice of "
"memory\n"
"   at the advertised length."
msgstr ""
"1. Não chame nenhuma função com um ponteiro não retornado por `dbm_open` "
"(inválido\n"
"   acesso ou corrupção).\n"
"2. Não chame nenhuma função em um ponteiro depois de fechar (use depois de "
"liberar).\n"
"3. O `dptr` em qualquer `datum` deve ser `NULL` ou apontar para uma parte "
"válida da memória\n"
"   no comprimento anunciado."

#: src\patterns/ffi/export.md:122
#, fuzzy
msgid ""
"In addition, it avoids a lot of pointer provenance issues.\n"
"To understand why, let us consider an alternative in some depth: key "
"iteration."
msgstr ""
"Além disso, evita muitos problemas de proveniência do ponteiro.\n"
"Para entender o porquê, vamos considerar uma alternativa com alguma "
"profundidade: iteração de chave."

#: src\patterns/ffi/export.md:125
#, fuzzy
msgid ""
"Rust is well known for its iterators.\n"
"When implementing one, the programmer makes a separate type with a bounded "
"lifetime\n"
"to its owner, and implements the `Iterator` trait."
msgstr ""
"Rust é bem conhecido por seus iteradores.\n"
"Ao implementar um, o programador cria um tipo separado com um tempo de vida "
"limitado\n"
"ao seu proprietário e implementa a característica `Iterator`."

#: src\patterns/ffi/export.md:129
#, fuzzy
msgid "Here is how iteration would be done in Rust for `DBM`:"
msgstr "Aqui está como a iteração seria feita em Rust para `DBM`:"

#: src\patterns/ffi/export.md:131
msgid ""
"```rust,ignore\n"
"struct Dbm { ... }\n"
"\n"
"impl Dbm {\n"
"    /* ... */\n"
"    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }\n"
"    /* ... */\n"
"}\n"
"\n"
"struct DbmKeysIter<'it> {\n"
"    owner: &'it Dbm,\n"
"}\n"
"\n"
"impl<'it> Iterator for DbmKeysIter<'it> { ... }\n"
"```"
msgstr ""

#: src\patterns/ffi/export.md:147
#, fuzzy
msgid ""
"This is clean, idiomatic, and safe. thanks to Rust's guarantees.\n"
"However, consider what a straightforward API translation would look like:"
msgstr ""
"Isso é limpo, idiomático e seguro. graças às garantias de Rust.\n"
"No entanto, considere como seria uma tradução direta da API:"

#: src\patterns/ffi/export.md:150
msgid ""
"```rust,ignore\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_next(\n"
"    iter: *mut DbmKeysIter,\n"
"    key_out: *const datum\n"
") -> libc::c_int {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"```"
msgstr ""

#: src\patterns/ffi/export.md:168
#, fuzzy
msgid ""
"This API loses a key piece of information: the lifetime of the iterator must "
"not\n"
"exceed the lifetime of the `Dbm` object that owns it. A user of the library "
"could\n"
"use it in a way which causes the iterator to outlive the data it is "
"iterating on,\n"
"resulting in reading uninitialized memory."
msgstr ""
"Essa API perde uma informação importante: o tempo de vida do iterador não "
"deve\n"
"exceder o tempo de vida do objeto `Dbm` que o possui. Um usuário da "
"biblioteca pode\n"
"usá-lo de uma maneira que faça com que o iterador sobreviva aos dados em que "
"está iterando,\n"
"resultando na leitura de memória não inicializada."

#: src\patterns/ffi/export.md:173
#, fuzzy
msgid ""
"This example written in C contains a bug that will be explained afterwards:"
msgstr "Este exemplo escrito em C contém um bug que será explicado a seguir:"

#: src\patterns/ffi/export.md:175
msgid ""
"```C\n"
"int count_key_sizes(DBM *db) {\n"
"    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!\n"
"    datum key;\n"
"    int len = 0;\n"
"\n"
"    if (!dbm_iter_new(db)) {\n"
"        dbm_close(db);\n"
"        return -1;\n"
"    }\n"
"\n"
"    int l;\n"
"    while ((l = dbm_iter_next(owner, &key)) >= 0) { // an error is indicated "
"by -1\n"
"        free(key.dptr);\n"
"        len += key.dsize;\n"
"        if (l == 0) { // end of the iterator\n"
"            dbm_close(owner);\n"
"        }\n"
"    }\n"
"    if l >= 0 {\n"
"        return -1;\n"
"    } else {\n"
"        return len;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\patterns/ffi/export.md:202
#, fuzzy
msgid ""
"This bug is a classic. Here's what happens when the iterator returns the\n"
"end-of-iteration marker:"
msgstr ""
"Este erro é um clássico. Aqui está o que acontece quando o iterador retorna "
"o\n"
"marcador de fim de iteração:"

#: src\patterns/ffi/export.md:205
#, fuzzy
msgid ""
"1. The loop condition sets `l` to zero, and enters the loop because `0 >= "
"0`.\n"
"2. The length is incremented, in this case by zero.\n"
"3. The if statement is true, so the database is closed. There should be a "
"break\n"
"   statement here.\n"
"4. The loop condition executes again, causing a `next` call on the closed "
"object."
msgstr ""
"1. A condição do loop define `l` como zero e entra no loop porque `0 >= 0`.\n"
"2. O comprimento é incrementado, neste caso por zero.\n"
"3. A instrução if é verdadeira, então o banco de dados está fechado. Deve "
"haver uma pausa\n"
"   declaração aqui.\n"
"4. A condição do loop é executada novamente, causando uma chamada `next` no "
"objeto fechado."

#: src\patterns/ffi/export.md:211
#, fuzzy
msgid ""
"The worst part about this bug?\n"
"If the Rust implementation was careful, this code will work most of the "
"time!\n"
"If the memory for the `Dbm` object is not immediately reused, an internal "
"check\n"
"will almost certainly fail, resulting in the iterator returning a `-1` "
"indicating\n"
"an error. But occasionally, it will cause a segmentation fault, or even "
"worse,\n"
"nonsensical memory corruption!"
msgstr ""
"A pior parte desse bug?\n"
"Se a implementação do Rust for cuidadosa, esse código funcionará na maioria "
"das vezes!\n"
"Se a memória para o objeto `Dbm` não for reutilizada imediatamente, uma "
"verificação interna\n"
"quase certamente falhará, resultando no iterador retornando um `-1` "
"indicando\n"
"um erro. Mas, ocasionalmente, causará uma falha de segmentação ou, pior "
"ainda,\n"
"corrupção de memória sem sentido!"

#: src\patterns/ffi/export.md:218
#, fuzzy
msgid ""
"None of this can be avoided by Rust.\n"
"From its perspective, it put those objects on its heap, returned pointers to "
"them,\n"
"and gave up control of their lifetimes. The C code simply must \"play nice\"."
msgstr ""
"Nada disso pode ser evitado por Rust.\n"
"De sua perspectiva, ele colocou esses objetos em sua pilha, retornou "
"ponteiros para eles,\n"
"e desistiram do controle de suas vidas. O código C simplesmente deve \"jogar "
"bem\"."

#: src\patterns/ffi/export.md:222
#, fuzzy
msgid ""
"The programmer must read and understand the API documentation.\n"
"While some consider that par for the course in C, a good API design can "
"mitigate\n"
"this risk. The POSIX API for `DBM` did this by _consolidating the ownership_ "
"of\n"
"the iterator with its parent:"
msgstr ""
"O programador deve ler e entender a documentação da API.\n"
"Enquanto alguns consideram esse par para o curso em C, um bom design de API "
"pode atenuar\n"
"este risco. A API POSIX para `DBM` fez isso _consolidando a propriedade_ de\n"
"o iterador com seu pai:"

#: src\patterns/ffi/export.md:227
msgid ""
"```C\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"```"
msgstr ""

#: src\patterns/ffi/export.md:232
#, fuzzy
msgid ""
"Thus, all the lifetimes were bound together, and such unsafety was prevented."
msgstr "Assim, todas as vidas foram unidas e tal insegurança foi evitada."

#: src\patterns/ffi/export.md:236
#, fuzzy
msgid ""
"However, this design choice also has a number of drawbacks, which should be\n"
"considered as well."
msgstr ""
"No entanto, esta escolha de design também tem uma série de desvantagens, que "
"devem ser\n"
"considerado também."

#: src\patterns/ffi/export.md:239
#, fuzzy
msgid ""
"First, the API itself becomes less expressive.\n"
"With POSIX DBM, there is only one iterator per object, and every call "
"changes\n"
"its state. This is much more restrictive than iterators in almost any "
"language,\n"
"even though it is safe. Perhaps with other related objects, whose lifetimes "
"are\n"
"less hierarchical, this limitation is more of a cost than the safety."
msgstr ""
"Primeiro, a própria API se torna menos expressiva.\n"
"Com POSIX DBM, há apenas um iterador por objeto e cada chamada muda\n"
"seu estado. Isso é muito mais restritivo do que iteradores em quase qualquer "
"idioma,\n"
"mesmo que seja seguro. Talvez com outros objetos relacionados, cujas vidas "
"são\n"
"menos hierárquica, essa limitação é mais um custo do que a segurança."

#: src\patterns/ffi/export.md:245
#, fuzzy
msgid ""
"Second, depending on the relationships of the API's parts, significant "
"design effort\n"
"may be involved. Many of the easier design points have other patterns "
"associated\n"
"with them:"
msgstr ""
"Em segundo lugar, dependendo das relações das partes da API, um esforço de "
"design significativo\n"
"pode estar envolvido. Muitos dos pontos de design mais fáceis têm outros "
"padrões associados\n"
"com eles:"

#: src\patterns/ffi/export.md:249
#, fuzzy
msgid ""
"- [Wrapper Type Consolidation](./wrappers.md) groups multiple Rust types "
"together\n"
"  into an opaque \"object\"\n"
"\n"
"- [FFI Error Passing](../../idioms/ffi/errors.md) explains error handling "
"with integer\n"
"  codes and sentinel return values (such as `NULL` pointers)\n"
"\n"
"- [Accepting Foreign Strings](../../idioms/ffi/accepting-strings.md) allows "
"accepting\n"
"  strings with minimal unsafe code, and is easier to get right than\n"
"  [Passing Strings to FFI](../../idioms/ffi/passing-strings.md)"
msgstr ""
"- [Consolidação de tipo de wrapper](./wrappers.md) agrupa vários tipos de "
"Rust\n"
"  em um \"objeto\" opaco\n"
"\n"
"- [FFI Error Passing](../../idioms/ffi/errors.md) explica o tratamento de "
"erros com número inteiro\n"
"  códigos e valores de retorno do sentinela (como ponteiros `NULL`)\n"
"\n"
"- [Accepting Foreign Strings](../../idioms/ffi/accepting-strings.md) permite "
"aceitar\n"
"  strings com código inseguro mínimo e é mais fácil de acertar do que\n"
"  [Passando Strings para FFI](../../idioms/ffi/passing-strings.md)"

#: src\patterns/ffi/export.md:259
#, fuzzy
msgid ""
"However, not every API can be done this way.\n"
"It is up to the best judgement of the programmer as to who their audience is."
msgstr ""
"No entanto, nem toda API pode ser feita dessa maneira.\n"
"Cabe ao melhor julgamento do programador saber quem é seu público."

#: src\patterns/ffi/wrappers.md:1
#, fuzzy
msgid "# Type Consolidation into Wrappers"
msgstr "# Digite a consolidação em wrappers"

#: src\patterns/ffi/wrappers.md:5
#, fuzzy
msgid ""
"This pattern is designed to allow gracefully handling multiple related "
"types,\n"
"while minimizing the surface area for memory unsafety."
msgstr ""
"Esse padrão foi projetado para permitir o manuseio elegante de vários tipos "
"relacionados,\n"
"enquanto minimiza a área de superfície para insegurança de memória."

#: src\patterns/ffi/wrappers.md:8
#, fuzzy
msgid ""
"One of the cornerstones of Rust's aliasing rules is lifetimes.\n"
"This ensures that many patterns of access between types can be memory safe,\n"
"data race safety included."
msgstr ""
"Um dos pilares das regras de aliasing de Rust são os tempos de vida.\n"
"Isso garante que muitos padrões de acesso entre os tipos possam ser seguros "
"para a memória,\n"
"segurança de corrida de dados incluída."

#: src\patterns/ffi/wrappers.md:12
#, fuzzy
msgid ""
"However, when Rust types are exported to other languages, they are usually "
"transformed\n"
"into pointers. In Rust, a pointer means \"the user manages the lifetime of "
"the pointee.\"\n"
"It is their responsibility to avoid memory unsafety."
msgstr ""
"No entanto, quando os tipos Rust são exportados para outros idiomas, eles "
"geralmente são transformados\n"
"em ponteiros. Em Rust, um ponteiro significa \"o usuário gerencia o tempo de "
"vida da ponta\".\n"
"É sua responsabilidade evitar a insegurança da memória."

#: src\patterns/ffi/wrappers.md:16
#, fuzzy
msgid ""
"Some level of trust in the user code is thus required, notably around "
"use-after-free\n"
"which Rust can do nothing about. However, some API designs place higher "
"burdens\n"
"than others on the code written in the other language."
msgstr ""
"Algum nível de confiança no código do usuário é, portanto, necessário, "
"principalmente em torno do use-after-free\n"
"sobre o qual Rust não pode fazer nada. No entanto, alguns designs de API "
"impõem cargas maiores\n"
"do que outros no código escrito no outro idioma."

#: src\patterns/ffi/wrappers.md:20
#, fuzzy
msgid ""
"The lowest risk API is the \"consolidated wrapper\", where all possible "
"interactions\n"
"with an object are folded into a \"wrapper type\", while keeping the Rust "
"API clean."
msgstr ""
"A API de menor risco é o \"wrapper consolidado\", onde todas as interações "
"possíveis\n"
"com um objeto são dobrados em um \"tipo wrapper\", mantendo a API Rust limpa."

#: src\patterns/ffi/wrappers.md:25
#, fuzzy
msgid ""
"To understand this, let us look at a classic example of an API to export: "
"iteration\n"
"through a collection."
msgstr ""
"Para entender isso, vejamos um exemplo clássico de uma API para exportar: "
"iteração\n"
"através de uma coleção."

#: src\patterns/ffi/wrappers.md:28
#, fuzzy
msgid "That API looks like this:"
msgstr "Essa API se parece com isso:"

#: src\patterns/ffi/wrappers.md:30
#, fuzzy
msgid ""
"1. The iterator is initialized with `first_key`.\n"
"2. Each call to `next_key` will advance the iterator.\n"
"3. Calls to `next_key` if the iterator is at the end will do nothing.\n"
"4. As noted above, the iterator is \"wrapped into\" the collection (unlike "
"the native\n"
"   Rust API)."
msgstr ""
"1. O iterador é inicializado com `first_key`.\n"
"2. Cada chamada para `next_key` avançará o iterador.\n"
"3. Chamadas para `next_key` se o iterador estiver no final não farão nada.\n"
"4. Conforme observado acima, o iterador é \"envolto\" na coleção (ao "
"contrário do nativo\n"
"   API de ferrugem)."

#: src\patterns/ffi/wrappers.md:36
#, fuzzy
msgid ""
"If the iterator implements `nth()` efficiently, then it is possible to make "
"it\n"
"ephemeral to each function call:"
msgstr ""
"Se o iterador implementa `nth()` de forma eficiente, então é possível "
"torná-lo\n"
"efêmero para cada chamada de função:"

#: src\patterns/ffi/wrappers.md:39
msgid ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"}\n"
"\n"
"impl MySetWrapper {\n"
"    pub fn first_key(&mut self) -> Option<&Key> {\n"
"        self.iter_next = 0;\n"
"        self.next_key()\n"
"    }\n"
"    pub fn next_key(&mut self) -> Option<&Key> {\n"
"        if let Some(next) = self.myset.keys().nth(self.iter_next) {\n"
"            self.iter_next += 1;\n"
"            Some(next)\n"
"        } else {\n"
"            None\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\patterns/ffi/wrappers.md:61
#, fuzzy
msgid "As a result, the wrapper is simple and contains no `unsafe` code."
msgstr ""
"Como resultado, o wrapper é simples e não contém nenhum código `inseguro`."

#: src\patterns/ffi/wrappers.md:65
#, fuzzy
msgid ""
"This makes APIs safer to use, avoiding issues with lifetimes between types.\n"
"See [Object-Based APIs](./export.md) for more on the advantages and "
"pitfalls\n"
"this avoids."
msgstr ""
"Isso torna as APIs mais seguras de usar, evitando problemas com tempos de "
"vida entre os tipos.\n"
"Consulte [APIs baseadas em objetos](./export.md) para saber mais sobre as "
"vantagens e armadilhas\n"
"isso evita."

#: src\patterns/ffi/wrappers.md:71
#, fuzzy
msgid ""
"Often, wrapping types is quite difficult, and sometimes a Rust API "
"compromise\n"
"would make things easier."
msgstr ""
"Freqüentemente, os tipos de empacotamento são bastante difíceis e, às vezes, "
"um comprometimento da Rust API\n"
"facilitaria as coisas."

#: src\patterns/ffi/wrappers.md:74
#, fuzzy
msgid ""
"As an example, consider an iterator which does not efficiently implement "
"`nth()`.\n"
"It would definitely be worth putting in special logic to make the object "
"handle\n"
"iteration internally, or to support a different access pattern efficiently "
"that\n"
"only the Foreign Function API will use."
msgstr ""
"Como exemplo, considere um iterador que não implementa eficientemente "
"`nth()`.\n"
"Definitivamente valeria a pena colocar uma lógica especial para fazer o "
"objeto manipular\n"
"iteração internamente, ou para suportar um padrão de acesso diferente de "
"forma eficiente que\n"
"somente a API de Função Estrangeira usará."

#: src\patterns/ffi/wrappers.md:79
#, fuzzy
msgid "### Trying to Wrap Iterators (and Failing)"
msgstr "### Tentando agrupar iteradores (e falhando)"

#: src\patterns/ffi/wrappers.md:81
#, fuzzy
msgid ""
"To wrap any type of iterator into the API correctly, the wrapper would need "
"to\n"
"do what a C version of the code would do: erase the lifetime of the "
"iterator,\n"
"and manage it manually."
msgstr ""
"Para agrupar qualquer tipo de iterador na API corretamente, o empacotador "
"precisaria\n"
"fazer o que uma versão C do código faria: apagar o tempo de vida do "
"iterador,\n"
"e gerenciá-lo manualmente."

#: src\patterns/ffi/wrappers.md:85
#, fuzzy
msgid "Suffice it to say, this is _incredibly_ difficult."
msgstr "Basta dizer que isso é _incrivelmente_ difícil."

#: src\patterns/ffi/wrappers.md:87
#, fuzzy
msgid "Here is an illustration of just _one_ pitfall."
msgstr "Aqui está uma ilustração de apenas uma armadilha."

#: src\patterns/ffi/wrappers.md:89
#, fuzzy
msgid "A first version of `MySetWrapper` would look like this:"
msgstr "Uma primeira versão de `MySetWrapper` ficaria assim:"

#: src\patterns/ffi/wrappers.md:91
msgid ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"    // created from a transmuted Box<KeysIter + 'self>\n"
"    iterator: Option<NonNull<KeysIter<'static>>>,\n"
"}\n"
"```"
msgstr ""

#: src\patterns/ffi/wrappers.md:100
#, fuzzy
msgid ""
"With `transmute` being used to extend a lifetime, and a pointer to hide it,\n"
"it's ugly already. But it gets even worse: _any other operation can cause\n"
"Rust `undefined behaviour`_."
msgstr ""
"Com `transmutar` sendo usado para estender uma vida, e um ponteiro para "
"ocultá-lo,\n"
"já está feio. Mas fica ainda pior: _qualquer outra operação pode causar\n"
"Rust `comportamento indefinido`_."

#: src\patterns/ffi/wrappers.md:104
#, fuzzy
msgid ""
"Consider that the `MySet` in the wrapper could be manipulated by other\n"
"functions during iteration, such as storing a new value to the key it was\n"
"iterating over. The API doesn't discourage this, and in fact some similar C\n"
"libraries expect it."
msgstr ""
"Considere que o `MySet` no wrapper pode ser manipulado por outros\n"
"funções durante a iteração, como armazenar um novo valor na chave que foi\n"
"iterando. A API não desencoraja isso e, de fato, alguns C semelhantes\n"
"as bibliotecas esperam isso."

#: src\patterns/ffi/wrappers.md:109
#, fuzzy
msgid "A simple implementation of `myset_store` would be:"
msgstr "Uma implementação simples de `myset_store` seria:"

#: src\patterns/ffi/wrappers.md:111
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    pub fn myset_store(\n"
"        myset: *mut MySetWrapper,\n"
"        key: datum,\n"
"        value: datum) -> libc::c_int {\n"
"\n"
"        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.\n"
"\n"
"        let myset: &mut MySet = unsafe { // SAFETY: whoops, UB occurs in "
"here!\n"
"            &mut (*myset).myset\n"
"        };\n"
"\n"
"        /* ...check and cast key and value data... */\n"
"\n"
"        match myset.store(casted_key, casted_value) {\n"
"            Ok(_) => 0,\n"
"            Err(e) => e.into()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\patterns/ffi/wrappers.md:137
#, fuzzy
msgid ""
"If the iterator exists when this function is called, we have violated one of "
"Rust's\n"
"aliasing rules. According to Rust, the mutable reference in this block must "
"have\n"
"_exclusive_ access to the object. If the iterator simply exists, it's not "
"exclusive,\n"
"so we have `undefined behaviour`! "
msgstr ""
"Se o iterador existir quando esta função for chamada, violamos uma das "
"regras do Rust\n"
"regras de alias. De acordo com Rust, a referência mutável neste bloco deve "
"ter\n"
"acesso _exclusivo_ ao objeto. Se o iterador simplesmente existir, não é "
"exclusivo,\n"
"então temos `comportamento indefinido`!"

#: src\patterns/ffi/wrappers.md:142
#, fuzzy
msgid ""
"To avoid this, we must have a way of ensuring that mutable reference really "
"is exclusive.\n"
"That basically means clearing out the iterator's shared reference while it "
"exists,\n"
"and then reconstructing it. In most cases, that will still be less efficient "
"than\n"
"the C version."
msgstr ""
"Para evitar isso, devemos ter uma maneira de garantir que a referência "
"mutável seja realmente exclusiva.\n"
"Isso basicamente significa limpar a referência compartilhada do iterador "
"enquanto ela existe,\n"
"e depois reconstruí-lo. Na maioria dos casos, isso ainda será menos "
"eficiente do que\n"
"a versão C."

#: src\patterns/ffi/wrappers.md:147
#, fuzzy
msgid ""
"Some may ask: how can C do this more efficiently?\n"
"The answer is, it cheats. Rust's aliasing rules are the problem, and C "
"simply ignores\n"
"them for its pointers. In exchange, it is common to see code that is "
"declared\n"
"in the manual as \"not thread safe\" under some or all circumstances. In "
"fact,\n"
"the [GNU C "
"library](https://manpages.debian.org/buster/manpages/attributes.7.en.html)\n"
"has an entire lexicon dedicated to concurrent behavior!"
msgstr ""
"Alguns podem perguntar: como C pode fazer isso de forma mais eficiente?\n"
"A resposta é: engana. As regras de aliasing do Rust são o problema, e C "
"simplesmente ignora\n"
"eles por seus ponteiros. Em troca, é comum ver código declarado\n"
"no manual como \"não thread-safe\" em algumas ou todas as circunstâncias. Na "
"verdade,\n"
"a [biblioteca GNU "
"C](https://manpages.debian.org/buster/manpages/attributes.7.en.html)\n"
"tem todo um léxico dedicado ao comportamento simultâneo!"

#: src\patterns/ffi/wrappers.md:154
#, fuzzy
msgid ""
"Rust would rather make everything memory safe all the time, for both safety "
"and\n"
"optimizations that C code cannot attain. Being denied access to certain "
"shortcuts\n"
"is the price Rust programmers need to pay."
msgstr ""
"Rust prefere tornar tudo seguro para a memória o tempo todo, tanto para "
"segurança quanto para\n"
"otimizações que o código C não pode atingir. Ser negado o acesso a certos "
"atalhos\n"
"é o preço que os programadores Rust precisam pagar."

#: src\patterns/ffi/wrappers.md:158
#, fuzzy
msgid ""
"For the C programmers out there scratching their heads, the iterator need\n"
"not be read _during_ this code cause the UB. The exclusivity rule also "
"enables\n"
"compiler optimizations which may cause inconsistent observations by the "
"iterator's\n"
"shared reference (e.g. stack spills or reordering instructions for "
"efficiency).\n"
"These observations may happen _any time after_ the mutable reference is "
"created."
msgstr ""
"Para os programadores C que estão coçando a cabeça, o iterador precisa\n"
"não ser lido _durante_ este código causa o UB. A regra de exclusividade "
"também permite\n"
"otimizações do compilador que podem causar observações inconsistentes por "
"parte do iterador\n"
"referência compartilhada (por exemplo, derramamentos de pilha ou "
"reordenamento de instruções para eficiência).\n"
"Essas observações podem acontecer _a qualquer momento após_ a referência "
"mutável ser criada."

#: src\anti_patterns/index.md:1
#, fuzzy
msgid "# Anti-patterns"
msgstr "# Antipadrões"

#: src\anti_patterns/index.md:3
#, fuzzy
msgid ""
"An [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) is a solution "
"to\n"
"a \"recurring problem that is usually ineffective and risks being highly\n"
"counterproductive\". Just as valuable as knowing how to solve a problem, is\n"
"knowing how _not_ to solve it. Anti-patterns give us great counter-examples "
"to\n"
"consider relative to design patterns. Anti-patterns are not confined to "
"code.\n"
"For example, a process can be an anti-pattern, too."
msgstr ""
"Um [anti-padrão](https://en.wikipedia.org/wiki/Anti-padrão) é uma solução "
"para\n"
"um \"problema recorrente que geralmente é ineficaz e corre o risco de ser "
"altamente\n"
"contraproducente\". Tão valioso quanto saber resolver um problema, é\n"
"sabendo _não_ resolvê-lo. Os antipadrões nos dão ótimos contra-exemplos "
"para\n"
"considerar em relação aos padrões de projeto. Os antipadrões não estão "
"confinados ao código.\n"
"Por exemplo, um processo também pode ser um antipadrão."

#: src\anti_patterns/borrow_clone.md:1
#, fuzzy
msgid "# Clone to satisfy the borrow checker"
msgstr "# Clone para satisfazer o verificador de empréstimo"

#: src\anti_patterns/borrow_clone.md:5
#, fuzzy
msgid ""
"The borrow checker prevents Rust users from developing otherwise unsafe code "
"by\n"
"ensuring that either: only one mutable reference exists, or potentially many "
"but\n"
"all immutable references exist. If the code written does not hold true to "
"these\n"
"conditions, this anti-pattern arises when the developer resolves the "
"compiler\n"
"error by cloning the variable."
msgstr ""
"O verificador de empréstimo impede que os usuários do Rust desenvolvam "
"códigos inseguros,\n"
"garantindo que: apenas uma referência mutável existe, ou potencialmente "
"muitas, mas\n"
"todas as referências imutáveis existem. Se o código escrito não for fiel a "
"essas\n"
"condições, esse antipadrão surge quando o desenvolvedor resolve o problema "
"do compilador\n"
"erro ao clonar a variável."

#: src\anti_patterns/borrow_clone.md:13
msgid ""
"```rust\n"
"// define any variable\n"
"let mut x = 5;\n"
"\n"
"// Borrow `x` -- but clone it first\n"
"let y = &mut (x.clone());\n"
"\n"
"// without the x.clone() two lines prior, this line would fail on compile "
"as\n"
"// x has been borrowed\n"
"// thanks to x.clone(), x was never borrowed, and this line will run.\n"
"println!(\"{}\", x);\n"
"\n"
"// perform some action on the borrow to prevent rust from optimizing this\n"
"//out of existence\n"
"*y += 1;\n"
"```"
msgstr ""

#: src\anti_patterns/borrow_clone.md:32
#, fuzzy
msgid ""
"It is tempting, particularly for beginners, to use this pattern to resolve\n"
"confusing issues with the borrow checker. However, there are serious\n"
"consequences. Using `.clone()` causes a copy of the data to be made. Any "
"changes\n"
"between the two are not synchronized -- as if two completely separate "
"variables\n"
"exist."
msgstr ""
"É tentador, principalmente para iniciantes, usar esse padrão para resolver\n"
"questões confusas com o verificador de empréstimo. No entanto, existem "
"graves\n"
"consequências. O uso de `.clone()` faz com que uma cópia dos dados seja "
"feita. Qualquer alteração\n"
"entre os dois não estão sincronizados - como se duas variáveis completamente "
"separadas\n"
"existir."

#: src\anti_patterns/borrow_clone.md:38
#, fuzzy
msgid ""
"There are special cases -- `Rc<T>` is designed to handle clones "
"intelligently.\n"
"It internally manages exactly one copy of the data, and cloning it will "
"only\n"
"clone the reference."
msgstr ""
"Existem casos especiais -- `Rc<T>` é projetado para lidar com clones de "
"forma inteligente.\n"
"Ele gerencia internamente exatamente uma cópia dos dados e a clonagem só\n"
"clonar a referência."

#: src\anti_patterns/borrow_clone.md:42
#, fuzzy
msgid ""
"There is also `Arc<T>` which provides shared ownership of a value of type T\n"
"that is allocated in the heap. Invoking `.clone()` on `Arc` produces a new "
"`Arc`\n"
"instance, which points to the same allocation on the heap as the source "
"`Arc`,\n"
"while increasing a reference count."
msgstr ""
"Há também `Arc<T>` que fornece propriedade compartilhada de um valor do tipo "
"T\n"
"que está alocado no heap. Invocar `.clone()` em `Arc` produz um novo `Arc`\n"
"instância, que aponta para a mesma alocação no heap que a origem `Arc`,\n"
"enquanto aumenta uma contagem de referência."

#: src\anti_patterns/borrow_clone.md:47
#, fuzzy
msgid ""
"In general, clones should be deliberate, with full understanding of the\n"
"consequences. If a clone is used to make a borrow checker error disappear,\n"
"that's a good indication this anti-pattern may be in use."
msgstr ""
"Em geral, os clones devem ser deliberados, com total compreensão do\n"
"consequências. Se um clone for usado para fazer desaparecer um erro do "
"verificador de empréstimo,\n"
"essa é uma boa indicação de que esse antipadrão pode estar em uso."

#: src\anti_patterns/borrow_clone.md:51
#, fuzzy
msgid ""
"Even though `.clone()` is an indication of a bad pattern, sometimes\n"
"**it is fine to write inefficient code**, in cases such as when:"
msgstr ""
"Mesmo que `.clone()` seja uma indicação de um padrão ruim, às vezes\n"
"**é bom escrever código ineficiente**, em casos como quando:"

#: src\anti_patterns/borrow_clone.md:54
#, fuzzy
msgid ""
"- the developer is still new to ownership\n"
"- the code doesn't have great speed or memory constraints\n"
"  (like hackathon projects or prototypes)\n"
"- satisfying the borrow checker is really complicated, and you prefer to\n"
"  optimize readability over performance"
msgstr ""
"- o desenvolvedor ainda é novo na propriedade\n"
"- o código não tem grandes restrições de velocidade ou memória\n"
"  (como projetos ou protótipos de hackathon)\n"
"- satisfazer o verificador de empréstimo é realmente complicado e você "
"prefere\n"
"  otimizar a legibilidade sobre o desempenho"

#: src\anti_patterns/borrow_clone.md:60
#, fuzzy
msgid ""
"If an unnecessary clone is suspected, The [Rust Book's chapter on "
"Ownership](https://doc.rust-lang.org/book/ownership.html)\n"
"should be understood fully before assessing whether the clone is required or "
"not."
msgstr ""
"Se houver suspeita de um clone desnecessário, o [capítulo do Rust Book sobre "
"propriedade](https://doc.rust-lang.org/book/ownership.html)\n"
"deve ser totalmente compreendido antes de avaliar se o clone é necessário ou "
"não."

#: src\anti_patterns/borrow_clone.md:63
#, fuzzy
msgid ""
"Also be sure to always run `cargo clippy` in your project, which will detect "
"some\n"
"cases in which `.clone()` is not necessary, like "
"[1](https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone),\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy),\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone) or "
"[4](https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref)."
msgstr ""
"Certifique-se também de sempre executar `cargo clippy` em seu projeto, o que "
"detectará alguns\n"
"casos em que `.clone()` não é necessário, como "
"[1](https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone),\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy),\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone) ou "
"[4](https://rust-lang.github.io/rust-clippy/master "
"/index.html#clone_double_ref)."

#: src\anti_patterns/borrow_clone.md:70
#, fuzzy
msgid ""
"- [`mem::{take(_), replace(_)}` to keep owned values in changed "
"enums](../idioms/mem-replace.md)\n"
"- [`Rc<T>` documentation, which handles .clone() "
"intelligently](http://doc.rust-lang.org/std/rc/)\n"
"- [`Arc<T>` documentation, a thread-safe reference-counting "
"pointer](https://doc.rust-lang.org/std/sync/struct.Arc.html)\n"
"- [Tricks with ownership in "
"Rust](https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)"
msgstr ""
"- [`mem::{take(_), replace(_)}` para manter os valores de propriedade em "
"enums alterados](../idioms/mem-replace.md)\n"
"- [documentação `Rc<T>`, que lida com .clone() de forma "
"inteligente](http://doc.rust-lang.org/std/rc/)\n"
"- [Documentação do `Arc<T>`, um ponteiro de contagem de referência "
"thread-safe](https://doc.rust-lang.org/std/sync/struct.Arc.html)\n"
"- [Truques com propriedade em "
"Rust](https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)"

#: src\anti_patterns/deny-warnings.md:1
#, fuzzy
msgid "# `#![deny(warnings)]`"
msgstr "# `#![negar(avisos)]`"

#: src\anti_patterns/deny-warnings.md:5
#, fuzzy
msgid ""
"A well-intentioned crate author wants to ensure their code builds without\n"
"warnings. So they annotate their crate root with the following:"
msgstr ""
"Um criador de caixas bem-intencionado quer garantir que seu código seja "
"construído sem\n"
"avisos. Então, eles anotam a raiz da caixa com o seguinte:"

#: src\anti_patterns/deny-warnings.md:10
msgid ""
"```rust\n"
"#![deny(warnings)]\n"
"\n"
"// All is well.\n"
"```"
msgstr ""

#: src\anti_patterns/deny-warnings.md:18
#, fuzzy
msgid "It is short and will stop the build if anything is amiss."
msgstr "É curto e interromperá a construção se algo estiver errado."

#: src\anti_patterns/deny-warnings.md:20
#, fuzzy
msgid "## Drawbacks"
msgstr "## Desvantagens"

#: src\anti_patterns/deny-warnings.md:22
#, fuzzy
msgid ""
"By disallowing the compiler to build with warnings, a crate author opts out "
"of\n"
"Rust's famed stability. Sometimes new features or old misfeatures need a "
"change\n"
"in how things are done, thus lints are written that `warn` for a certain "
"grace\n"
"period before being turned to `deny`."
msgstr ""
"Ao não permitir que o compilador construa com avisos, um autor de caixa opta "
"por não\n"
"A famosa estabilidade de Rust. Às vezes, novos recursos ou antigos erros "
"precisam de uma mudança\n"
"em como as coisas são feitas, assim são escritos lints que 'advertem' para "
"uma certa graça\n"
"período antes de ser transformado em `negar`."

#: src\anti_patterns/deny-warnings.md:27
#, fuzzy
msgid ""
"For example, it was discovered that a type could have two `impl`s with the "
"same\n"
"method. This was deemed a bad idea, but in order to make the transition "
"smooth,\n"
"the `overlapping-inherent-impls` lint was introduced to give a warning to "
"those\n"
"stumbling on this fact, before it becomes a hard error in a future release."
msgstr ""
"Por exemplo, descobriu-se que um tipo poderia ter dois `impl`s com o mesmo\n"
"método. Isso foi considerado uma má ideia, mas para tornar a transição "
"suave,\n"
"o lint `overlapping-inherent-impls` foi introduzido para dar um aviso "
"àqueles\n"
"tropeçando nesse fato, antes que se torne um erro grave em uma versão futura."

#: src\anti_patterns/deny-warnings.md:32
#, fuzzy
msgid ""
"Also sometimes APIs get deprecated, so their use will emit a warning where\n"
"before there was none."
msgstr ""
"Às vezes, as APIs ficam obsoletas, portanto, seu uso emitirá um aviso onde\n"
"antes não havia nenhum."

#: src\anti_patterns/deny-warnings.md:35
#, fuzzy
msgid ""
"All this conspires to potentially break the build whenever something changes."
msgstr ""
"Tudo isso conspira para potencialmente quebrar a construção sempre que algo "
"mudar."

#: src\anti_patterns/deny-warnings.md:37
#, fuzzy
msgid ""
"Furthermore, crates that supply additional lints (e.g. [rust-clippy]) can "
"no\n"
"longer be used unless the annotation is removed. This is mitigated with\n"
"[--cap-lints]. The `--cap-lints=warn` command line argument, turns all "
"`deny`\n"
"lint errors into warnings."
msgstr ""
"Além disso, as caixas que fornecem fiapos adicionais (por exemplo, "
"[ferrugem-clippy]) não podem\n"
"não será mais usado, a menos que a anotação seja removida. Isso é mitigado "
"com\n"
"[--cap-lints]. O argumento de linha de comando `--cap-lints=warn` transforma "
"todos os `deny`\n"
"erros lint em avisos."

#: src\anti_patterns/deny-warnings.md:42
#: src\functional/generics-type-classes.md:227
#, fuzzy
msgid "## Alternatives"
msgstr "## Alternativas"

#: src\anti_patterns/deny-warnings.md:44
#, fuzzy
msgid ""
"There are two ways of tackling this problem: First, we can decouple the "
"build\n"
"setting from the code, and second, we can name the lints we want to deny\n"
"explicitly."
msgstr ""
"Existem duas maneiras de lidar com esse problema: primeiro, podemos "
"desacoplar a construção\n"
"configuração do código e, segundo, podemos nomear os lints que queremos "
"negar\n"
"explicitamente."

#: src\anti_patterns/deny-warnings.md:48
#, fuzzy
msgid "The following command line will build with all warnings set to `deny`:"
msgstr ""
"A linha de comando a seguir será criada com todos os avisos definidos como "
"`deny`:"

#: src\anti_patterns/deny-warnings.md:50
#, fuzzy
msgid "`RUSTFLAGS=\"-D warnings\" cargo build`"
msgstr "`RUSTFLAGS=\"-D warnings\" construção de carga`"

#: src\anti_patterns/deny-warnings.md:52
#, fuzzy
msgid ""
"This can be done by any individual developer (or be set in a CI tool like\n"
"Travis, but remember that this may break the build when something changes)\n"
"without requiring a change to the code."
msgstr ""
"Isso pode ser feito por qualquer desenvolvedor individual (ou pode ser "
"configurado em uma ferramenta CI como\n"
"Travis, mas lembre-se que isso pode quebrar a construção quando algo mudar)\n"
"sem exigir alteração no código."

#: src\anti_patterns/deny-warnings.md:56
#, fuzzy
msgid ""
"Alternatively, we can specify the lints that we want to `deny` in the code.\n"
"Here is a list of warning lints that is (hopefully) safe to deny (as of "
"Rustc 1.48.0):"
msgstr ""
"Como alternativa, podemos especificar os lints que queremos `negar` no "
"código.\n"
"Aqui está uma lista de lints de aviso que é (espero) seguro negar (a partir "
"de Rustc 1.48.0):"

#: src\anti_patterns/deny-warnings.md:59
msgid ""
"```rust,ignore\n"
"#![deny(bad_style,\n"
"       const_err,\n"
"       dead_code,\n"
"       improper_ctypes,\n"
"       non_shorthand_field_patterns,\n"
"       no_mangle_generic_items,\n"
"       overflowing_literals,\n"
"       path_statements,\n"
"       patterns_in_fns_without_body,\n"
"       private_in_public,\n"
"       unconditional_recursion,\n"
"       unused,\n"
"       unused_allocation,\n"
"       unused_comparisons,\n"
"       unused_parens,\n"
"       while_true)]\n"
"```"
msgstr ""

#: src\anti_patterns/deny-warnings.md:78
#, fuzzy
msgid "In addition, the following `allow`ed lints may be a good idea to `deny`:"
msgstr ""
"Além disso, os seguintes lints permitidos podem ser uma boa ideia para negar:"

#: src\anti_patterns/deny-warnings.md:80
msgid ""
"```rust,ignore\n"
"#![deny(missing_debug_implementations,\n"
"       missing_docs,\n"
"       trivial_casts,\n"
"       trivial_numeric_casts,\n"
"       unused_extern_crates,\n"
"       unused_import_braces,\n"
"       unused_qualifications,\n"
"       unused_results)]\n"
"```"
msgstr ""

#: src\anti_patterns/deny-warnings.md:91
#, fuzzy
msgid "Some may also want to add `missing-copy-implementations` to their list."
msgstr ""
"Alguns também podem querer adicionar `missing-copy-implementations` à sua "
"lista."

#: src\anti_patterns/deny-warnings.md:93
#, fuzzy
msgid ""
"Note that we explicitly did not add the `deprecated` lint, as it is fairly\n"
"certain that there will be more deprecated APIs in the future."
msgstr ""
"Observe que não adicionamos explicitamente o lint `obsoleto`, pois é "
"bastante\n"
"certo de que haverá mais APIs obsoletas no futuro."

#: src\anti_patterns/deny-warnings.md:98
#, fuzzy
msgid ""
"- [A collection of all clippy "
"lints](https://rust-lang.github.io/rust-clippy/master)\n"
"- [deprecate attribute] documentation\n"
"- Type `rustc -W help` for a list of lints on your system. Also type\n"
"  `rustc --help` for a general list of options\n"
"- [rust-clippy] is a collection of lints for better Rust code"
msgstr ""
"- [Uma coleção de todos os lints "
"clippy](https://rust-lang.github.io/rust-clippy/master)\n"
"- [atributo obsoleto] documentação\n"
"- Digite `rustc -W help` para obter uma lista de lints em seu sistema. "
"Digite também\n"
"  `rustc --help` para uma lista geral de opções\n"
"- [rust-clippy] é uma coleção de lints para melhorar o código Rust"

#: src\anti_patterns/deref.md:1
#, fuzzy
msgid "# `Deref` polymorphism"
msgstr "# Polimorfismo `Deref`"

#: src\anti_patterns/deref.md:5
#, fuzzy
msgid ""
"Misuse the `Deref` trait to emulate inheritance between structs, and thus "
"reuse\n"
"methods."
msgstr ""
"Use mal o trait `Deref` para emular a herança entre structs e, assim, "
"reutilizar\n"
"métodos."

#: src\anti_patterns/deref.md:10
#, fuzzy
msgid ""
"Sometimes we want to emulate the following common pattern from OO languages "
"such\n"
"as Java:"
msgstr ""
"Às vezes, queremos emular o seguinte padrão comum de linguagens OO, como\n"
"como Java:"

#: src\anti_patterns/deref.md:13
msgid ""
"```java\n"
"class Foo {\n"
"    void m() { ... }\n"
"}\n"
"\n"
"class Bar extends Foo {}\n"
"\n"
"public static void main(String[] args) {\n"
"    Bar b = new Bar();\n"
"    b.m();\n"
"}\n"
"```"
msgstr ""

#: src\anti_patterns/deref.md:26
#, fuzzy
msgid "We can use the deref polymorphism anti-pattern to do so:"
msgstr "Podemos usar o antipadrão de polimorfismo deref para fazer isso:"

#: src\anti_patterns/deref.md:28
msgid ""
"```rust\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"impl Foo {\n"
"    fn m(&self) {\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"struct Bar {\n"
"    f: Foo,\n"
"}\n"
"\n"
"impl Deref for Bar {\n"
"    type Target = Foo;\n"
"    fn deref(&self) -> &Foo {\n"
"        &self.f\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar { f: Foo {} };\n"
"    b.m();\n"
"}\n"
"```"
msgstr ""

#: src\anti_patterns/deref.md:56
#, fuzzy
msgid ""
"There is no struct inheritance in Rust. Instead we use composition and "
"include\n"
"an instance of `Foo` in `Bar` (since the field is a value, it is stored "
"inline,\n"
"so if there were fields, they would have the same layout in memory as the "
"Java\n"
"version (probably, you should use `#[repr(C)]` if you want to be sure))."
msgstr ""
"Não há herança de struct no Rust. Em vez disso, usamos composição e "
"incluímos\n"
"uma instância de `Foo` em `Bar` (como o campo é um valor, ele é armazenado "
"em linha,\n"
"portanto, se houvesse campos, eles teriam o mesmo layout na memória que o "
"Java\n"
"versão (provavelmente, você deve usar `#[repr(C)]` se quiser ter certeza))."

#: src\anti_patterns/deref.md:61
#, fuzzy
msgid ""
"In order to make the method call work we implement `Deref` for `Bar` with "
"`Foo`\n"
"as the target (returning the embedded `Foo` field). That means that when we\n"
"dereference a `Bar` (for example, using `*`) then we will get a `Foo`. That "
"is\n"
"pretty weird. Dereferencing usually gives a `T` from a reference to `T`, "
"here we\n"
"have two unrelated types. However, since the dot operator does implicit\n"
"dereferencing, it means that the method call will search for methods on "
"`Foo` as\n"
"well as `Bar`."
msgstr ""
"Para fazer a chamada do método funcionar, implementamos `Deref` para `Bar` "
"com `Foo`\n"
"como o destino (retornando o campo `Foo` incorporado). Isso significa que "
"quando nós\n"
"desreferenciar um `Bar` (por exemplo, usando `*`) então obteremos um `Foo`. "
"Aquilo é\n"
"bem estranho. Desreferenciar geralmente dá um `T` de uma referência a `T`, "
"aqui nós\n"
"têm dois tipos não relacionados. No entanto, como o operador ponto "
"implícito\n"
"desreferenciação, isso significa que a chamada do método irá procurar "
"métodos em `Foo` como\n"
"bem como 'Bar'."

#: src\anti_patterns/deref.md:71
#, fuzzy
msgid "You save a little boilerplate, e.g.,"
msgstr "Você economiza um pouco clichê, por exemplo,"

#: src\anti_patterns/deref.md:73
msgid ""
"```rust,ignore\n"
"impl Bar {\n"
"    fn m(&self) {\n"
"        self.f.m()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\anti_patterns/deref.md:83
#, fuzzy
msgid ""
"Most importantly this is a surprising idiom - future programmers reading "
"this in\n"
"code will not expect this to happen. That's because we are misusing the "
"`Deref`\n"
"trait rather than using it as intended (and documented, etc.). It's also "
"because\n"
"the mechanism here is completely implicit."
msgstr ""
"Mais importante, este é um idioma surpreendente - futuros programadores "
"lendo isso em\n"
"código não espera que isso aconteça. Isso porque estamos usando mal o "
"`Deref`\n"
"traço em vez de usá-lo como pretendido (e documentado, etc.). é também "
"porque\n"
"o mecanismo aqui é completamente implícito."

#: src\anti_patterns/deref.md:88
#, fuzzy
msgid ""
"This pattern does not introduce subtyping between `Foo` and `Bar` like\n"
"inheritance in Java or C++ does. Furthermore, traits implemented by `Foo` "
"are\n"
"not automatically implemented for `Bar`, so this pattern interacts badly "
"with\n"
"bounds checking and thus generic programming."
msgstr ""
"Este padrão não introduz subtipagem entre `Foo` e `Bar` como\n"
"herança em Java ou C++ faz. Além disso, as características implementadas por "
"`Foo` são\n"
"não implementado automaticamente para `Bar`, então este padrão interage mal "
"com\n"
"verificação de limites e, portanto, programação genérica."

#: src\anti_patterns/deref.md:93
#, fuzzy
msgid ""
"Using this pattern gives subtly different semantics from most OO languages "
"with\n"
"regards to `self`. Usually it remains a reference to the sub-class, with "
"this\n"
"pattern it will be the 'class' where the method is defined."
msgstr ""
"O uso desse padrão fornece uma semântica sutilmente diferente da maioria das "
"linguagens OO com\n"
"diz respeito a 'eu'. Normalmente permanece uma referência à subclasse, com "
"este\n"
"pattern será a 'classe' onde o método é definido."

#: src\anti_patterns/deref.md:97
#, fuzzy
msgid ""
"Finally, this pattern only supports single inheritance, and has no notion "
"of\n"
"interfaces, class-based privacy, or other inheritance-related features. So, "
"it\n"
"gives an experience that will be subtly surprising to programmers used to "
"Java\n"
"inheritance, etc."
msgstr ""
"Por fim, esse padrão suporta apenas herança única e não tem noção de\n"
"interfaces, privacidade baseada em classe ou outros recursos relacionados à "
"herança. Então, é\n"
"oferece uma experiência que surpreenderá sutilmente os programadores "
"acostumados com Java\n"
"herança, etc"

#: src\anti_patterns/deref.md:104
#, fuzzy
msgid ""
"There is no one good alternative. Depending on the exact circumstances it "
"might\n"
"be better to re-implement using traits or to write out the facade methods "
"to\n"
"dispatch to `Foo` manually. We do intend to add a mechanism for inheritance\n"
"similar to this to Rust, but it is likely to be some time before it reaches\n"
"stable Rust. See these "
"[blog](http://aturon.github.io/blog/2015/09/18/reuse/)\n"
"[posts](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/)\n"
"and this [RFC issue](https://github.com/rust-lang/rfcs/issues/349) for more "
"details."
msgstr ""
"Não há uma boa alternativa. Dependendo das circunstâncias exatas, pode\n"
"seria melhor reimplementar usando traits ou escrever os métodos de fachada "
"para\n"
"despachar para `Foo` manualmente. Pretendemos adicionar um mecanismo para "
"herança\n"
"semelhante a isso para Rust, mas é provável que demore algum tempo antes de "
"atingir\n"
"ferrugem estável. Veja estes "
"[blog](http://aturon.github.io/blog/2015/09/18/reuse/)\n"
"[postagens](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/)\n"
"e este [problema RFC](https://github.com/rust-lang/rfcs/issues/349) para "
"mais detalhes."

#: src\anti_patterns/deref.md:112
#, fuzzy
msgid ""
"The `Deref` trait is designed for the implementation of custom pointer "
"types.\n"
"The intention is that it will take a pointer-to-`T` to a `T`, not convert\n"
"between different types. It is a shame that this isn't (probably cannot be)\n"
"enforced by the trait definition."
msgstr ""
"O trait `Deref` é projetado para a implementação de tipos de ponteiro "
"personalizados.\n"
"A intenção é que ele leve um ponteiro para `T` para um `T`, não converta\n"
"entre diferentes tipos. É uma pena que isso não seja (provavelmente não pode "
"ser)\n"
"imposta pela definição do traço."

#: src\anti_patterns/deref.md:117
#, fuzzy
msgid ""
"Rust tries to strike a careful balance between explicit and implicit "
"mechanisms,\n"
"favouring explicit conversions between types. Automatic dereferencing in the "
"dot\n"
"operator is a case where the ergonomics strongly favour an implicit "
"mechanism,\n"
"but the intention is that this is limited to degrees of indirection, not\n"
"conversion between arbitrary types."
msgstr ""
"Rust tenta encontrar um equilíbrio cuidadoso entre mecanismos explícitos e "
"implícitos,\n"
"favorecendo conversões explícitas entre tipos. Desreferenciamento automático "
"no ponto\n"
"operador é um caso onde a ergonomia favorece fortemente um mecanismo "
"implícito,\n"
"mas a intenção é que isso seja limitado a graus de indireção, não\n"
"conversão entre tipos arbitrários."

#: src\anti_patterns/deref.md:125
#, fuzzy
msgid ""
"- [Collections are smart pointers idiom](../idioms/deref.md).\n"
"- Delegation crates for less boilerplate like "
"[delegate](https://crates.io/crates/delegate)\n"
"  or [ambassador](https://crates.io/crates/ambassador)\n"
"- [Documentation for `Deref` "
"trait](https://doc.rust-lang.org/std/ops/trait.Deref.html)."
msgstr ""
"- [Coleções são idiomas de ponteiros inteligentes](../idioms/deref.md).\n"
"- Caixas de delegação por menos padrão como "
"[delegate](https://crates.io/crates/delegate)\n"
"  ou [embaixador](https://crates.io/crates/ambassador)\n"
"- [Documentação para o trait "
"`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)."

#: src\functional/index.md:1
#, fuzzy
msgid "# Functional Usage of Rust"
msgstr "# Uso Funcional de Rust"

#: src\functional/index.md:3
#, fuzzy
msgid ""
"Rust is an imperative language, but it follows many\n"
"[functional "
"programming](https://en.wikipedia.org/wiki/Functional_programming) paradigms."
msgstr ""
"A ferrugem é uma linguagem imperativa, mas segue muitas\n"
"[programação "
"funcional](https://en.wikipedia.org/wiki/Functional_programming) paradigmas."

#: src\functional/index.md:6
#, fuzzy
msgid ""
"> In computer science, _functional programming_ is a programming paradigm "
"where\n"
"> programs are constructed by applying and composing functions.\n"
"> It is a declarative programming paradigm in which function definitions "
"are\n"
"> trees of expressions that each return a value, rather than a sequence of\n"
"> imperative statements which change the state of the program."
msgstr ""
"> Em ciência da computação, _programação funcional_ é um paradigma de "
"programação onde\n"
"> os programas são construídos aplicando e compondo funções.\n"
"> É um paradigma de programação declarativa em que as definições de funções "
"são\n"
"> árvores de expressões que retornam um valor, em vez de uma sequência de\n"
"> declarações imperativas que mudam o estado do programa."

#: src\functional/paradigms.md:1
#, fuzzy
msgid "# Programming paradigms"
msgstr "# Paradigmas de programação"

#: src\functional/paradigms.md:3
#, fuzzy
msgid ""
"One of the biggest hurdles to understanding functional programs when coming\n"
"from an imperative background is the shift in thinking. Imperative programs\n"
"describe **how** to do something, whereas declarative programs describe\n"
"**what** to do. Let's sum the numbers from 1 to 10 to show this."
msgstr ""
"Um dos maiores obstáculos para a compreensão dos programas funcionais ao "
"chegar\n"
"de um fundo imperativo é a mudança no pensamento. programas imperativos\n"
"descrevem **como** fazer algo, enquanto os programas declarativos descrevem\n"
"**o que fazer. Vamos somar os números de 1 a 10 para mostrar isso."

#: src\functional/paradigms.md:8
#, fuzzy
msgid "## Imperative"
msgstr "## Imperativo"

#: src\functional/paradigms.md:10
msgid ""
"```rust\n"
"let mut sum = 0;\n"
"for i in 1..11 {\n"
"    sum += i;\n"
"}\n"
"println!(\"{}\", sum);\n"
"```"
msgstr ""

#: src\functional/paradigms.md:18
#, fuzzy
msgid ""
"With imperative programs, we have to play compiler to see what is "
"happening.\n"
"Here, we start with a `sum` of `0`.\n"
"Next, we iterate through the range from 1 to 10.\n"
"Each time through the loop, we add the corresponding value in the range.\n"
"Then we print it out."
msgstr ""
"Com programas imperativos, temos que jogar compilador para ver o que está "
"acontecendo.\n"
"Aqui, começamos com uma `soma` de `0`.\n"
"Em seguida, iteramos pelo intervalo de 1 a 10.\n"
"Cada vez que passamos pelo loop, adicionamos o valor correspondente no "
"intervalo.\n"
"Depois imprimimos."

#: src\functional/paradigms.md:24
#, fuzzy
msgid ""
"| `i` | `sum` |\n"
"| :-: | :---: |\n"
"|  1  |   1   |\n"
"|  2  |   3   |\n"
"|  3  |   6   |\n"
"|  4  |  10   |\n"
"|  5  |  15   |\n"
"|  6  |  21   |\n"
"|  7  |  28   |\n"
"|  8  |  36   |\n"
"|  9  |  45   |\n"
"| 10  |  55   |"
msgstr ""
"| `eu` | `soma` |\n"
"| :-: | :---: |\n"
"| 1 | 1 |\n"
"| 2 | 3 |\n"
"| 3 | 6 |\n"
"| 4 | 10 |\n"
"| 5 | 15 |\n"
"| 6 | 21 |\n"
"| 7 | 28 |\n"
"| 8 | 36 |\n"
"| 9 | 45 |\n"
"| 10 | 55 |"

#: src\functional/paradigms.md:37
#, fuzzy
msgid ""
"This is how most of us start out programming. We learn that a program is a "
"set\n"
"of steps."
msgstr ""
"É assim que a maioria de nós começa a programar. Aprendemos que um programa "
"é um conjunto\n"
"de passos."

#: src\functional/paradigms.md:40
#, fuzzy
msgid "## Declarative"
msgstr "## Declarativo"

#: src\functional/paradigms.md:42
msgid ""
"```rust\n"
"println!(\"{}\", (1..11).fold(0, |a, b| a + b));\n"
"```"
msgstr ""

#: src\functional/paradigms.md:46
#, fuzzy
msgid ""
"Whoa! This is really different! What's going on here?\n"
"Remember that with declarative programs we are describing **what** to do,\n"
"rather than **how** to do it. `fold` is a function that "
"[composes](https://en.wikipedia.org/wiki/Function_composition)\n"
"functions. The name is a convention from Haskell."
msgstr ""
"Uau! Isso é realmente diferente! O que está acontecendo aqui?\n"
"Lembre-se que com programas declarativos estamos descrevendo **o que** "
"fazer,\n"
"em vez de **como** fazer. `fold` é uma função que "
"[compõe](https://en.wikipedia.org/wiki/Function_composition)\n"
"funções. O nome é uma convenção de Haskell."

#: src\functional/paradigms.md:51
#, fuzzy
msgid ""
"Here, we are composing functions of addition (this closure: `|a, b| a + b`)\n"
"with a range from 1 to 10. The `0` is the starting point, so `a` is `0` at\n"
"first. `b` is the first element of the range, `1`. `0 + 1 = 1` is the "
"result.\n"
"So now we `fold` again, with `a = 1`, `b = 2` and so `1 + 2 = 3` is the "
"next\n"
"result. This process continues until we get to the last element in the "
"range,\n"
"`10`."
msgstr ""
"Aqui, estamos compondo funções de adição (este fechamento: `|a, b| a + b`)\n"
"com um intervalo de 1 a 10. O `0` é o ponto de partida, então `a` é `0` em\n"
"primeiro. `b` é o primeiro elemento do intervalo, `1`. `0 + 1 = 1` é o "
"resultado.\n"
"Então agora nós `fold` novamente, com `a = 1`, `b = 2` e então `1 + 2 = 3` é "
"o próximo\n"
"resultado. Esse processo continua até chegarmos ao último elemento do "
"intervalo,\n"
"`10`."

#: src\functional/paradigms.md:58
#, fuzzy
msgid ""
"| `a` | `b` | result |\n"
"| :-: | :-: | :----: |\n"
"|  0  |  1  |   1    |\n"
"|  1  |  2  |   3    |\n"
"|  3  |  3  |   6    |\n"
"|  6  |  4  |   10   |\n"
"| 10  |  5  |   15   |\n"
"| 15  |  6  |   21   |\n"
"| 21  |  7  |   28   |\n"
"| 28  |  8  |   36   |\n"
"| 36  |  9  |   45   |\n"
"| 45  | 10  |   55   |"
msgstr ""
"| `a` | `b` | resultado |\n"
"| :-: | :-: | :----: |\n"
"| 0 | 1 | 1 |\n"
"| 1 | 2 | 3 |\n"
"| 3 | 3 | 6 |\n"
"| 6 | 4 | 10 |\n"
"| 10 | 5 | 15 |\n"
"| 15 | 6 | 21 |\n"
"| 21 | 7 | 28 |\n"
"| 28 | 8 | 36 |\n"
"| 36 | 9 | 45 |\n"
"| 45 | 10 | 55 |"

#: src\functional/generics-type-classes.md:1
#, fuzzy
msgid "# Generics as Type Classes"
msgstr "# Generics as Type Classes"

#: src\functional/generics-type-classes.md:5
#, fuzzy
msgid ""
"Rust's type system is designed more like functional languages (like "
"Haskell)\n"
"rather than imperative languages (like Java and C++). As a result, Rust can "
"turn\n"
"many kinds of programming problems into \"static typing\" problems. This is "
"one\n"
"of the biggest wins of choosing a functional language, and is critical to "
"many\n"
"of Rust's compile time guarantees."
msgstr ""
"O sistema de tipos do Rust é projetado mais como linguagens funcionais (como "
"Haskell)\n"
"em vez de linguagens imperativas (como Java e C++). Como resultado, Rust "
"pode transformar\n"
"muitos tipos de problemas de programação em problemas de \"digitação "
"estática\". Isso é um\n"
"das maiores vitórias de escolher uma linguagem funcional, e é fundamental "
"para muitos\n"
"das garantias de tempo de compilação do Rust."

#: src\functional/generics-type-classes.md:11
#, fuzzy
msgid ""
"A key part of this idea is the way generic types work. In C++ and Java, for\n"
"example, generic types are a meta-programming construct for the compiler.\n"
"`vector<int>` and `vector<char>` in C++ are just two different copies of "
"the\n"
"same boilerplate code for a `vector` type (known as a `template`) with two\n"
"different types filled in."
msgstr ""
"Uma parte fundamental dessa ideia é a maneira como os tipos genéricos "
"funcionam. Em C++ e Java, por\n"
"Por exemplo, os tipos genéricos são uma construção de metaprogramação para o "
"compilador.\n"
"`vector<int>` e `vector<char>` em C++ são apenas duas cópias diferentes do\n"
"mesmo código clichê para um tipo `vector` (conhecido como `template`) com "
"dois\n"
"diferentes tipos preenchidos."

#: src\functional/generics-type-classes.md:17
#, fuzzy
msgid ""
"In Rust, a generic type parameter creates what is known in functional "
"languages\n"
"as a \"type class constraint\", and each different parameter filled in by an "
"end\n"
"user _actually changes the type_. In other words, `Vec<isize>` and "
"`Vec<char>`\n"
"_are two different types_, which are recognized as distinct by all parts of "
"the\n"
"type system."
msgstr ""
"No Rust, um parâmetro de tipo genérico cria o que é conhecido em linguagens "
"funcionais\n"
"como uma \"restrição de classe de tipo\", e cada parâmetro diferente "
"preenchido por um final\n"
"o usuário _realmente muda o tipo_. Em outras palavras, `Vec<isize>` e "
"`Vec<char>`\n"
"_são dois tipos diferentes_, que são reconhecidos como distintos por todas "
"as partes do\n"
"tipo de sistema."

#: src\functional/generics-type-classes.md:23
#, fuzzy
msgid ""
"This is called **monomorphization**, where different types are created from\n"
"**polymorphic** code. This special behavior requires `impl` blocks to "
"specify\n"
"generic parameters. Different values for the generic type cause different "
"types,\n"
"and different types can have different `impl` blocks."
msgstr ""
"Isso é chamado de **monomorfização**, onde diferentes tipos são criados a "
"partir de\n"
"Código **polimórfico**. Este comportamento especial requer blocos `impl` "
"para especificar\n"
"parâmetros genéricos. Valores diferentes para o tipo genérico causam tipos "
"diferentes,\n"
"e diferentes tipos podem ter diferentes blocos `impl`."

#: src\functional/generics-type-classes.md:28
#, fuzzy
msgid ""
"In object-oriented languages, classes can inherit behavior from their "
"parents.\n"
"However, this allows the attachment of not only additional behavior to\n"
"particular members of a type class, but extra behavior as well."
msgstr ""
"Em linguagens orientadas a objetos, as classes podem herdar o comportamento "
"de seus pais.\n"
"No entanto, isso permite a anexação não apenas de comportamento adicional a\n"
"membros particulares de uma classe de tipo, mas comportamento extra também."

#: src\functional/generics-type-classes.md:32
#, fuzzy
msgid ""
"The nearest equivalent is the runtime polymorphism in Javascript and "
"Python,\n"
"where new members can be added to objects willy-nilly by any constructor.\n"
"However, unlike those languages, all of Rust's additional methods can be "
"type\n"
"checked when they are used, because their generics are statically defined. "
"That\n"
"makes them more usable while remaining safe."
msgstr ""
"O equivalente mais próximo é o polimorfismo de tempo de execução em "
"Javascript e Python,\n"
"onde novos membros podem ser adicionados a objetos por qualquer construtor.\n"
"No entanto, ao contrário dessas linguagens, todos os métodos adicionais do "
"Rust podem ser digitados\n"
"verificados quando são usados, porque seus genéricos são definidos "
"estaticamente. Que\n"
"torna-os mais utilizáveis enquanto permanecem seguros."

#: src\functional/generics-type-classes.md:40
#, fuzzy
msgid ""
"Suppose you are designing a storage server for a series of lab machines.\n"
"Because of the software involved, there are two different protocols you "
"need\n"
"to support: BOOTP (for PXE network boot), and NFS (for remote mount storage)."
msgstr ""
"Suponha que você esteja projetando um servidor de armazenamento para uma "
"série de máquinas de laboratório.\n"
"Devido ao software envolvido, existem dois protocolos diferentes que você "
"precisa\n"
"para suportar: BOOTP (para inicialização de rede PXE) e NFS (para "
"armazenamento de montagem remota)."

#: src\functional/generics-type-classes.md:44
#, fuzzy
msgid ""
"Your goal is to have one program, written in Rust, which can handle both of\n"
"them. It will have protocol handlers and listen for both kinds of requests. "
"The\n"
"main application logic will then allow a lab administrator to configure "
"storage\n"
"and security controls for the actual files."
msgstr ""
"Seu objetivo é ter um programa, escrito em Rust, que possa lidar com ambos\n"
"eles. Ele terá manipuladores de protocolo e escutará ambos os tipos de "
"solicitações. O\n"
"a lógica do aplicativo principal permitirá que um administrador de "
"laboratório configure o armazenamento\n"
"e controles de segurança para os arquivos reais."

#: src\functional/generics-type-classes.md:49
#, fuzzy
msgid ""
"The requests from machines in the lab for files contain the same basic\n"
"information, no matter what protocol they came from: an authentication "
"method,\n"
"and a file name to retrieve. A straightforward implementation would look\n"
"something like this:"
msgstr ""
"As solicitações de máquinas no laboratório para arquivos contêm o mesmo "
"básico\n"
"informações, independentemente do protocolo de onde vieram: um método de "
"autenticação,\n"
"e um nome de arquivo para recuperar. Uma implementação direta pareceria\n"
"algo assim:"

#: src\functional/generics-type-classes.md:54
msgid ""
"```rust,ignore\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo),\n"
"    Bootp(crate::bootp::AuthInfo),\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"}\n"
"```"
msgstr ""

#: src\functional/generics-type-classes.md:66
#, fuzzy
msgid ""
"This design might work well enough. But now suppose you needed to support\n"
"adding metadata that was _protocol specific_. For example, with NFS, you\n"
"wanted to determine what their mount point was in order to enforce "
"additional\n"
"security rules."
msgstr ""
"Este design pode funcionar bem o suficiente. Mas agora suponha que você "
"precise apoiar\n"
"adicionando metadados que eram _protocolos específicos_. Por exemplo, com o "
"NFS, você\n"
"queria determinar qual era o seu ponto de montagem para impor\n"
"regras de segurança."

#: src\functional/generics-type-classes.md:71
#, fuzzy
msgid ""
"The way the current struct is designed leaves the protocol decision until\n"
"runtime. That means any method that applies to one protocol and not the "
"other\n"
"requires the programmer to do a runtime check."
msgstr ""
"A maneira como a estrutura atual é projetada deixa a decisão do protocolo "
"até\n"
"tempo de execução. Isso significa qualquer método que se aplique a um "
"protocolo e não ao outro\n"
"requer que o programador faça uma verificação de tempo de execução."

#: src\functional/generics-type-classes.md:75
#, fuzzy
msgid "Here is how getting an NFS mount point would look:"
msgstr "Aqui está como obter um ponto de montagem NFS seria:"

#: src\functional/generics-type-classes.md:77
msgid ""
"```rust,ignore\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"    mount_point: Option<PathBuf>,\n"
"}\n"
"\n"
"impl FileDownloadRequest {\n"
"    // ... other methods ...\n"
"\n"
"    /// Gets an NFS mount point if this is an NFS request. Otherwise,\n"
"    /// return None.\n"
"    pub fn mount_point(&self) -> Option<&Path> {\n"
"        self.mount_point.as_ref()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\functional/generics-type-classes.md:95
#, fuzzy
msgid ""
"Every caller of `mount_point()` must check for `None` and write code to "
"handle\n"
"it. This is true even if they know only NFS requests are ever used in a "
"given\n"
"code path!"
msgstr ""
"Todo chamador de `mount_point()` deve verificar `None` e escrever o código "
"para manipular\n"
"isto. Isso é verdade mesmo que eles saibam que apenas solicitações NFS são "
"usadas em um determinado\n"
"caminho do código!"

#: src\functional/generics-type-classes.md:99
#, fuzzy
msgid ""
"It would be far more optimal to cause a compile-time error if the different\n"
"request types were confused. After all, the entire path of the user's code,\n"
"including what functions from the library they use, will know whether a "
"request\n"
"is an NFS request or a BOOTP request."
msgstr ""
"Seria muito mais ideal causar um erro de tempo de compilação se os "
"diferentes\n"
"os tipos de solicitação eram confusos. Afinal, todo o caminho do código do "
"usuário,\n"
"incluindo quais funções da biblioteca eles usam, saberão se uma solicitação\n"
"é uma solicitação NFS ou uma solicitação BOOTP."

#: src\functional/generics-type-classes.md:104
#, fuzzy
msgid ""
"In Rust, this is actually possible! The solution is to _add a generic type_ "
"in\n"
"order to split the API."
msgstr ""
"No Rust, isso é realmente possível! A solução é _adicionar um tipo genérico_ "
"em\n"
"para dividir a API."

#: src\functional/generics-type-classes.md:107
#, fuzzy
msgid "Here is what that looks like:"
msgstr "Aqui está o que parece:"

#: src\functional/generics-type-classes.md:109
msgid ""
"```rust\n"
"use std::path::{Path, PathBuf};\n"
"\n"
"mod nfs {\n"
"    #[derive(Clone)]\n"
"    pub(crate) struct AuthInfo(String); // NFS session management omitted\n"
"}\n"
"\n"
"mod bootp {\n"
"    pub(crate) struct AuthInfo(); // no authentication in bootp\n"
"}\n"
"\n"
"// private module, lest outside users invent their own protocol kinds!\n"
"mod proto_trait {\n"
"    use std::path::{Path, PathBuf};\n"
"    use super::{bootp, nfs};\n"
"\n"
"    pub(crate) trait ProtoKind {\n"
"        type AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo;\n"
"    }\n"
"\n"
"    pub struct Nfs {\n"
"        auth: nfs::AuthInfo,\n"
"        mount_point: PathBuf,\n"
"    }\n"
"\n"
"    impl Nfs {\n"
"        pub(crate) fn mount_point(&self) -> &Path {\n"
"            &self.mount_point\n"
"        }\n"
"    }\n"
"\n"
"    impl ProtoKind for Nfs {\n"
"        type AuthInfo = nfs::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            self.auth.clone()\n"
"        }\n"
"    }\n"
"\n"
"    pub struct Bootp(); // no additional metadata\n"
"\n"
"    impl ProtoKind for Bootp {\n"
"        type AuthInfo = bootp::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            bootp::AuthInfo()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"use proto_trait::ProtoKind; // keep internal to prevent impls\n"
"pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them\n"
"\n"
"struct FileDownloadRequest<P: ProtoKind> {\n"
"    file_name: PathBuf,\n"
"    protocol: P,\n"
"}\n"
"\n"
"// all common API parts go into a generic impl block\n"
"impl<P: ProtoKind> FileDownloadRequest<P> {\n"
"    fn file_path(&self) -> &Path {\n"
"        &self.file_name\n"
"    }\n"
"\n"
"    fn auth_info(&self) -> P::AuthInfo {\n"
"        self.protocol.auth_info()\n"
"    }\n"
"}\n"
"\n"
"// all protocol-specific impls go into their own block\n"
"impl FileDownloadRequest<Nfs> {\n"
"    fn mount_point(&self) -> &Path {\n"
"        self.protocol.mount_point()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // your code here\n"
"}\n"
"```"
msgstr ""

#: src\functional/generics-type-classes.md:190
msgid ""
"With this approach, if the user were to make a mistake and use the wrong\n"
"type;"
msgstr ""

#: src\functional/generics-type-classes.md:193
msgid ""
"```rust,ignore\n"
"fn main() {\n"
"    let mut socket = crate::bootp::listen()?;\n"
"    while let Some(request) = socket.next_request()? {\n"
"        match request.mount_point().as_ref()\n"
"            \"/secure\" => socket.send(\"Access denied\"),\n"
"            _ => {} // continue on...\n"
"        }\n"
"        // Rest of the code here\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src\functional/generics-type-classes.md:206
#, fuzzy
msgid ""
"They would get a syntax error. The type `FileDownloadRequest<Bootp>` does "
"not\n"
"implement `mount_point()`, only the type `FileDownloadRequest<Nfs>` does. "
"And\n"
"that is created by the NFS module, not the BOOTP module of course!"
msgstr ""
"Eles receberiam um erro de sintaxe. O tipo `FileDownloadRequest<Bootp>` não\n"
"implementar `mount_point()`, apenas o tipo `FileDownloadRequest<Nfs>` o faz. "
"E\n"
"que é criado pelo módulo NFS, não pelo módulo BOOTP, é claro!"

#: src\functional/generics-type-classes.md:212
#, fuzzy
msgid ""
"First, it allows fields that are common to multiple states to be "
"de-duplicated.\n"
"By making the non-shared fields generic, they are implemented once."
msgstr ""
"Primeiro, permite que os campos comuns a vários estados sejam "
"desduplicados.\n"
"Ao tornar os campos não compartilhados genéricos, eles são implementados uma "
"vez."

#: src\functional/generics-type-classes.md:215
#, fuzzy
msgid ""
"Second, it makes the `impl` blocks easier to read, because they are broken "
"down\n"
"by state. Methods common to all states are typed once in one block, and "
"methods\n"
"unique to one state are in a separate block."
msgstr ""
"Em segundo lugar, torna os blocos `impl` mais fáceis de ler, porque eles são "
"divididos\n"
"por estado. Os métodos comuns a todos os estados são digitados uma vez em um "
"bloco e os métodos\n"
"exclusivos para um estado estão em um bloco separado."

#: src\functional/generics-type-classes.md:219
#, fuzzy
msgid ""
"Both of these mean there are fewer lines of code, and they are better "
"organized."
msgstr ""
"Ambos significam que há menos linhas de código e são mais bem organizados."

#: src\functional/generics-type-classes.md:223
#, fuzzy
msgid ""
"This currently increases the size of the binary, due to the way "
"monomorphization\n"
"is implemented in the compiler. Hopefully the implementation will be able "
"to\n"
"improve in the future."
msgstr ""
"Isso atualmente aumenta o tamanho do binário, devido à forma como a "
"monomorfização\n"
"é implementado no compilador. Esperamos que a implementação seja capaz de\n"
"melhorar no futuro."

#: src\functional/generics-type-classes.md:229
#, fuzzy
msgid ""
"- If a type seems to need a \"split API\" due to construction or partial\n"
"  initialization, consider the\n"
"  [Builder Pattern](../patterns/creational/builder.md) instead.\n"
"\n"
"- If the API between types does not change -- only the behavior does -- "
"then\n"
"  the [Strategy Pattern](../patterns/behavioural/strategy.md) is better "
"used\n"
"  instead."
msgstr ""
"- Se um tipo parecer precisar de uma \"API dividida\" devido à construção "
"ou\n"
"  inicialização, considere o\n"
"  [Padrão do construtor](../patterns/creational/builder.md) em vez disso.\n"
"\n"
"- Se a API entre os tipos não mudar -- apenas o comportamento muda -- então\n"
"  o [Padrão de Estratégia](../patterns/behavioural/strategy.md) é melhor "
"usado\n"
"  em vez de."

#: src\functional/generics-type-classes.md:239
#, fuzzy
msgid "This pattern is used throughout the standard library:"
msgstr "Este padrão é usado em toda a biblioteca padrão:"

#: src\functional/generics-type-classes.md:241
#, fuzzy
msgid ""
"- `Vec<u8>` can be cast from a String, unlike every other type of "
"`Vec<T>`.[^1]\n"
"- They can also be cast into a binary heap, but only if they contain a type\n"
"  that implements the `Ord` trait.[^2]\n"
"- The `to_string` method was specialized for `Cow` only of type `str`.[^3]"
msgstr ""
"- `Vec<u8>` pode ser lançado a partir de uma String, ao contrário de "
"qualquer outro tipo de `Vec<T>`.[^1]\n"
"- Eles também podem ser lançados em um heap binário, mas apenas se "
"contiverem um tipo\n"
"  que implementa o traço `Ord`.[^2]\n"
"- O método `to_string` foi especializado para `Cow` apenas do tipo `str`.[^3]"

#: src\functional/generics-type-classes.md:246
#, fuzzy
msgid "It is also used by several popular crates to allow API flexibility:"
msgstr ""
"Ele também é usado por várias caixas populares para permitir a flexibilidade "
"da API:"

#: src\functional/generics-type-classes.md:248
#, fuzzy
msgid ""
"- The `embedded-hal` ecosystem used for embedded devices makes extensive use "
"of\n"
"  this pattern. For example, it allows statically verifying the "
"configuration of\n"
"  device registers used to control embedded pins. When a pin is put into a "
"mode,\n"
"  it returns a `Pin<MODE>` struct, whose generic determines the functions\n"
"  usable in that mode, which are not on the `Pin` itself. [^4]\n"
"\n"
"- The `hyper` HTTP client library uses this to expose rich APIs for "
"different\n"
"  pluggable requests. Clients with different connectors have different "
"methods\n"
"  on them as well as different trait implementations, while a core set of\n"
"  methods apply to any connector. [^5]\n"
"\n"
"- The \"type state\" pattern -- where an object gains and loses API based on "
"an\n"
"  internal state or invariant -- is implemented in Rust using the same "
"basic\n"
"  concept, and a slightly different technique. [^6]"
msgstr ""
"- O ecossistema `embedded-hal` usado para dispositivos embarcados faz uso "
"extensivo de\n"
"  esse padrão. Por exemplo, permite verificar estaticamente a configuração "
"de\n"
"  registradores de dispositivos usados para controlar pinos embutidos. "
"Quando um pino é colocado em um modo,\n"
"  ele retorna uma estrutura `Pin<MODE>`, cujo genérico determina as funções\n"
"  utilizáveis nesse modo, que não estão no próprio `Pin`. [^4]\n"
"\n"
"- A biblioteca de cliente `hiper` HTTP usa isso para expor APIs ricas para "
"diferentes\n"
"  solicitações conectáveis. Clientes com conectores diferentes têm métodos "
"diferentes\n"
"  sobre eles, bem como implementações de características diferentes, "
"enquanto um conjunto básico de\n"
"  Os métodos se aplicam a qualquer conector. [^5]\n"
"\n"
"- O padrão \"tipo de estado\" -- onde um objeto ganha e perde API com base "
"em um\n"
"  estado interno ou invariante -- é implementado em Rust usando o mesmo\n"
"  conceito e uma técnica ligeiramente diferente. [^6]"

#: src\functional/generics-type-classes.md:263
#, fuzzy
msgid ""
"See: [impl From\\<CString\\> for "
"Vec\\<u8\\>](https://doc.rust-lang.org/1.59.0/src/std/ffi/c_str.rs.html#803-811)"
msgstr ""
"Veja: [impl From\\<CString\\> for "
"Vec\\<u8\\>](https://doc.rust-lang.org/1.59.0/src/std/ffi/c_str.rs.html#803-811 "
")"

#: src\functional/generics-type-classes.md:265
#, fuzzy
msgid ""
"See: [impl\\<T\\> From\\<Vec\\<T, Global\\>\\> for "
"BinaryHeap\\<T\\>](https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354)"
msgstr ""
"Veja: [impl\\<T\\> From\\<Vec\\<T, Global\\>\\> for "
"BinaryHeap\\<T\\>](https://doc.rust-lang.org/stable/src/alloc/collections "
"/binary_heap.rs.html#1345-1354)"

#: src\functional/generics-type-classes.md:267
#, fuzzy
msgid ""
"See: [impl\\<'\\_\\> ToString for Cow\\<'\\_, "
"str>](https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2235-2240)"
msgstr ""
"Veja: [impl\\<'\\_\\> ToString for Cow\\<'\\_, "
"str>](https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2235- 2240)"

#: src\functional/generics-type-classes.md:269
#, fuzzy
msgid ""
"Example:\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html)"
msgstr ""
"Exemplo:\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/ "
"gpioa/struct.PA0.html)"

#: src\functional/generics-type-classes.md:272
#, fuzzy
msgid ""
"See:\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html)"
msgstr ""
"Ver:\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html)"

#: src\functional/generics-type-classes.md:275
#, fuzzy
msgid ""
"See:\n"
"[The Case for the Type State "
"Pattern](https://web.archive.org/web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-pattern-itself/)\n"
"and\n"
"[Rusty Typestate Series (an extensive "
"thesis)](https://web.archive.org/web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index)"
msgstr ""
"Ver:\n"
"[O caso para o padrão de estado de "
"tipo](https://web.archive.org/web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-typestate- "
"padrão-o-tipo-estado-padrão-em-si/)\n"
"e\n"
"[Série Rusty Typestate (uma tese "
"extensa)](https://web.archive.org/web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index "
")"

#: src\functional/lenses.md:1
#, fuzzy
msgid "# Lenses and Prisms"
msgstr "# Lentes e Prismas"

#: src\functional/lenses.md:3
#, fuzzy
msgid ""
"This is a pure functional concept that is not frequently used in Rust.\n"
"Nevertheless, exploring the concept may be helpful to understand other\n"
"patterns in Rust APIs, such as "
"[visitors](../patterns/behavioural/visitor.md).\n"
"They also have niche use cases."
msgstr ""
"Este é um conceito funcional puro que não é usado com frequência no Rust.\n"
"No entanto, explorar o conceito pode ser útil para entender outras\n"
"padrões em Rust APIs, como [visitors](../patterns/behavioural/visitor.md).\n"
"Eles também têm casos de uso de nicho."

#: src\functional/lenses.md:8
#, fuzzy
msgid "## Lenses: Uniform Access Across Types"
msgstr "## Lentes: Acesso uniforme entre os tipos"

#: src\functional/lenses.md:10
#, fuzzy
msgid ""
"A lens is a concept from functional programming languages that allows\n"
"accessing parts of a data type in an abstract, unified way.[^1]\n"
"In basic concept, it is similar to the way Rust traits work with type "
"erasure,\n"
"but it has a bit more power and flexibility."
msgstr ""
"Uma lente é um conceito de linguagens de programação funcional que permite\n"
"acessando partes de um tipo de dados de forma abstrata e unificada.[^1]\n"
"No conceito básico, é semelhante à maneira como as características do Rust "
"funcionam com o apagamento de tipo,\n"
"mas tem um pouco mais de potência e flexibilidade."

#: src\functional/lenses.md:15
#, fuzzy
msgid ""
"For example, suppose a bank contains several JSON formats for customer\n"
"data.\n"
"This is because they come from different databases or legacy systems.\n"
"One database contains the data needed to perform credit checks:"
msgstr ""
"Por exemplo, suponha que um banco contenha vários formatos JSON para "
"clientes\n"
"dados.\n"
"Isso ocorre porque eles vêm de diferentes bancos de dados ou sistemas "
"legados.\n"
"Um banco de dados contém os dados necessários para realizar verificações de "
"crédito:"

#: src\functional/lenses.md:20
msgid ""
"```json\n"
"{ \"name\": \"Jane Doe\",\n"
"  \"dob\": \"2002-02-24\",\n"
"  [...]\n"
"  \"customer_id\": 1048576332,\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:28
#, fuzzy
msgid "Another one contains the account information:"
msgstr "Outro contém as informações da conta:"

#: src\functional/lenses.md:30
msgid ""
"```json\n"
"{ \"customer_id\": 1048576332,\n"
"  \"accounts\": [\n"
"      { \"account_id\": 2121,\n"
"        \"account_type: \"savings\",\n"
"        \"joint_customer_ids\": [],\n"
"        [...]\n"
"      },\n"
"      { \"account_id\": 2122,\n"
"        \"account_type: \"checking\",\n"
"        \"joint_customer_ids\": [1048576333],\n"
"        [...]\n"
"      },\n"
"  ]\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:47
#, fuzzy
msgid ""
"Notice that both types have a customer ID number which corresponds to a "
"person.\n"
"How would a single function handle both records of different types?"
msgstr ""
"Observe que ambos os tipos têm um número de identificação do cliente que "
"corresponde a uma pessoa.\n"
"Como uma única função lidaria com ambos os registros de tipos diferentes?"

#: src\functional/lenses.md:50
#, fuzzy
msgid ""
"In Rust, a `struct` could represent each of these types, and a trait would "
"have\n"
"a `get_customer_id` function they would implement:"
msgstr ""
"Em Rust, uma `struct` poderia representar cada um desses tipos, e um trait "
"teria\n"
"uma função `get_customer_id` que eles implementariam:"

#: src\functional/lenses.md:53
msgid ""
"```rust\n"
"use std::collections::HashSet;\n"
"\n"
"pub struct Account {\n"
"    account_id: u32,\n"
"    account_type: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"pub trait CustomerId {\n"
"    fn get_customer_id(&self) -> u64;\n"
"}\n"
"\n"
"pub struct CreditRecord {\n"
"    customer_id: u64,\n"
"    name: String,\n"
"    dob: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"impl CustomerId for CreditRecord {\n"
"    fn get_customer_id(&self) -> u64 {\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"pub struct AccountRecord {\n"
"    customer_id: u64,\n"
"    accounts: Vec<Account>,\n"
"}\n"
"\n"
"impl CustomerId for AccountRecord {\n"
"    fn get_customer_id(&self) -> u64 {\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"// static polymorphism: only one type, but each function call can choose it\n"
"fn unique_ids_set<R: CustomerId>(records: &[R]) -> HashSet<u64> {\n"
"    records.iter().map(|r| r.get_customer_id()).collect()\n"
"}\n"
"\n"
"// dynamic dispatch: iterates over any type with a customer ID, collecting "
"all\n"
"// values together\n"
"fn unique_ids_iter<I>(iterator: I) -> HashSet<u64>\n"
"    where I: Iterator<Item=Box<dyn CustomerId>>\n"
"{\n"
"    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:104
#, fuzzy
msgid ""
"Lenses, however, allow the code supporting customer ID to be moved from the\n"
"_type_ to the _accessor function_.\n"
"Rather than implementing a trait on each type, all matching structures can\n"
"simply be accessed the same way."
msgstr ""
"As lentes, no entanto, permitem que o código que suporta a ID do cliente "
"seja movido do\n"
"_type_ para a função _accessor_.\n"
"Em vez de implementar uma característica em cada tipo, todas as estruturas "
"correspondentes podem\n"
"simplesmente ser acessado da mesma maneira."

#: src\functional/lenses.md:109
#, fuzzy
msgid ""
"While the Rust language itself does not support this (type erasure is the\n"
"preferred solution to this problem), the [lens-rs "
"crate](https://github.com/TOETOE55/lens-rs/blob/master/guide.md) allows "
"code\n"
"that feels like this to be written with macros:"
msgstr ""
"Embora a própria linguagem Rust não suporte isso (o apagamento de tipo é o\n"
"solução preferida para este problema), o [lens-rs "
"crate](https://github.com/TOETOE55/lens-rs/blob/master/guide.md) permite o "
"código\n"
"que se sente assim para ser escrito com macros:"

#: src\functional/lenses.md:113
msgid ""
"```rust,ignore\n"
"use std::collections::HashSet;\n"
"\n"
"use lens_rs::{optics, Lens, LensRef, Optics};\n"
"\n"
"#[derive(Clone, Debug, Lens /* derive to allow lenses to work */)]\n"
"pub struct CreditRecord {\n"
"    #[optic(ref)] // macro attribute to allow viewing this field\n"
"    customer_id: u64,\n"
"    name: String,\n"
"    dob: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"#[derive(Clone, Debug)]\n"
"pub struct Account {\n"
"    account_id: u32,\n"
"    account_type: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"#[derive(Clone, Debug, Lens)]\n"
"pub struct AccountRecord {\n"
"    #[optic(ref)]\n"
"    customer_id: u64,\n"
"    accounts: Vec<Account>,\n"
"}\n"
"\n"
"fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -> HashSet<u64>\n"
"where\n"
"    T: LensRef<Optics![customer_id], u64>, // any type with this field\n"
"{\n"
"    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:149
#, fuzzy
msgid ""
"The version of `unique_ids_lens` shown here allows any type to be in the "
"iterator,\n"
"so long as it has an attribute called `customer_id` which can be accessed "
"by\n"
"the function.\n"
"This is how most functional programming languages operate on lenses."
msgstr ""
"A versão de `unique_ids_lens` mostrada aqui permite que qualquer tipo esteja "
"no iterador,\n"
"desde que tenha um atributo chamado `customer_id` que pode ser acessado por\n"
"a função.\n"
"É assim que a maioria das linguagens de programação funcionais operam nas "
"lentes."

#: src\functional/lenses.md:154
#, fuzzy
msgid ""
"Rather than macros, they achieve this with a technique known as "
"\"currying\".\n"
"That is, they \"partially construct\" the function, leaving the type of the\n"
"final parameter (the value being operated on) unfilled until the function "
"is\n"
"called.\n"
"Thus it can be called with different types dynamically even from one place "
"in\n"
"the code.\n"
"That is what the `optics!` and `view_ref` in the example above simulates."
msgstr ""
"Em vez de macros, eles conseguem isso com uma técnica conhecida como "
"\"currying\".\n"
"Ou seja, eles \"constroem parcialmente\" a função, deixando o tipo do\n"
"parâmetro final (o valor que está sendo operado) não preenchido até que a "
"função seja\n"
"chamado.\n"
"Assim, pode ser chamado com diferentes tipos dinamicamente, mesmo de um "
"lugar em\n"
"o código.\n"
"Isso é o que `optics!` e `view_ref` no exemplo acima simulam."

#: src\functional/lenses.md:162
#, fuzzy
msgid ""
"The functional approach need not be restricted to accessing members.\n"
"More powerful lenses can be created which both _set_ and _get_ data in a\n"
"structure.\n"
"But the concept really becomes interesting when used as a building block "
"for\n"
"composition.\n"
"That is where the concept appears more clearly in Rust."
msgstr ""
"A abordagem funcional não precisa ser restrita aos membros de acesso.\n"
"Podem ser criadas lentes mais poderosas que _configuram_ e _obtêm_ dados em "
"um\n"
"estrutura.\n"
"Mas o conceito realmente se torna interessante quando usado como bloco de "
"construção para\n"
"composição.\n"
"É aí que o conceito aparece com mais clareza em Rust."

#: src\functional/lenses.md:169
#, fuzzy
msgid "## Prisms: A Higher-Order form of \"Optics\""
msgstr "## Prismas: Uma forma de ordem superior de \"Óptica\""

#: src\functional/lenses.md:171
#, fuzzy
msgid ""
"A simple function such as `unique_ids_lens` above operates on a single "
"lens.\n"
"A _prism_ is a function that operates on a _family_ of lenses.\n"
"It is one conceptual level higher, using lenses as a building block, and\n"
"continuing the metaphor, is part of a family of \"optics\".\n"
"It is the main one that is useful in understanding Rust APIs, so will be "
"the\n"
"focus here."
msgstr ""
"Uma função simples como `unique_ids_lens` acima opera em uma única lente.\n"
"Um _prisma_ é uma função que opera em uma _família_ de lentes.\n"
"É um nível conceitual superior, usando lentes como bloco de construção e\n"
"continuando a metáfora, faz parte de uma família de \"ópticas\".\n"
"É o principal que é útil para entender as APIs do Rust, assim será o\n"
"foco aqui."

#: src\functional/lenses.md:178
#, fuzzy
msgid ""
"The same way that traits allow \"lens-like\" design with static polymorphism "
"and\n"
"dynamic dispatch, prism-like designs appear in Rust APIs which split "
"problems\n"
"into multiple associated types to be composed.\n"
"A good example of this is the traits in the parsing crate _Serde_."
msgstr ""
"Da mesma forma que as características permitem um design \"semelhante a uma "
"lente\" com polimorfismo estático e\n"
"despacho dinâmico, designs semelhantes a prismas aparecem em APIs Rust que "
"dividem problemas\n"
"em vários tipos associados a serem compostos.\n"
"Um bom exemplo disso são as características na caixa de análise _Serde_."

#: src\functional/lenses.md:183
#, fuzzy
msgid ""
"Trying to understand the way _Serde_ works by only reading the API is a\n"
"challenge, especially the first time.\n"
"Consider the `Deserializer` trait, implemented by some type in any library\n"
"which parses a new format:"
msgstr ""
"Tentar entender como o _Serde_ funciona apenas lendo a API é uma\n"
"desafio, especialmente na primeira vez.\n"
"Considere o trait `Deserializer`, implementado por algum tipo em qualquer "
"biblioteca\n"
"que analisa um novo formato:"

#: src\functional/lenses.md:188
msgid ""
"```rust,ignore\n"
"pub trait Deserializer<'de>: Sized {\n"
"    type Error: Error;\n"
"\n"
"    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, "
"Self::Error>\n"
"    where\n"
"        V: Visitor<'de>;\n"
"\n"
"    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, "
"Self::Error>\n"
"    where\n"
"        V: Visitor<'de>;\n"
"\n"
"    // remainder ommitted\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:204
#, fuzzy
msgid ""
"For a trait that is just supposed to parse data from a format and return a\n"
"value, this looks odd."
msgstr ""
"Para uma característica que deve apenas analisar dados de um formato e "
"retornar um\n"
"valor, isso parece estranho."

#: src\functional/lenses.md:207
#, fuzzy
msgid "Why are all the return types type erased?"
msgstr "Por que todos os tipos de retorno são apagados?"

#: src\functional/lenses.md:209
#, fuzzy
msgid ""
"To understand that, we need to keep the lens concept in mind and look at\n"
"the definition of the `Visitor` type that is passed in generically:"
msgstr ""
"Para entender isso, precisamos manter o conceito de lente em mente e olhar "
"para\n"
"a definição do tipo `Visitor` que é passado genericamente:"

#: src\functional/lenses.md:212
msgid ""
"```rust,ignore\n"
"pub trait Visitor<'de>: Sized {\n"
"    type Value;\n"
"\n"
"    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    // remainder omitted\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:232
#, fuzzy
msgid ""
"The job of the `Visitor` type is to construct values in the _Serde_ data "
"model,\n"
"which are represented by its associated `Value` type."
msgstr ""
"O trabalho do tipo `Visitor` é construir valores no modelo de dados "
"_Serde_,\n"
"que são representados por seu tipo `Value` associado."

#: src\functional/lenses.md:235
#, fuzzy
msgid ""
"These values represent parts of the Rust value being deserialized.\n"
"If this fails, it returns an `Error` type - an error type determined by the\n"
"`Deserializer` when its methods were called."
msgstr ""
"Esses valores representam partes do valor Rust sendo desserializado.\n"
"Se falhar, ele retornará um tipo `Error` - um tipo de erro determinado pelo\n"
"`Deserializer` quando seus métodos foram chamados."

#: src\functional/lenses.md:239
#, fuzzy
msgid ""
"This highlights that `Deserializer` is similar to `CustomerId` from "
"earlier,\n"
"allowing any format parser which implements it to create `Value`s based on "
"what\n"
"it parsed.\n"
"The `Value` trait is acting like a lens in functional programming languages."
msgstr ""
"Isso destaca que `Deserializer` é semelhante a `CustomerId` de antes,\n"
"permitindo que qualquer analisador de formato que o implemente crie "
"`Valores`s com base no que\n"
"ele analisou.\n"
"O traço `Valor` está agindo como uma lente em linguagens de programação "
"funcional."

#: src\functional/lenses.md:244
#, fuzzy
msgid ""
"But unlike the `CustomerId` trait, the return types of `Visitor` methods "
"are\n"
"_generic_, and the concrete `Value` type is _determined by the Visitor "
"itself_."
msgstr ""
"Mas ao contrário do trait `CustomerId`, os tipos de retorno dos métodos "
"`Visitor` são\n"
"_genérico_, e o tipo `Valor` concreto é _determinado pelo próprio Visitante_."

#: src\functional/lenses.md:247
#, fuzzy
msgid ""
"Instead of acting as one lens, it effectively acts as a family of\n"
"lenses, one for each concrete type of `Visitor`."
msgstr ""
"Em vez de atuar como uma lente, ela efetivamente atua como uma família de\n"
"lentes, uma para cada tipo concreto de 'Visitante'."

#: src\functional/lenses.md:250
#, fuzzy
msgid ""
"The `Deserializer` API is based on having a generic set of \"lenses\" work "
"across\n"
"a set of other generic types for \"observation\".\n"
"It is a _prism_."
msgstr ""
"A API `Deserializer` é baseada em ter um conjunto genérico de \"lentes\" "
"trabalhando\n"
"um conjunto de outros tipos genéricos para \"observação\".\n"
"É um _prisma_."

#: src\functional/lenses.md:254
#, fuzzy
msgid "For example, consider the identity record from earlier but simplified:"
msgstr ""
"Por exemplo, considere o registro de identidade anterior, mas simplificado:"

#: src\functional/lenses.md:256
msgid ""
"```json\n"
"{ \"name\": \"Jane Doe\",\n"
"  \"customer_id\": 1048576332,\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:262
#, fuzzy
msgid ""
"How would the _Serde_ library deserialize this JSON into `struct "
"CreditRecord`?"
msgstr ""
"Como a biblioteca _Serde_ desserializaria este JSON em `struct CreditRecord`?"

#: src\functional/lenses.md:264
#, fuzzy
msgid ""
"1. The user would call a library function to deserialize the data. This "
"would\n"
"   create a `Deserializer` based on the JSON format.\n"
"1. Based on the fields in the struct, a `Visitor` would be created (more on\n"
"   that in a moment) which knows how to create each type in a generic data\n"
"   model that was needed to represent it: `u64` and `String`.\n"
"1. The deserializer would make calls to the `Visitor` as it parsed items.\n"
"1. The `Visitor` would indicate if the items found were expected, and if "
"not,\n"
"   raise an error to indicate deserialization has failed."
msgstr ""
"1. O usuário chamaria uma função de biblioteca para desserializar os dados. "
"Isso seria\n"
"   crie um `Deserializer` baseado no formato JSON.\n"
"1. Com base nos campos da estrutura, um `Visitor` seria criado (mais sobre\n"
"   isso daqui a pouco) que sabe como criar cada tipo em um data genérico\n"
"   modelo necessário para representá-lo: `u64` e `String`.\n"
"1. O desserializador faria chamadas para o `Visitor` enquanto analisava os "
"itens.\n"
"1. O 'Visitante' indicaria se os itens encontrados eram esperados e, se "
"não,\n"
"   gera um erro para indicar que a desserialização falhou."

#: src\functional/lenses.md:273
#, fuzzy
msgid "For our very simple structure above, the expected pattern would be:"
msgstr "Para nossa estrutura muito simples acima, o padrão esperado seria:"

#: src\functional/lenses.md:275
#, fuzzy
msgid ""
"1. Visit a map (_Serde_'s equvialent to `HashMap` or JSON's dictionary).\n"
"1. Visit a string key called \"name\".\n"
"1. Visit a string value, which will go into the `name` field.\n"
"1. Visit a string key called \"customer_id\".\n"
"1. Visit a string value, which will go into the `customer_id` field.\n"
"1. Visit the end of the map."
msgstr ""
"1. Visite um mapa (equivalente de _Serde_ a `HashMap` ou dicionário de "
"JSON).\n"
"1. Visite uma chave de string chamada \"nome\".\n"
"1. Visite um valor de string, que irá para o campo `name`.\n"
"1. Visite uma chave de string chamada \"customer_id\".\n"
"1. Visite um valor de string, que irá para o campo `customer_id`.\n"
"1. Visite o final do mapa."

#: src\functional/lenses.md:282
#, fuzzy
msgid "But what determines which \"observation\" pattern is expected?"
msgstr "Mas o que determina qual padrão de \"observação\" é esperado?"

#: src\functional/lenses.md:284
#, fuzzy
msgid ""
"A functional programming language would be able to use currying to create\n"
"reflection of each type based on the type itself.\n"
"Rust does not support that, so every single type would need to have its own\n"
"code written based on its fields and their properties."
msgstr ""
"Uma linguagem de programação funcional seria capaz de usar currying para "
"criar\n"
"reflexão de cada tipo com base no próprio tipo.\n"
"Rust não suporta isso, então cada tipo precisaria ter seu próprio\n"
"código escrito com base em seus campos e suas propriedades."

#: src\functional/lenses.md:289
#, fuzzy
msgid "_Serde_ solves this usability challenge with a derive macro:"
msgstr "_Serde_ resolve esse desafio de usabilidade com uma macro de derivação:"

#: src\functional/lenses.md:291
msgid ""
"```rust,ignore\n"
"use serde::Deserialize;\n"
"\n"
"#[derive(Deserialize)]\n"
"struct IdRecord {\n"
"    name: String,\n"
"    customer_id: String,\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:301
#, fuzzy
msgid ""
"That macro simply generates an impl block causing the struct to implement a\n"
"trait called `Deserialize`."
msgstr ""
"Essa macro simplesmente gera um bloco impl fazendo com que o struct "
"implemente um\n"
"traço chamado `Deserialize`."

#: src\functional/lenses.md:304
#, fuzzy
msgid "It is defined this way:"
msgstr "É definido desta forma:"

#: src\functional/lenses.md:306
msgid ""
"```rust,ignore\n"
"pub trait Deserialize<'de>: Sized {\n"
"    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
"    where\n"
"        D: Deserializer<'de>;\n"
"}\n"
"```"
msgstr ""

#: src\functional/lenses.md:314
#, fuzzy
msgid ""
"This is the function that determines how to create the struct itself.\n"
"Code is generated based on the struct's fields.\n"
"When the parsing library is called - in our example, a JSON parsing library "
"-\n"
"it creates a `Deserializer` and calls `Type::deserialize` with it as a\n"
"parameter."
msgstr ""
"Esta é a função que determina como criar a própria estrutura.\n"
"O código é gerado com base nos campos da estrutura.\n"
"Quando a biblioteca de análise é chamada - em nosso exemplo, uma biblioteca "
"de análise JSON -\n"
"ele cria um `Deserializer` e chama `Type::deserialize` com ele como um\n"
"parâmetro."

#: src\functional/lenses.md:320
#, fuzzy
msgid ""
"The `deserialize` code will then create a `Visitor` which will have its "
"calls\n"
"\"refracted\" by the `Deserializer`.\n"
"If everything goes well, eventually that `Visitor` will construct a value\n"
"corresponding to the type being parsed and return it."
msgstr ""
"O código `deserialize` criará então um `Visitor` que terá suas chamadas\n"
"\"refratado\" pelo `Deserializer`.\n"
"Se tudo correr bem, eventualmente esse `Visitor` construirá um valor\n"
"correspondente ao tipo que está sendo analisado e retorná-lo."

#: src\functional/lenses.md:325
#, fuzzy
msgid ""
"For a complete example, see the [_Serde_ "
"documentation](https://serde.rs/deserialize-struct.html)."
msgstr ""
"Para obter um exemplo completo, consulte a [documentação do "
"_Serde_](https://serde.rs/deserialize-struct.html)."

#: src\functional/lenses.md:327
#, fuzzy
msgid "To wrap up, this is the power of _Serde_:"
msgstr "Para finalizar, este é o poder do _Serde_:"

#: src\functional/lenses.md:329
#, fuzzy
msgid ""
"1. The structure being parsed is represented by an `impl` block for "
"`Deserialize`\n"
"1. The input data format (e.g. JSON) is represented by a `Deserializer` "
"called\n"
"   by `Deserialize`\n"
"1. The `Deserializer` acts like a prism which \"refracts\" lens-like "
"`Visitor`\n"
"   calls which actually build the data value"
msgstr ""
"1. A estrutura que está sendo analisada é representada por um bloco `impl` "
"para `Deserialize`\n"
"1. O formato de dados de entrada (por exemplo, JSON) é representado por um "
"`Deserializer` chamado\n"
"   por `Deserialize`\n"
"1. O `Deserializer` age como um prisma que \"refrata\" o `Visitor` "
"semelhante a uma lente\n"
"   chamadas que realmente constroem o valor dos dados"

#: src\functional/lenses.md:335
#, fuzzy
msgid ""
"The result is that types to be deserialized only implement the \"top layer\" "
"of\n"
"the API, and file formats only need to implement the \"bottom layer\".\n"
"Each piece can then \"just work\" with the rest of the ecosystem, since "
"generic\n"
"types will bridge them."
msgstr ""
"O resultado é que os tipos a serem desserializados implementam apenas a "
"\"camada superior\" de\n"
"a API e os formatos de arquivo só precisam implementar a \"camada "
"inferior\".\n"
"Cada peça pode então \"simplesmente funcionar\" com o resto do ecossistema, "
"desde\n"
"os tipos os unirão."

#: src\functional/lenses.md:340
#, fuzzy
msgid ""
"To emphasize, the only reason this model works on any format and any type "
"is\n"
"because the `Deserializer` trait's output type **is specified by the\n"
"implementor of `Visitor` it is passed**, rather than being tied to one "
"specific\n"
"type.\n"
"This was not true in the account example earlier."
msgstr ""
"Para enfatizar, a única razão pela qual este modelo funciona em qualquer "
"formato e qualquer tipo é\n"
"porque o tipo de saída do trait `Deserializer` ** é especificado pelo\n"
"implementador de `Visitor` é passado**, em vez de ser vinculado a um "
"específico\n"
"tipo.\n"
"Isso não era verdade no exemplo de conta anterior."

#: src\functional/lenses.md:346
#, fuzzy
msgid ""
"Rust's generic-inspired type system can bring it close to these concepts "
"and\n"
"use their power, as shown in this API design.\n"
"But it may also need procedural macros to create bridges for its generics."
msgstr ""
"O sistema de tipo de inspiração genérica de Rust pode aproximá-lo desses "
"conceitos e\n"
"use seu poder, conforme mostrado neste design de API.\n"
"Mas também pode precisar de macros processuais para criar pontes para seus "
"genéricos."

#: src\functional/lenses.md:350
#, fuzzy
msgid "## See Also"
msgstr "## Veja também"

#: src\functional/lenses.md:352
#, fuzzy
msgid ""
"- [lens-rs crate](https://crates.io/crates/lens-rs) for a pre-built lenses\n"
"  implementation, with a cleaner interface than these examples\n"
"- [serde](https://serde.rs) itself, which makes these concepts intuitive "
"for\n"
"  end users (i.e. defining the structs) without needing to undestand the\n"
"  details\n"
"- [luminance](https://github.com/phaazon/luminance-rs) is a crate for "
"drawing\n"
"  computer graphics that uses lens API design, including proceducal macros "
"to\n"
"  create full prisms for buffers of different pixel types that remain "
"generic\n"
"- [An Article about Lenses in "
"Scala](https://web.archive.org/web/20221128185849/https://medium.com/zyseme-technology/functional-references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
"  that is very readable even without Scala expertise.\n"
"- [Paper: Profunctor Optics: Modular Data\n"
"  "
"Accessors](https://web.archive.org/web/20220701102832/https://arxiv.org/ftp/arxiv/papers/1703/1703.10857.pdf)"
msgstr ""
"- [lens-rs crate](https://crates.io/crates/lens-rs) para lentes "
"pré-construídas\n"
"  implementação, com uma interface mais limpa do que esses exemplos\n"
"- [serde](https://serde.rs) em si, o que torna esses conceitos intuitivos "
"para\n"
"  usuários finais (isto é, definindo as estruturas) sem precisar entender o\n"
"  detalhes\n"
"- [luminância](https://github.com/phaazon/luminance-rs) é uma caixa para "
"desenho\n"
"  computação gráfica que usa design de API de lentes, incluindo macros "
"processuais para\n"
"  criar prismas completos para buffers de diferentes tipos de pixel que "
"permanecem genéricos\n"
"- [Um artigo sobre lentes em "
"Scala](https://web.archive.org/web/20221128185849/https://medium.com/zyseme-technology/functional-references-lens-and-other-optics-in- "
"scala-e5f7e2fdafe)\n"
"  que é muito legível mesmo sem experiência em Scala.\n"
"- [Papel: Profunctor Optics: Modular Data\n"
"  "
"Acessadores](https://web.archive.org/web/20220701102832/https://arxiv.org/ftp/arxiv/papers/1703/1703.10857.pdf)"

#: src\functional/lenses.md:365
#, fuzzy
msgid ""
"[School of Haskell: A Little Lens Starter "
"Tutorial](https://web.archive.org/web/20221128190041/https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial)"
msgstr ""
"[Escola de Haskell: um pequeno tutorial para iniciantes em "
"lentes](https://web.archive.org/web/20221128190041/https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of- "
"the-week/a-little-lens-starter-tutorial)"

#: src\additional_resources/index.md:1
#, fuzzy
msgid "# Additional resources"
msgstr "# Recursos adicionais"

#: src\additional_resources/index.md:3
#, fuzzy
msgid "A collection of complementary helpful content"
msgstr "Uma coleção de conteúdo útil complementar"

#: src\additional_resources/index.md:5
#, fuzzy
msgid "## Talks"
msgstr "## Palestras"

#: src\additional_resources/index.md:7
#, fuzzy
msgid ""
"- [Design Patterns in Rust](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by\n"
"  Nicholas Cameron at the PDRust (2016)\n"
"- [Writing Idiomatic Libraries in "
"Rust](https://www.youtube.com/watch?v=0zOg8_B71gE)\n"
"  by Pascal Hertleif at RustFest (2017)\n"
"- [Rust Programming Techniques](https://www.youtube.com/watch?v=vqavdUGKeb4) "
"by\n"
"  Nicholas Cameron at LinuxConfAu (2018)"
msgstr ""
"- [Padrões de design em "
"ferrugem](https://www.youtube.com/watch?v=Pm_oO0N5B9k) por\n"
"  Nicholas Cameron no PDRust (2016)\n"
"- [Escrevendo bibliotecas idiomáticas em "
"ferrugem](https://www.youtube.com/watch?v=0zOg8_B71gE)\n"
"  por Pascal Hertleif no RustFest (2017)\n"
"- [Técnicas de Programação "
"Rust](https://www.youtube.com/watch?v=vqavdUGKeb4) por\n"
"  Nicholas Cameron na LinuxConfAu (2018)"

#: src\additional_resources/index.md:14
#, fuzzy
msgid "## Books (Online)"
msgstr "## Livros (On-line)"

#: src\additional_resources/index.md:16
#, fuzzy
msgid "- [The Rust API Guidelines](https://rust-lang.github.io/api-guidelines)"
msgstr "- [Diretrizes da Rust API](https://rust-lang.github.io/api-guidelines)"

#: src\additional_resources/design-principles.md:1
#, fuzzy
msgid "# Design principles"
msgstr "# Princípios de design"

#: src\additional_resources/design-principles.md:3
#, fuzzy
msgid "## A brief overview over common design principles"
msgstr "## Uma breve visão geral sobre os princípios de design comuns"

#: src\additional_resources/design-principles.md:7
#, fuzzy
msgid "## [SOLID](https://en.wikipedia.org/wiki/SOLID)"
msgstr "## [SOLID](https://en.wikipedia.org/wiki/SOLID)"

#: src\additional_resources/design-principles.md:9
#, fuzzy
msgid ""
"- [Single Responsibility Principle "
"(SRP)](https://en.wikipedia.org/wiki/Single-responsibility_principle):\n"
"  A class should only have a single responsibility, that is, only changes "
"to\n"
"  one part of the software's specification should be able to affect the\n"
"  specification of the class.\n"
"- [Open/Closed Principle "
"(OCP)](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle):\n"
"  \"Software entities ... should be open for extension, but closed for\n"
"  modification.\"\n"
"- [Liskov Substitution Principle "
"(LSP)](https://en.wikipedia.org/wiki/Liskov_substitution_principle):\n"
"  \"Objects in a program should be replaceable with instances of their "
"subtypes\n"
"  without altering the correctness of that program.\"\n"
"- [Interface Segregation Principle "
"(ISP)](https://en.wikipedia.org/wiki/Interface_segregation_principle):\n"
"  \"Many client-specific interfaces are better than one general-purpose\n"
"  interface.\"\n"
"- [Dependency Inversion Principle "
"(DIP)](https://en.wikipedia.org/wiki/Dependency_inversion_principle):\n"
"  One should \"depend upon abstractions, [not] concretions.\""
msgstr ""
"- [Princípio de Responsabilidade Única "
"(SRP)](https://en.wikipedia.org/wiki/Single-responsibility_principle):\n"
"  Uma classe deve ter apenas uma única responsabilidade, ou seja, apenas "
"alterações\n"
"  uma parte da especificação do software deve ser capaz de afetar o\n"
"  especificação da classe.\n"
"- [Princípio Aberto/Fechado "
"(OCP)](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle):\n"
"  \"Entidades de software ... devem estar abertas para extensão, mas "
"fechadas para\n"
"  modificação.\"\n"
"- [Princípio de Substituição de Liskov "
"(LSP)](https://en.wikipedia.org/wiki/Liskov_substitution_principle):\n"
"  \"Objetos em um programa devem ser substituíveis por instâncias de seus "
"subtipos\n"
"  sem alterar a correção desse programa.\"\n"
"- [Princípio de Segregação de Interface "
"(ISP)](https://en.wikipedia.org/wiki/Interface_segregation_principle):\n"
"  \"Muitas interfaces específicas do cliente são melhores do que uma de uso "
"geral\n"
"  interface.\"\n"
"- [Princípio de Inversão de Dependência "
"(DIP)](https://en.wikipedia.org/wiki/Dependency_inversion_principle):\n"
"  Deve-se \"depender de abstrações, [não] concreções\"."

#: src\additional_resources/design-principles.md:25
#, fuzzy
msgid ""
"## [DRY (Don’t Repeat "
"Yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)"
msgstr ""
"## [DRY (Don't Repeat "
"Yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)"

#: src\additional_resources/design-principles.md:27
#, fuzzy
msgid ""
"\"Every piece of knowledge must have a single, unambiguous, authoritative\n"
"representation within a system\""
msgstr ""
"“Cada pedaço de conhecimento deve ter um único, inequívoco, autoritário\n"
"representação dentro de um sistema\""

#: src\additional_resources/design-principles.md:30
#, fuzzy
msgid "## [KISS principle](https://en.wikipedia.org/wiki/KISS_principle)"
msgstr "## [princípio KISS](https://en.wikipedia.org/wiki/KISS_principle)"

#: src\additional_resources/design-principles.md:32
msgid ""
"most systems work best if they are kept simple rather than made "
"complicated;\n"
"therefore, simplicity should be a key goal in design, and unnecessary\n"
"complexity should be avoided"
msgstr ""

#: src\additional_resources/design-principles.md:36
#, fuzzy
msgid "## [Law of Demeter (LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"
msgstr "## [Lei de Demeter (LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"

#: src\additional_resources/design-principles.md:38
#, fuzzy
msgid ""
"a given object should assume as little as possible about the structure or\n"
"properties of anything else (including its subcomponents), in accordance "
"with\n"
"the principle of \"information hiding\""
msgstr ""
"um determinado objeto deve assumir o mínimo possível sobre a estrutura ou\n"
"propriedades de qualquer outra coisa (incluindo seus subcomponentes), de "
"acordo com\n"
"o princípio de \"ocultação de informações\""

#: src\additional_resources/design-principles.md:42
#, fuzzy
msgid ""
"## [Design by contract "
"(DbC)](https://en.wikipedia.org/wiki/Design_by_contract)"
msgstr ""
"## [Design por contrato "
"(DbC)](https://en.wikipedia.org/wiki/Design_by_contract)"

#: src\additional_resources/design-principles.md:44
#, fuzzy
msgid ""
"software designers should define formal, precise and verifiable interface\n"
"specifications for software components, which extend the ordinary definition "
"of\n"
"abstract data types with preconditions, postconditions and invariants"
msgstr ""
"designers de software devem definir interface formal, precisa e verificável\n"
"especificações para componentes de software, que estendem a definição comum "
"de\n"
"tipos de dados abstratos com pré-condições, pós-condições e invariantes"

#: src\additional_resources/design-principles.md:48
#, fuzzy
msgid ""
"## "
"[Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))"
msgstr ""
"## "
"[Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))"

#: src\additional_resources/design-principles.md:50
#, fuzzy
msgid ""
"bundling of data with the methods that operate on that data, or the "
"restricting\n"
"of direct access to some of an object's components. Encapsulation is used "
"to\n"
"hide the values or state of a structured data object inside a class, "
"preventing\n"
"unauthorized parties' direct access to them."
msgstr ""
"agrupamento de dados com os métodos que operam nesses dados, ou a restrição\n"
"de acesso direto a alguns dos componentes de um objeto. O encapsulamento é "
"usado para\n"
"ocultar os valores ou estado de um objeto de dados estruturados dentro de "
"uma classe, evitando\n"
"acesso direto de partes não autorizadas a eles."

#: src\additional_resources/design-principles.md:55
#, fuzzy
msgid ""
"## "
"[Command-Query-Separation(CQS)](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation)"
msgstr ""
"## "
"[Command-Query-Separation(CQS)](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation)"

#: src\additional_resources/design-principles.md:57
#, fuzzy
msgid ""
"“Functions should not produce abstract side effects...only commands\n"
"(procedures) will be permitted to produce side effects.” - Bertrand Meyer:\n"
"Object-Oriented Software Construction"
msgstr ""
"“As funções não devem produzir efeitos colaterais abstratos... apenas "
"comandos\n"
"(procedimentos) serão permitidos para produzir efeitos colaterais.” "
"-Bertrand Meyer:\n"
"Construção de Software Orientado a Objetos"

#: src\additional_resources/design-principles.md:61
#, fuzzy
msgid ""
"## [Principle of least astonishment "
"(POLA)](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)"
msgstr ""
"## [Princípio do menor espanto "
"(POLA)](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)"

#: src\additional_resources/design-principles.md:63
#, fuzzy
msgid ""
"a component of a system should behave in a way that most users will expect "
"it\n"
"to behave. The behavior should not astonish or surprise users"
msgstr ""
"um componente de um sistema deve se comportar de uma maneira que a maioria "
"dos usuários espera\n"
"comportar-se. O comportamento não deve surpreender ou surpreender os usuários"

#: src\additional_resources/design-principles.md:66
#, fuzzy
msgid "## Linguistic-Modular-Units"
msgstr "## Linguistic-Modular-Units"

#: src\additional_resources/design-principles.md:68
#, fuzzy
msgid ""
"“Modules must correspond to syntactic units in the language used.” - "
"Bertrand\n"
"Meyer: Object-Oriented Software Construction"
msgstr ""
"“Os módulos devem corresponder às unidades sintáticas da linguagem "
"utilizada.” -Bertrand\n"
"Meyer: Construção de Software Orientado a Objetos"

#: src\additional_resources/design-principles.md:71
#, fuzzy
msgid "## Self-Documentation"
msgstr "## Autodocumentação"

#: src\additional_resources/design-principles.md:73
#, fuzzy
msgid ""
"“The designer of a module should strive to make all information about the\n"
"module part of the module itself.” - Bertrand Meyer: Object-Oriented "
"Software\n"
"Construction"
msgstr ""
"“O projetista de um módulo deve se esforçar para tornar todas as informações "
"sobre o\n"
"parte do módulo do próprio módulo.” - Bertrand Meyer: Software Orientado a "
"Objetos\n"
"Construção"

#: src\additional_resources/design-principles.md:77
#, fuzzy
msgid "## Uniform-Access"
msgstr "## Uniform-Access"

#: src\additional_resources/design-principles.md:79
#, fuzzy
msgid ""
"“All services offered by a module should be available through a uniform\n"
"notation, which does not betray whether they are implemented through storage "
"or\n"
"through computation.” - Bertrand Meyer: Object-Oriented Software Construction"
msgstr ""
"“Todos os serviços oferecidos por um módulo devem estar disponíveis por meio "
"de um\n"
"notação, que não revela se eles são implementados por meio de armazenamento "
"ou\n"
"através da computação”. - Bertrand Meyer: Construção de Software Orientado a "
"Objetos"

#: src\additional_resources/design-principles.md:83
#, fuzzy
msgid "## Single-Choice"
msgstr "## Escolha única"

#: src\additional_resources/design-principles.md:85
#, fuzzy
msgid ""
"“Whenever a software system must support a set of alternatives, one and "
"only\n"
"one module in the system should know their exhaustive list.” - Bertrand "
"Meyer:\n"
"Object-Oriented Software Construction"
msgstr ""
"“Sempre que um sistema de software deve suportar um conjunto de "
"alternativas, uma e somente\n"
"um módulo no sistema deve conhecer sua lista exaustiva.” -Bertrand Meyer:\n"
"Construção de Software Orientado a Objetos"

#: src\additional_resources/design-principles.md:89
#, fuzzy
msgid "## Persistence-Closure"
msgstr "## Persistência-Fechamento"

#: src\additional_resources/design-principles.md:91
#, fuzzy
msgid ""
"“Whenever a storage mechanism stores an object, it must store with it the\n"
"dependents of that object. Whenever a retrieval mechanism retrieves a\n"
"previously stored object, it must also retrieve any dependent of that "
"object\n"
"that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented "
"Software\n"
"Construction"
msgstr ""
"“Sempre que um mecanismo de armazenamento armazena um objeto, ele deve "
"armazenar com ele o\n"
"dependentes desse objeto. Sempre que um mecanismo de recuperação recupera "
"um\n"
"objeto armazenado anteriormente, ele também deve recuperar qualquer "
"dependente desse objeto\n"
"que ainda não foi recuperado.” - Bertrand Meyer: Software Orientado a "
"Objetos\n"
"Construção"

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

msgid ""
msgstr ""

