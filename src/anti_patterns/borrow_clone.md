# 借用チェッカーを満たすためのクローン

## 説明

借用チェッカーは、「変更可能な参照が1つだけ存在する」か、
「潜在的に多くの不変参照が存在する」のいずれかを確保することで、
Rustユーザーが本来なら安全でないコードを開発するのを防ぎます。
書かれたコードがこれらの条件に従わない場合、
開発者が変数をクローンすることでコンパイラエラーを解決するときに、
このアンチパターンが生じます。

## 例

```rust
// 任意の変数を定義
let mut x = 5;

// `x` を借用する -- しかし最初にクローンする
let y = &mut (x.clone());

// 2行前のx.clone()がなければ、この行はコンパイル時に失敗する
// x が借用されているため
// x.clone()のおかげで、x は決して借用されず、この行は実行される
println!("{x}");

// Rustがこれを最適化で除去するのを防ぐために、借用に対して何らかのアクションを実行
*y += 1;
```

## 動機

特に初心者にとって、借用チェッカーとの混乱する問題を解決するために
このパターンを使用することは誘惑的です。しかし、深刻な結果があります。
`.clone()`を使用すると、データのコピーが作成されます。
2つの間での変更は同期されません -- まるで完全に別々の変数が存在するかのようです。

特別なケース -- `Rc<T>`はクローンをインテリジェントに処理するように設計されています。
内部的に正確にデータの1つのコピーを管理します。`Rc`に対して`.clone()`を呼び出すと、
参照カウントを増やしながら、ソース`Rc`と同じデータを指す新しい`Rc`インスタンスが生成されます。
同じことが、`Rc`のスレッドセーフな対応物である`Arc`にも適用されます。

一般的に、クローンは意図的であるべきで、結果を完全に理解した上で行うべきです。
借用チェッカーエラーを消すためにクローンが使用される場合、
それはこのアンチパターンが使用されている可能性がある良い兆候です。

`.clone()`は悪いパターンの兆候であっても、以下のような場合に
**非効率的なコードを書くことは問題ありません**：

- 開発者が所有権にまだ慣れていない
- コードに大きな速度やメモリの制約がない（ハッカソンプロジェクトやプロトタイプなど）
- 借用チェッカーを満足させることが本当に複雑で、パフォーマンスよりも可読性を最適化したい

不要なクローンが疑われる場合、
[Rust Bookの所有権に関する章](https://doc.rust-lang.org/book/ownership.html)
を、クローンが必要かどうかを評価する前に完全に理解する必要があります。

また、プロジェクトで常に`cargo clippy`を実行することを確認してください。
これは`.clone()`が不要な場合を検出します。

## 参照

- [`mem::{take(_), replace(_)}` で変更されたenumで所有される値を保持する](../idioms/mem-replace.md)
- [`Rc<T>` ドキュメント、.clone()をインテリジェントに処理する](http://doc.rust-lang.org/std/rc/)
- [`Arc<T>` ドキュメント、スレッドセーフな参照カウントポインタ](https://doc.rust-lang.org/std/sync/struct.Arc.html)
- [Rustでの所有権のトリック](https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)
