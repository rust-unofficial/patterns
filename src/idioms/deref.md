# コレクションはスマートポインタ

## 説明

[`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)トレイトを使用して、
コレクションをスマートポインタのように扱い、データの所有ビューと借用ビューを提供します。

## 例

```rust,ignore
use std::ops::Deref;

struct Vec<T> {
    data: RawVec<T>,
    //..
}

impl<T> Deref for Vec<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //..
    }
}
```

`Vec<T>`は`T`の所有コレクションであり、一方スライス（`&[T]`）は`T`の借用コレクションです。
`Vec`に`Deref`を実装することで、`&Vec<T>`から`&[T]`への暗黙的な参照外しが可能になり、
自動参照外し検索にその関係が含まれます。`Vec`に実装されることが期待されるほとんどのメソッドは、
代わりにスライスに実装されています。

また、`String`と`&str`も同様の関係を持っています。

## 動機

所有権と借用はRust言語の重要な側面です。データ構造は、良いユーザー体験を提供するために、
これらのセマンティクスを適切に考慮する必要があります。データを所有するデータ構造を実装する際、
そのデータの借用ビューを提供することで、より柔軟なAPIが可能になります。

## 利点

ほとんどのメソッドは借用ビューのみに実装でき、その後、所有ビューで暗黙的に利用可能になります。

クライアントにデータの借用または所有権の取得の選択肢を提供します。

## 欠点

参照外しを介してのみ利用可能なメソッドとトレイトは、境界チェック時に考慮されないため、
このパターンを使用したデータ構造によるジェネリックプログラミングは複雑になる可能性があります
（`Borrow`および`AsRef`トレイトなどを参照）。

## 議論

スマートポインタとコレクションは類似しています：スマートポインタは単一のオブジェクトを指し、
コレクションは多くのオブジェクトを指します。型システムの観点から見ると、両者の間にはほとんど違いがありません。
各データにアクセスする唯一の方法がコレクションを介することであり、コレクションがデータの削除を担当している場合
（共有所有権の場合でも、何らかの借用ビューが適切な場合があります）、コレクションはそのデータを所有しています。
コレクションがデータを所有している場合、データを借用として表示して、複数回参照できるようにすることは通常有用です。

ほとんどのスマートポインタ（例：`Foo<T>`）は`Deref<Target=T>`を実装します。
しかし、コレクションは通常、カスタム型に参照外しされます。`[T]`と`str`には言語サポートがありますが、
一般的な場合、これは必要ありません。`Foo<T>`は`Deref<Target=Bar<T>>`を実装でき、
ここで`Bar`は動的サイズ型であり、`&Bar<T>`は`Foo<T>`のデータの借用ビューです。

一般的に、順序付けられたコレクションは、スライス構文を提供するために`Range`に対して`Index`を実装します。
ターゲットは借用ビューになります。

## 参照

- [Deref多態性アンチパターン](../anti_patterns/deref.md)
- [`Deref`トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait.Deref.html)